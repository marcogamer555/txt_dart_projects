GENERADO: 2025-11-28 12:28:18
PROYECTO: C:/Users/marqu/Programacion/App100MujeresTrabajando/flutter_application_emprendedoras
RAICES: lib
================================================================================

EXTRAS (inicio)
================================================================================


=== RAIZ: lib ===

Dentro de /modules:

Dentro de /features:

Dentro de /admin:

---------------- FILE: modules/features/admin/admin_routes.dart ----------------
// lib/modules/features/admin/admin_routes.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'data/datasources/admin_dashboard_remote_datasource.dart';
import 'data/repositories/admin_dashboard_repository_impl.dart';
import '../catalog/data/datasources/catalog_remote_datasource.dart'
    as catalog_ds;
import '../catalog/data/datasources/categories_remote_datasource.dart'
    as categories_ds;
import '../catalog/data/datasources/products_remote_datasource.dart'
    as products_ds;
import '../catalog/data/repositories/catalog_repository_impl.dart';
import '../catalog/data/repositories/categories_repository_impl.dart';
import '../catalog/data/repositories/catalog_settings_repository_impl.dart';
import '../catalog/data/repositories/products_repository_impl.dart';
import '../catalog/domain/entities/admin_product.dart';
import '../catalog/domain/usecases/admin/save_product_usecase.dart';
import '../catalog/domain/usecases/browse/get_product_usecase.dart';
import '../catalog/domain/usecases/create_category.dart';
import '../catalog/domain/usecases/delete_category.dart';
import '../catalog/domain/usecases/get_admin_products.dart';
import '../catalog/domain/usecases/get_categories.dart';
import '../catalog/domain/usecases/get_primary_categories_limit.dart';
import '../catalog/domain/usecases/reorder_categories.dart';
import '../catalog/domain/usecases/set_primary_categories_limit.dart';
import '../catalog/domain/usecases/toggle_product_visibility.dart';
import '../catalog/domain/usecases/update_category.dart';
import '../catalog/domain/usecases/watch_categories_stream.dart';
import 'domain/usecases/watch_admin_dashboard_summary.dart';
import 'presentation/blocs/admin_dashboard_cubit.dart';
import 'presentation/blocs/admin_nav_cubit.dart';
import 'presentation/pages/dashboard/admin_dashboard_page.dart';
import 'presentation/pages/management/admin_management_host.dart';
import 'presentation/pages/orders/admin_orders_host.dart';
import 'presentation/pages/admin_shell.dart';
import 'presentation/widgets/shared/admin_only.dart';
import '../catalog/domain/repositories/categories_repository.dart';
import '../catalog/presentation/admin/categories/blocs/category_list_cubit.dart';
import '../catalog/presentation/admin/categories/blocs/category_form_cubit.dart';
import '../catalog/presentation/admin/categories/pages/categories_customize_page.dart';
import '../catalog/presentation/admin/categories/pages/category_form_page.dart';
import 'presentation/pages/catalog/admin_catalog_workspace_host.dart';
import '../catalog/presentation/admin/pages/product_form_page.dart';
import '../catalog/presentation/admin/blocs/product_form/product_form_cubit.dart';

class AdminRoutes {
  static const String base = '/admin';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    final path = settings.name ?? base;

    final firestore = FirebaseFirestore.instance;
    final dashboardUsecase = WatchAdminDashboardSummary(
      AdminDashboardRepositoryImpl(AdminDashboardRemoteDataSource(firestore)),
    );

    CatalogRepositoryImpl buildCatalogRepo() {
      final ds = catalog_ds.CatalogRemoteDataSource(firestore);
      return CatalogRepositoryImpl(ds);
    }

    CategoriesRepositoryImpl buildCategoriesRepo() {
      final ds = categories_ds.CategoriesRemoteDataSource(firestore);
      return CategoriesRepositoryImpl(ds);
    }

    ProductsRepositoryImpl buildProductsRepo() {
      final ds = products_ds.ProductsRemoteDataSourceImpl(firestore);
      return ProductsRepositoryImpl(ds);
    }

    Widget wrap(Widget child, {bool withDashboardCubit = false}) {
      return AdminOnly(
        child: MultiBlocProvider(
          providers: [
            BlocProvider(create: (_) => AdminNavCubit()),
            if (withDashboardCubit)
              BlocProvider(
                create: (_) => AdminDashboardCubit(dashboardUsecase)..start(),
              ),
          ],
          child: child,
        ),
      );
    }

    Widget buildCatalogPage() {
      final catalogRepo = buildCatalogRepo();
      final getAdminProducts = GetAdminProducts(catalogRepo);
      final toggleVisibility = ToggleProductVisibility(catalogRepo);
      final categoriesRepo = buildCategoriesRepo();
      final watchCategories = WatchCategoriesStream(categoriesRepo);
      final getCategories = GetCategories(categoriesRepo);
      return AdminCatalogWorkspaceHost(
        getAdminProducts: getAdminProducts,
        toggleVisibility: toggleVisibility,
        getCategories: getCategories,
        watchCategories: watchCategories,
      );
    }

    if (path == base) {
      return MaterialPageRoute(
        builder:
            (_) => wrap(
              AdminShell(catalogPage: buildCatalogPage()),
              withDashboardCubit: true,
            ),
        settings: settings,
      );
    }

    if (path.startsWith('$base/dashboard')) {
      return MaterialPageRoute(
        builder:
            (_) => wrap(const AdminDashboardPage(), withDashboardCubit: true),
        settings: settings,
      );
    }

    if (path.startsWith('$base/orders')) {
      return MaterialPageRoute(
        builder: (_) => wrap(const AdminOrdersHost()),
        settings: settings,
      );
    }

    if (path == '$base/catalog/product/new') {
      final productsRepo = buildProductsRepo();
      final saveProduct = SaveProductUseCase(productsRepo);
      final getProduct = GetProductUseCase(productsRepo);
      final categoriesRepo = buildCategoriesRepo();
      final watchCategories = WatchCategoriesStream(categoriesRepo);
      return MaterialPageRoute(
        builder:
            (_) => wrap(
              BlocProvider(
                create:
                    (_) => ProductFormCubit(
                      saveProductUseCase: saveProduct,
                      getProductUseCase: getProduct,
                    ),
                child: ProductFormPage(
                  watchCategories: watchCategories,
                ),
              ),
            ),
        settings: settings,
      );
    }

    if (path == '$base/catalog/product/edit') {
      final args = settings.arguments as Map<String, dynamic>? ?? {};
      final productId = args['productId'] as String?;
      final product = args['product'] as AdminProduct?;
      if ((productId == null || productId.isEmpty) && product == null) {
        return MaterialPageRoute(
          builder:
              (_) => wrap(
                const Scaffold(
                  body: Center(child: Text('Producto no encontrado')),
                ),
              ),
          settings: settings,
        );
      }
      final productsRepo = buildProductsRepo();
      final saveProduct = SaveProductUseCase(productsRepo);
      final getProduct = GetProductUseCase(productsRepo);
      final categoriesRepo = buildCategoriesRepo();
      final watchCategories = WatchCategoriesStream(categoriesRepo);
      return MaterialPageRoute(
        builder:
            (_) => wrap(
              BlocProvider(
                create:
                    (_) => ProductFormCubit(
                      saveProductUseCase: saveProduct,
                      getProductUseCase: getProduct,
                    ),
                child: ProductFormPage(
                  watchCategories: watchCategories,
                  productId: productId,
                  initialProduct: product,
                ),
              ),
            ),
        settings: settings,
      );
    }

    if (path == '$base/catalog/categories') {
      final categoriesRepo = buildCategoriesRepo();
      final watch = WatchCategoriesStream(categoriesRepo);
      final update = UpdateCategory(categoriesRepo);
      final reorder = ReorderCategories(categoriesRepo);
      final settingsRepo = CatalogSettingsRepositoryImpl(firestore);
      final getPrimaryLimit = GetPrimaryCategoriesLimit(settingsRepo);
      final setPrimaryLimit = SetPrimaryCategoriesLimit(settingsRepo);
      return MaterialPageRoute(
        fullscreenDialog: true,
        builder:
            (_) => wrap(
              RepositoryProvider<CategoriesRepository>.value(
                value: categoriesRepo,
                child: MultiBlocProvider(
                  providers: [
                    BlocProvider(
                      create:
                          (_) => CategoryListCubit(
                            watchCategories: watch,
                            updateCategory: update,
                            reorderCategories: reorder,
                            getPrimaryCategoriesLimit: getPrimaryLimit,
                            setPrimaryCategoriesLimit: setPrimaryLimit,
                          )..init(),
                    ),
                  ],
                  child: const CategoriesCustomizePage(),
                ),
              ),
            ),
        settings: settings,
      );
    }

    if (path == '$base/catalog/categories/new') {
      final categoriesRepo = buildCategoriesRepo();
      final create = CreateCategory(categoriesRepo);
      final update = UpdateCategory(categoriesRepo);
      final delete = DeleteCategory(categoriesRepo);
      return MaterialPageRoute(
        fullscreenDialog: true,
        builder:
            (_) => wrap(
              RepositoryProvider<CategoriesRepository>.value(
                value: categoriesRepo,
                child: BlocProvider(
                  create:
                      (_) => CategoryFormCubit(
                        createCategory: create,
                        updateCategory: update,
                        deleteCategory: delete,
                      ),
                  child: const CategoryFormPage(),
                ),
              ),
            ),
        settings: settings,
      );
    }

    if (path.startsWith('$base/catalog')) {
      return MaterialPageRoute(
        builder: (_) => wrap(buildCatalogPage()),
        settings: settings,
      );
    }

    if (path.startsWith('$base/management')) {
      return MaterialPageRoute(
        builder: (_) => wrap(const AdminManagementHost()),
        settings: settings,
      );
    }

    // Fallback a shell
    return MaterialPageRoute(
      builder: (_) => wrap(AdminShell(catalogPage: buildCatalogPage())),
      settings: settings,
    );
  }
}

-------------- END FILE: modules/features/admin/admin_routes.dart --------------

Dentro de /data:

Dentro de /datasources:

 FILE: modules/features/admin/data/datasources/admin_dashboard_remote_datasource.dart 
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/admin_dashboard_summary_model.dart';

class AdminDashboardRemoteDataSource {
  final FirebaseFirestore firestore;
  AdminDashboardRemoteDataSource(this.firestore);

  Stream<AdminDashboardSummaryModel> watchSummary() {
    return firestore
        .collection('orders')
        .snapshots()
        .asyncMap((ordersSnapshot) async {
      final productsSnapshot =
          await firestore.collection('products').get();
      final now = DateTime.now();
      final rangeEnd = now;
      final rangeStart = now.subtract(const Duration(days: 7));
      return AdminDashboardSummaryModel.fromSnapshots(
        ordersSnapshot: ordersSnapshot,
        productsSnapshot: productsSnapshot,
        rangeStart: rangeStart,
        rangeEnd: rangeEnd,
      );
    });
  }
}

 END FILE: modules/features/admin/data/datasources/admin_dashboard_remote_datasource.dart 

Dentro de /models:

-- FILE: modules/features/admin/data/models/admin_dashboard_summary_model.dart -
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../domain/entities/admin_dashboard_summary.dart';
import '../../domain/entities/top_product_summary.dart';

class AdminDashboardSummaryModel extends AdminDashboardSummary {
  AdminDashboardSummaryModel({
    required super.statusCounts,
    required super.ordersLast7Days,
    required super.topProducts,
    required super.avgPreparationMinutes,
    required super.avgDeliveryMinutes,
    required super.expiredVouchers,
    required super.rangeStart,
    required super.rangeEnd,
  });

  factory AdminDashboardSummaryModel.fromSnapshots({
    required QuerySnapshot<Map<String, dynamic>> ordersSnapshot,
    required QuerySnapshot<Map<String, dynamic>> productsSnapshot,
    required DateTime rangeStart,
    required DateTime rangeEnd,
  }) {
    final statusCounts = <String, int>{};
    int ordersInRange = 0;
    int expiredVouchers = 0;
    final prepValues = <double>[];
    final deliveryValues = <double>[];

    for (final doc in ordersSnapshot.docs) {
      final data = doc.data();
      final status = (data['status'] as String?)?.toLowerCase() ?? 'desconocido';
      statusCounts[status] = (statusCounts[status] ?? 0) + 1;

      final createdAt = (data['createdAt'] as Timestamp?)?.toDate();
      if (createdAt != null &&
          !createdAt.isBefore(rangeStart) &&
          !createdAt.isAfter(rangeEnd)) {
        ordersInRange++;
      }

      final voucherExpiresAt = (data['voucherExpiresAt'] as Timestamp?)?.toDate();
      final isPendingPayment = status.contains('pend') || status == 'nuevo';
      if (isPendingPayment &&
          voucherExpiresAt != null &&
          voucherExpiresAt.isBefore(DateTime.now())) {
        expiredVouchers++;
      }

      final prep = (data['metrics']?['prepMinutes'] as num?)?.toDouble() ??
          (data['prepMinutes'] as num?)?.toDouble();
      if (prep != null && prep > 0) prepValues.add(prep);

      final delivery =
          (data['metrics']?['deliveryMinutes'] as num?)?.toDouble() ??
              (data['deliveryMinutes'] as num?)?.toDouble();
      if (delivery != null && delivery > 0) deliveryValues.add(delivery);
    }

    final topProducts = productsSnapshot.docs.map((doc) {
      final data = doc.data();
      final name = (data['name'] as String?) ?? 'Sin nombre';
      final sales = (data['stats']?['sales'] as num?)?.toInt() ??
          (data['totalSales'] as num?)?.toInt() ??
          0;
      return TopProductSummary(name: name, total: sales);
    }).toList()
      ..sort((a, b) => b.total.compareTo(a.total));

    return AdminDashboardSummaryModel(
      statusCounts: statusCounts,
      ordersLast7Days: ordersInRange,
      topProducts: topProducts.take(3).toList(),
      avgPreparationMinutes:
          prepValues.isEmpty ? null : _avg(prepValues),
      avgDeliveryMinutes:
          deliveryValues.isEmpty ? null : _avg(deliveryValues),
      expiredVouchers: expiredVouchers,
      rangeStart: rangeStart,
      rangeEnd: rangeEnd,
    );
  }

  static double _avg(List<double> values) =>
      values.reduce((a, b) => a + b) / values.length;
}

 END FILE: modules/features/admin/data/models/admin_dashboard_summary_model.dart 

Dentro de /repositories:

 FILE: modules/features/admin/data/repositories/admin_dashboard_repository_impl.dart 
import '../../domain/entities/admin_dashboard_summary.dart';
import '../../domain/repositories/admin_dashboard_repository.dart';
import '../datasources/admin_dashboard_remote_datasource.dart';

class AdminDashboardRepositoryImpl implements AdminDashboardRepository {
  final AdminDashboardRemoteDataSource remote;
  AdminDashboardRepositoryImpl(this.remote);

  @override
  Stream<AdminDashboardSummary> watchSummary() => remote.watchSummary();
}

 END FILE: modules/features/admin/data/repositories/admin_dashboard_repository_impl.dart 

Dentro de /domain:

Dentro de /entities:

--- FILE: modules/features/admin/domain/entities/admin_dashboard_summary.dart --
import 'top_product_summary.dart';

class AdminDashboardSummary {
  final Map<String, int> statusCounts;
  final int ordersLast7Days;
  final List<TopProductSummary> topProducts;
  final double? avgPreparationMinutes;
  final double? avgDeliveryMinutes;
  final int expiredVouchers;
  final DateTime rangeStart;
  final DateTime rangeEnd;

  const AdminDashboardSummary({
    required this.statusCounts,
    required this.ordersLast7Days,
    required this.topProducts,
    required this.avgPreparationMinutes,
    required this.avgDeliveryMinutes,
    required this.expiredVouchers,
    required this.rangeStart,
    required this.rangeEnd,
  });
}

- END FILE: modules/features/admin/domain/entities/admin_dashboard_summary.dart 

----- FILE: modules/features/admin/domain/entities/top_product_summary.dart ----
class TopProductSummary {
  final String name;
  final int total;

  const TopProductSummary({
    required this.name,
    required this.total,
  });
}

--- END FILE: modules/features/admin/domain/entities/top_product_summary.dart --

Dentro de /repositories:

 FILE: modules/features/admin/domain/repositories/admin_dashboard_repository.dart 
import '../entities/admin_dashboard_summary.dart';

abstract class AdminDashboardRepository {
  Stream<AdminDashboardSummary> watchSummary();
}

 END FILE: modules/features/admin/domain/repositories/admin_dashboard_repository.dart 

Dentro de /usecases:

 FILE: modules/features/admin/domain/usecases/watch_admin_dashboard_summary.dart 
import '../entities/admin_dashboard_summary.dart';
import '../repositories/admin_dashboard_repository.dart';

class WatchAdminDashboardSummary {
  final AdminDashboardRepository repository;
  WatchAdminDashboardSummary(this.repository);

  Stream<AdminDashboardSummary> call() {
    return repository.watchSummary();
  }
}

 END FILE: modules/features/admin/domain/usecases/watch_admin_dashboard_summary.dart 

Dentro de /presentation:

Dentro de /blocs:

- FILE: modules/features/admin/presentation/blocs/admin_catalog_list_cubit.dart 
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../catalog/domain/entities/public_product.dart';
import '../../../catalog/domain/usecases/get_admin_products.dart';
import '../../../catalog/domain/usecases/toggle_product_visibility.dart';

class AdminCatalogListState {
  static const _sentinel = Object();

  final List<PublicProduct> products;
  final bool isLoading;
  final bool isLoadingMore;
  final bool hasMore;
  final String? nextCursor;
  final String? categoryId;
  final String statusFilter;
  final String searchQuery;
  final String? errorMessage;

  const AdminCatalogListState({
    this.products = const [],
    this.isLoading = false,
    this.isLoadingMore = false,
    this.hasMore = true,
    this.nextCursor,
    this.categoryId,
    this.statusFilter = 'all',
    this.searchQuery = '',
    this.errorMessage,
  });

  AdminCatalogListState copyWith({
    List<PublicProduct>? products,
    bool? isLoading,
    bool? isLoadingMore,
    bool? hasMore,
    Object? nextCursor = _sentinel,
    Object? categoryId = _sentinel,
    String? statusFilter,
    String? searchQuery,
    Object? errorMessage = _sentinel,
  }) {
    return AdminCatalogListState(
      products: products ?? this.products,
      isLoading: isLoading ?? this.isLoading,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      hasMore: hasMore ?? this.hasMore,
      nextCursor:
          identical(nextCursor, _sentinel)
              ? this.nextCursor
              : nextCursor as String?,
      categoryId:
          identical(categoryId, _sentinel)
              ? this.categoryId
              : categoryId as String?,
      statusFilter: statusFilter ?? this.statusFilter,
      searchQuery: searchQuery ?? this.searchQuery,
      errorMessage:
          identical(errorMessage, _sentinel)
              ? this.errorMessage
              : errorMessage as String?,
    );
  }
}

class AdminCatalogListCubit extends Cubit<AdminCatalogListState> {
  final GetAdminProducts _getAdminProducts;
  final ToggleProductVisibility _toggleProductVisibility;

  AdminCatalogListCubit(
    this._getAdminProducts,
    this._toggleProductVisibility,
  ) : super(const AdminCatalogListState());

  Future<void> loadInitial() async {
    _emitSafe(
      state.copyWith(
        isLoading: true,
        errorMessage: null,
        nextCursor: null,
        hasMore: true,
      ),
    );
    try {
      final page = await _getAdminProducts(
        categoryId: state.categoryId,
        status: _statusParam(state.statusFilter),
        searchQuery: state.searchQuery.isEmpty ? null : state.searchQuery,
        limit: 20,
      );

      _emitSafe(
        state.copyWith(
          isLoading: false,
          products: page.products,
          hasMore: page.hasMore,
          nextCursor: page.nextCursor,
        ),
      );
    } catch (e) {
      _emitSafe(state.copyWith(isLoading: false, errorMessage: e.toString()));
    }
  }

  Future<void> refresh() => loadInitial();

  Future<void> loadMore() async {
    if (state.isLoadingMore || !state.hasMore || state.nextCursor == null) {
      return;
    }
    _emitSafe(state.copyWith(isLoadingMore: true));
    try {
      final page = await _getAdminProducts(
        categoryId: state.categoryId,
        status: _statusParam(state.statusFilter),
        searchQuery: state.searchQuery.isEmpty ? null : state.searchQuery,
        limit: 20,
        startAfterId: state.nextCursor,
      );

      _emitSafe(
        state.copyWith(
          isLoadingMore: false,
          products: [...state.products, ...page.products],
          hasMore: page.hasMore,
          nextCursor: page.nextCursor,
        ),
      );
    } catch (e) {
      _emitSafe(
        state.copyWith(isLoadingMore: false, errorMessage: e.toString()),
      );
    }
  }

  Future<void> applyFilter({
    String? categoryId,
    String? status,
    bool clearCategory = false,
  }) async {
    _emitSafe(
      state.copyWith(
        categoryId: clearCategory ? null : (categoryId ?? state.categoryId),
        statusFilter: status ?? state.statusFilter,
      ),
    );
    await loadInitial();
  }

  Future<void> search(String query) async {
    _emitSafe(state.copyWith(searchQuery: query));
    await loadInitial();
  }

  Future<void> toggleVisibility(String productId, bool visible) async {
    try {
      await _toggleProductVisibility(productId, visible);
      final updated =
          state.products
              .map(
                (p) =>
                    p.id == productId
                        ? p.copyWith(isVisible: visible, isActive: visible)
                        : p,
              )
              .toList();
      _emitSafe(state.copyWith(products: updated));
    } catch (e) {
      _emitSafe(state.copyWith(errorMessage: e.toString()));
    }
  }

  String? _statusParam(String status) {
    switch (status) {
      case 'all':
        return null;
      case 'published':
      case 'draft':
      case 'hidden':
        return status;
      default:
        return null;
    }
  }

  void _emitSafe(AdminCatalogListState newState) {
    if (isClosed) return;
    emit(newState);
  }
}

 END FILE: modules/features/admin/presentation/blocs/admin_catalog_list_cubit.dart 

-- FILE: modules/features/admin/presentation/blocs/admin_categories_cubit.dart -
import 'dart:async';

import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../catalog/domain/entities/category.dart';
import '../../../catalog/domain/usecases/get_categories.dart';
import '../../../catalog/domain/usecases/watch_categories_stream.dart';

class AdminCategoriesState {
  static const _sentinel = Object();

  final bool isLoading;
  final List<Category> categories;
  final String? errorMessage;

  const AdminCategoriesState({
    this.isLoading = false,
    this.categories = const [],
    this.errorMessage,
  });

  AdminCategoriesState copyWith({
    bool? isLoading,
    List<Category>? categories,
    Object? errorMessage = _sentinel,
  }) {
    return AdminCategoriesState(
      isLoading: isLoading ?? this.isLoading,
      categories: categories ?? this.categories,
      errorMessage: identical(errorMessage, _sentinel)
          ? this.errorMessage
          : errorMessage as String?,
    );
  }
}

class AdminCategoriesCubit extends Cubit<AdminCategoriesState> {
  final GetCategories _getCategories;
  final WatchCategoriesStream _watchCategories;
  StreamSubscription<List<Category>>? _subscription;

  AdminCategoriesCubit(
    this._getCategories,
    this._watchCategories,
  )
      : super(const AdminCategoriesState(isLoading: true));

  Future<void> load() async {
    _subscription?.cancel();
    _emitSafe(state.copyWith(isLoading: true, errorMessage: null));
    try {
      final initial = await _getCategories();
      _emitSafe(
        state.copyWith(
          isLoading: false,
          categories: initial,
        ),
      );
    } catch (e) {
      _emitSafe(
        state.copyWith(
          isLoading: false,
          errorMessage: e.toString(),
        ),
      );
    }
    try {
      _subscription = _watchCategories().listen(
        (categories) {
          _emitSafe(
            state.copyWith(
              isLoading: false,
              categories: categories,
            ),
          );
        },
        onError: (e) {
          _emitSafe(
            state.copyWith(
              isLoading: false,
              errorMessage: e.toString(),
            ),
          );
        },
      );
    } catch (e) {
      _emitSafe(
        state.copyWith(
          isLoading: false,
          errorMessage: e.toString(),
        ),
      );
    }
  }

  /// Llamado solo si se requiere un refresco puntual sin esperar al stream.
  Future<void> refreshOnce() async {
    try {
      final categories = await _getCategories();
      _emitSafe(
        state.copyWith(
          isLoading: false,
          categories: categories,
        ),
      );
    } catch (e) {
      _emitSafe(
        state.copyWith(
          isLoading: false,
          errorMessage: e.toString(),
        ),
      );
    }
  }

  void _emitSafe(AdminCategoriesState newState) {
    if (isClosed) return;
    emit(newState);
  }

  @override
  Future<void> close() {
    _subscription?.cancel();
    return super.close();
  }
}

 END FILE: modules/features/admin/presentation/blocs/admin_categories_cubit.dart 

-- FILE: modules/features/admin/presentation/blocs/admin_dashboard_cubit.dart --
import 'dart:async';

import 'package:flutter_bloc/flutter_bloc.dart';

import '../../domain/entities/admin_dashboard_summary.dart';
import '../../domain/usecases/watch_admin_dashboard_summary.dart';

sealed class AdminDashboardState {
  const AdminDashboardState();
}

class AdminDashboardLoading extends AdminDashboardState {
  const AdminDashboardLoading();
}

class AdminDashboardLoaded extends AdminDashboardState {
  final AdminDashboardSummary summary;
  const AdminDashboardLoaded(this.summary);
}

class AdminDashboardError extends AdminDashboardState {
  final String message;
  const AdminDashboardError(this.message);
}

class AdminDashboardCubit extends Cubit<AdminDashboardState> {
  final WatchAdminDashboardSummary watchSummary;
  StreamSubscription? _sub;

  AdminDashboardCubit(this.watchSummary) : super(const AdminDashboardLoading());

  void start() {
    _sub?.cancel();
    emit(const AdminDashboardLoading());
    _sub = watchSummary().listen(
      (summary) => emit(AdminDashboardLoaded(summary)),
      onError: (err) => emit(AdminDashboardError(err.toString())),
    );
  }

  @override
  Future<void> close() {
    _sub?.cancel();
    return super.close();
  }
}

 END FILE: modules/features/admin/presentation/blocs/admin_dashboard_cubit.dart 

----- FILE: modules/features/admin/presentation/blocs/admin_nav_cubit.dart -----
// lib/modules/features/admin/presentation/blocs/admin_nav_cubit.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class AdminNavCubit extends Cubit<int> {
  AdminNavCubit() : super(0);
  void setTab(int i) => emit(i);
}

class AdminNavScope extends StatelessWidget {
  const AdminNavScope({super.key, required this.child});
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return BlocProvider<AdminNavCubit>(
      create: (_) => AdminNavCubit(),
      child: child,
    );
  }
}

--- END FILE: modules/features/admin/presentation/blocs/admin_nav_cubit.dart ---

- FILE: modules/features/admin/presentation/blocs/admin_product_form_cubit.dart 
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../catalog/domain/entities/public_product.dart';
import '../../../catalog/domain/usecases/create_product.dart';
import '../../../catalog/domain/usecases/get_product.dart';
import '../../../catalog/domain/usecases/toggle_product_visibility.dart';
import '../../../catalog/domain/usecases/update_product.dart';

class AdminProductFormState {
  static const _sentinel = Object();

  final PublicProduct? product;
  final bool isNew;
  final bool isLoading;
  final bool isSaving;
  final bool autosaving;
  final String? errorMessage;
  final DateTime? lastSavedAt;

  const AdminProductFormState({
    this.product,
    this.isNew = true,
    this.isLoading = false,
    this.isSaving = false,
    this.autosaving = false,
    this.errorMessage,
    this.lastSavedAt,
  });

  bool get isReady => !isLoading && product != null;

  AdminProductFormState copyWith({
    Object? product = _sentinel,
    bool? isNew,
    bool? isLoading,
    bool? isSaving,
    bool? autosaving,
    Object? errorMessage = _sentinel,
    Object? lastSavedAt = _sentinel,
  }) {
    return AdminProductFormState(
      product: identical(product, _sentinel) ? this.product : product as PublicProduct?,
      isNew: isNew ?? this.isNew,
      isLoading: isLoading ?? this.isLoading,
      isSaving: isSaving ?? this.isSaving,
      autosaving: autosaving ?? this.autosaving,
      errorMessage: identical(errorMessage, _sentinel)
          ? this.errorMessage
          : errorMessage as String?,
      lastSavedAt: identical(lastSavedAt, _sentinel)
          ? this.lastSavedAt
          : lastSavedAt as DateTime?,
    );
  }
}

class AdminProductFormCubit extends Cubit<AdminProductFormState> {
  final CreateProduct _createProduct;
  final UpdateProduct _updateProduct;
  final ToggleProductVisibility _toggleVisibility;
  final GetProduct _getProduct;

  AdminProductFormCubit({
    required CreateProduct createProduct,
    required UpdateProduct updateProduct,
    required ToggleProductVisibility toggleVisibility,
    required GetProduct getProduct,
  })  : _createProduct = createProduct,
        _updateProduct = updateProduct,
        _toggleVisibility = toggleVisibility,
        _getProduct = getProduct,
        super(const AdminProductFormState());

  void initNew() {
    emit(
      AdminProductFormState(
        product: PublicProduct(
          id: 'temp-${DateTime.now().microsecondsSinceEpoch}',
          name: '',
          description: '',
          categoryId: '',
          sku: null,
          imageUrl: null,
          galleryImages: const [],
          basePrice: 0,
          cost: null,
          compareAtPrice: null,
          isActive: false,
          isVisible: false,
          stock: 0,
          minStock: 0,
          tags: const [],
        ),
        isNew: true,
        isLoading: false,
      ),
    );
  }

  Future<void> loadExisting(String productId) async {
    emit(state.copyWith(isLoading: true, errorMessage: null));
    try {
      final product = await _getProduct(productId);
      if (product == null) {
        throw Exception('Producto no encontrado');
      }
      emit(
        state.copyWith(
          product: product,
          isNew: false,
          isLoading: false,
          errorMessage: null,
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          isLoading: false,
          errorMessage: e.toString(),
        ),
      );
    }
  }

  void updateName(String value) => _patchProduct((p) => p.copyWith(name: value));

  void updateDescription(String value) =>
      _patchProduct((p) => p.copyWith(description: value));

  void updateCategory(String? categoryId) =>
      _patchProduct((p) => p.copyWith(categoryId: categoryId ?? ''));

  void updateSku(String? sku) => _patchProduct((p) => p.copyWith(sku: sku));

  void updateBasePrice(String value) {
    final parsed = double.tryParse(value.replaceAll(',', '.')) ?? 0;
    _patchProduct((p) => p.copyWith(basePrice: parsed));
  }

  void updateCost(String value) {
    final parsed = double.tryParse(value.replaceAll(',', '.'));
    _patchProduct((p) => p.copyWith(cost: parsed));
  }

  void updateComparePrice(String value) {
    final parsed = double.tryParse(value.replaceAll(',', '.'));
    _patchProduct((p) => p.copyWith(compareAtPrice: parsed));
  }

  void updateStock(String value) {
    final parsed = int.tryParse(value) ?? 0;
    _patchProduct((p) => p.copyWith(stock: parsed));
  }

  void updateMinStock(String value) {
    final parsed = int.tryParse(value) ?? 0;
    _patchProduct((p) => p.copyWith(minStock: parsed));
  }

  void toggleTag(String tag) {
    _patchProduct((p) {
      final tags = List<String>.from(p.tags);
      if (tags.contains(tag)) {
        tags.remove(tag);
      } else {
        tags.add(tag);
      }
      return p.copyWith(tags: tags);
    });
  }

  void updatePrimaryImage(String? url) =>
      _patchProduct((p) => p.copyWith(imageUrl: url));

  void updateGallery(List<String> images) =>
      _patchProduct((p) => p.copyWith(galleryImages: images));

  void toggleVisibility(bool visible) =>
      _patchProduct((p) => p.copyWith(isVisible: visible, isActive: visible));

  Future<void> save({bool publish = false}) async {
    final product = state.product;
    if (product == null) return;
    emit(state.copyWith(isSaving: true, errorMessage: null));
    final updatedProduct = publish
        ? product.copyWith(isActive: true, isVisible: true)
        : product;
    try {
      if (state.isNew) {
        final created = await _createProduct(updatedProduct);
        emit(
          state.copyWith(
            product: created,
            isNew: false,
            isSaving: false,
            lastSavedAt: DateTime.now(),
          ),
        );
      } else {
        await _updateProduct(updatedProduct);
        emit(
          state.copyWith(
            product: updatedProduct,
            isSaving: false,
            lastSavedAt: DateTime.now(),
          ),
        );
      }
    } catch (e) {
      emit(
        state.copyWith(
          isSaving: false,
          errorMessage: e.toString(),
        ),
      );
    }
  }

  Future<void> publish() => save(publish: true);

  Future<void> toggleVisibilityRemote(bool visible) async {
    final product = state.product;
    if (product == null || product.id.isEmpty || state.isNew) {
      toggleVisibility(visible);
      return;
    }
    try {
      await _toggleVisibility(product.id, visible);
      toggleVisibility(visible);
    } catch (e) {
      emit(state.copyWith(errorMessage: e.toString()));
    }
  }

  Future<void> discardChanges() async {
    if (state.isNew) {
      initNew();
      return;
    }
    final id = state.product?.id;
    if (id == null) return;
    await loadExisting(id);
  }

  void _patchProduct(PublicProduct Function(PublicProduct current) transform) {
    final current = state.product;
    if (current == null) return;
    final updated = transform(current);
    emit(
      state.copyWith(
        product: updated,
        errorMessage: null,
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/blocs/admin_product_form_cubit.dart 

Dentro de /pages:

------- FILE: modules/features/admin/presentation/pages/admin_shell.dart -------
// lib/modules/features/admin/presentation/pages/admin_shell.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/widgets/layout/tab_back_guard.dart';
import '../blocs/admin_nav_cubit.dart';
import '../widgets/shared/admin_top_bar.dart';
import 'dashboard/admin_dashboard_page.dart';
import 'management/admin_management_host.dart';
import 'orders/admin_orders_host.dart';

class AdminShell extends StatelessWidget {
  final Widget catalogPage;

  const AdminShell({super.key, required this.catalogPage});

  @override
  Widget build(BuildContext context) {
    final pages = [
      const AdminDashboardPage(),
      const AdminOrdersHost(),
      catalogPage,
      const AdminManagementHost(),
    ];
    const titles = ['Dashboard', 'Pedidos', 'Catalogo', 'Gestion'];

    return BlocBuilder<AdminNavCubit, int>(
      builder: (context, index) {
        return TabBackGuard(
          currentIndex: index,
          onRequestRoot: () => context.read<AdminNavCubit>().setTab(0),
          child: Scaffold(
            appBar: AdminTopBar(
              title: titles[index],
              useTopSafeArea: false,
              onNotifications: () {},
              showBadge: index == 0,
            ),
            body: IndexedStack(index: index, children: pages),
            bottomNavigationBar: NavigationBar(
              selectedIndex: index,
              onDestinationSelected: context.read<AdminNavCubit>().setTab,
              destinations: const [
                NavigationDestination(
                  icon: Icon(Icons.dashboard_outlined),
                  label: 'Panel',
                ),
                NavigationDestination(
                  icon: Icon(Icons.receipt_long_outlined),
                  label: 'Pedidos',
                ),
                NavigationDestination(
                  icon: Icon(Icons.category_outlined),
                  label: 'Catalogo',
                ),
                NavigationDestination(
                  icon: Icon(Icons.admin_panel_settings_outlined),
                  label: 'Gestion',
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

----- END FILE: modules/features/admin/presentation/pages/admin_shell.dart -----

Dentro de /catalog:

 FILE: modules/features/admin/presentation/pages/catalog/admin_catalog_workspace_host.dart 
// lib/modules/features/admin/presentation/pages/admin_catalog_workspace_host.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../catalog/domain/entities/public_product.dart';
import '../../../../catalog/domain/usecases/get_admin_products.dart';
import '../../../../catalog/domain/usecases/get_categories.dart';
import '../../../../catalog/domain/usecases/toggle_product_visibility.dart';
import '../../../../catalog/domain/usecases/watch_categories_stream.dart';
import '../../../admin_routes.dart';
import '../../blocs/admin_catalog_list_cubit.dart';
import '../../blocs/admin_categories_cubit.dart';
import '../../widgets/catalog/admin_categories_strip.dart';
import '../../widgets/product/admin_product_card.dart';
import '../../widgets/shared/admin_surface.dart';
import 'catalog_presentation_page.dart';

class AdminCatalogWorkspaceHost extends StatelessWidget {
  final GetAdminProducts getAdminProducts;
  final ToggleProductVisibility toggleVisibility;
  final GetCategories getCategories;
  final WatchCategoriesStream watchCategories;

  const AdminCatalogWorkspaceHost({
    super.key,
    required this.getAdminProducts,
    required this.toggleVisibility,
    required this.getCategories,
    required this.watchCategories,
  });

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider(
          create:
              (_) =>
                  AdminCatalogListCubit(getAdminProducts, toggleVisibility)
                    ..loadInitial(),
        ),
        BlocProvider(
          create: (_) =>
              AdminCategoriesCubit(getCategories, watchCategories)..load(),
        ),
      ],
      child: const _AdminCatalogWorkspaceView(),
    );
  }
}

class _AdminCatalogWorkspaceView extends StatelessWidget {
  const _AdminCatalogWorkspaceView();

  @override
  Widget build(BuildContext context) {
    // El AdminShell ya provee AppBar y Scaffold.
    return const _AdminProductsTab();
  }
}

Future<void> _navigateToCategories(BuildContext context) async {
  final navigator = Navigator.of(context);
  final categoriesCubit = context.read<AdminCategoriesCubit>();
  final catalogCubit = context.read<AdminCatalogListCubit>();

  await navigator.pushNamed('${AdminRoutes.base}/catalog/categories');
  if (!navigator.mounted) return;

  // Refresca categorÃ­as y productos al volver, para reflejar cambios.
  await categoriesCubit.load();
  await catalogCubit.loadInitial();
}

void _navigateToPresentation(BuildContext context) {
  Navigator.of(
    context,
  ).push(MaterialPageRoute(builder: (_) => const CatalogPresentationPage()));
}

class _AdminProductsTab extends StatefulWidget {
  const _AdminProductsTab();

  @override
  State<_AdminProductsTab> createState() => _AdminProductsTabState();
}

class _AdminProductsTabState extends State<_AdminProductsTab> {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();
  bool _gridMode = true;

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  void _runSearch() {
    context.read<AdminCatalogListCubit>().search(_searchController.text.trim());
  }

  @override
  Widget build(BuildContext context) {
    final catalogCubit = context.read<AdminCatalogListCubit>();
    return BlocBuilder<AdminCatalogListCubit, AdminCatalogListState>(
      builder: (context, catalogState) {
        return BlocBuilder<AdminCategoriesCubit, AdminCategoriesState>(
          builder: (context, categoriesState) {
            final products = catalogState.products;
            final mediaWidth = MediaQuery.of(context).size.width;
            final columns =
                !_gridMode
                    ? 1
                    : mediaWidth > 1100
                    ? 3
                    : mediaWidth > 720
                    ? 2
                    : 1;
            final categoryNames = {
              for (final category in categoriesState.categories)
                category.id: category.name,
            };
            final emptyType = _resolveEmptyType(catalogState, categoriesState);

            final String? headerSubtitle =
                emptyType == CatalogEmptyType.catalog && !catalogState.isLoading
                    ? 'Aun no tienes productos. Crea tu primer producto para comenzar.'
                    : null;

            final slivers = <Widget>[
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 4, 16, 4),
                  child: CatalogHeader(
                    searchController: _searchController,
                    onSearch: _runSearch,
                    onClear: () {
                      _searchController.clear();
                      _runSearch();
                    },
                    searchFocusNode: _searchFocusNode,
                    onFilterPressed: () => _showComingSoon(context),
                  ),
                ),
              ),
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                  child: CatalogFilters(
                    status: catalogState.statusFilter,
                    onStatusChanged:
                        (value) => catalogCubit.applyFilter(status: value),
                  ),
                ),
              ),
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                  child: AdminCategoriesStrip(
                    isLoading: categoriesState.isLoading,
                    categories: categoriesState.categories,
                    selectedCategoryId: catalogState.categoryId,
                    onCategorySelected: (categoryId) {
                      catalogCubit.applyFilter(
                        categoryId: categoryId,
                        clearCategory: categoryId == null,
                      );
                    },
                    onManageCategories: () => _navigateToCategories(context),
                    onCreateCategory: () => _openCreateCategory(context),
                  ),
                ),
              ),
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                  child: CatalogProductsHeader(
                    subtitle: headerSubtitle,
                    gridMode: _gridMode,
                    onToggleView: () => setState(() => _gridMode = !_gridMode),
                    onPresentationTap: () => _navigateToPresentation(context),
                  ),
                ),
              ),
            ];
            if (emptyType != CatalogEmptyType.catalog) {
              slivers.add(
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(16, 20, 16, 0),
                    child: CatalogKpiSummary(products: products),
                  ),
                ),
              );
            }

            Widget bodySliver;
            if (catalogState.isLoading && products.isEmpty) {
              bodySliver = const SliverFillRemaining(
                hasScrollBody: false,
                child: Center(child: CircularProgressIndicator()),
              );
            } else if (products.isEmpty) {
              bodySliver = SliverFillRemaining(
                hasScrollBody: false,
                child: CatalogEmptyState(
                  type: emptyType,
                  categoryName: categoryNames[catalogState.categoryId],
                  statusFilter: catalogState.statusFilter,
                  onCreateProduct: () => _openCreateProduct(context),
                  onCreateCategory: () => _navigateToCategories(context),
                  showActionButton: false,
                ),
              );
            } else {
              bodySliver = CatalogProductGrid(
                products: products,
                columns: columns,
                gridMode: _gridMode,
                categoryNameResolver:
                    (categoryId) =>
                        categoryNames[categoryId] ?? 'Sin categoria',
                onEdit: (product) => _openEditProduct(context, product.id),
                onPreview: (product) => _openPreviewProduct(context, product),
                onToggleVisibility:
                    (product, visible) =>
                        catalogCubit.toggleVisibility(product.id, visible),
              );
            }
            slivers.add(bodySliver);

            if (catalogState.hasMore &&
                !catalogState.isLoading &&
                products.isNotEmpty) {
              slivers.add(
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.only(bottom: 24),
                    child: Center(
                      child: TextButton(
                        onPressed: () => catalogCubit.loadMore(),
                        child: const Text('Cargar mas'),
                      ),
                    ),
                  ),
                ),
              );
            }

            if (catalogState.isLoadingMore) {
              slivers.add(
                const SliverToBoxAdapter(
                  child: Padding(
                    padding: EdgeInsets.symmetric(vertical: 12),
                    child: Center(child: CircularProgressIndicator()),
                  ),
                ),
              );
            }

            if (catalogState.errorMessage != null && products.isNotEmpty) {
              slivers.add(
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Text(
                      catalogState.errorMessage!,
                      style: const TextStyle(color: Colors.redAccent),
                    ),
                  ),
                ),
              );
            }

            return RefreshIndicator(
              onRefresh: catalogCubit.refresh,
              child: CustomScrollView(
                physics: const AlwaysScrollableScrollPhysics(),
                slivers: slivers,
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _openCreateProduct(BuildContext context) async {
    final navigator = Navigator.of(context);
    final catalogCubit = context.read<AdminCatalogListCubit>();

    final result = await navigator.pushNamed(
      '${AdminRoutes.base}/catalog/product/new',
    );
    if (!navigator.mounted) return;

    if (result == true) {
      await catalogCubit.loadInitial();
    }
  }

  void _openCreateCategory(BuildContext context) {
    Navigator.of(
      context,
      rootNavigator: true,
    ).pushNamed('${AdminRoutes.base}/catalog/categories/new');
  }

  void _openEditProduct(BuildContext context, String productId) {
    Navigator.of(context).pushNamed(
      '${AdminRoutes.base}/catalog/product/edit',
      arguments: {'productId': productId},
    );
  }

  void _openPreviewProduct(BuildContext context, PublicProduct product) {
    Navigator.of(context).pushNamed(
      '${AdminRoutes.base}/catalog/product/detail',
      arguments: {'product': product},
    );
  }

  void _showComingSoon(BuildContext context) {
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(const SnackBar(content: Text('Filtros proximamente')));
  }

  CatalogEmptyType _resolveEmptyType(
    AdminCatalogListState catalogState,
    AdminCategoriesState categoriesState,
  ) {
    if (!categoriesState.isLoading && categoriesState.categories.isEmpty) {
      return CatalogEmptyType.noCategories;
    }
    if (catalogState.categoryId != null) {
      return CatalogEmptyType.category;
    }
    if (catalogState.statusFilter != 'all') {
      return CatalogEmptyType.status;
    }
    return CatalogEmptyType.catalog;
  }
}

enum CatalogEmptyType { catalog, noCategories, category, status }

class CatalogHeader extends StatelessWidget {
  final TextEditingController searchController;
  final FocusNode searchFocusNode;
  final VoidCallback onSearch;
  final VoidCallback onClear;
  final VoidCallback onFilterPressed;

  const CatalogHeader({
    super.key,
    required this.searchController,
    required this.searchFocusNode,
    required this.onSearch,
    required this.onClear,
    required this.onFilterPressed,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final scheme = theme.colorScheme;
    return ValueListenableBuilder<TextEditingValue>(
      valueListenable: searchController,
      builder: (context, value, _) {
        return Row(
          children: [
            Expanded(
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: scheme.surfaceContainerLowest,
                  borderRadius: BorderRadius.circular(32),
                  border: Border.all(color: scheme.outlineVariant),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.03),
                      blurRadius: 12,
                      offset: const Offset(0, 6),
                    ),
                  ],
                ),
                child: TextField(
                  controller: searchController,
                  focusNode: searchFocusNode,
                  decoration: InputDecoration(
                    border: InputBorder.none,
                    hintText: 'Buscar por nombre o SKU',
                    hintStyle: theme.textTheme.bodyMedium?.copyWith(
                      color: scheme.outline,
                    ),
                    prefixIcon: Icon(Icons.search, color: scheme.primary),
                    suffixIcon:
                        value.text.isEmpty
                            ? null
                            : IconButton(
                              tooltip: 'Limpiar bÃºsqueda',
                              icon: const Icon(Icons.close),
                              onPressed: onClear,
                            ),
                    contentPadding: const EdgeInsets.symmetric(
                      vertical: 14,
                      horizontal: 4,
                    ),
                  ),
                  textInputAction: TextInputAction.search,
                  onSubmitted: (_) => onSearch(),
                ),
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              tooltip: 'Filtros',
              onPressed: onFilterPressed,
              style: IconButton.styleFrom(
                backgroundColor: scheme.surfaceContainerHighest,
                shape: const CircleBorder(),
              ),
              icon: Icon(Icons.tune, color: scheme.primary),
            ),
          ],
        );
      },
    );
  }
}

class CatalogProductsHeader extends StatelessWidget {
  final String? subtitle;
  final bool gridMode;
  final VoidCallback onToggleView;
  final VoidCallback? onPresentationTap;

  const CatalogProductsHeader({
    super.key,
    required this.subtitle,
    required this.gridMode,
    required this.onToggleView,
    this.onPresentationTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: Text(
                'Productos',
                style: theme.textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
            if (onPresentationTap != null)
              IconButton(
                tooltip: 'Presentaciones',
                onPressed: onPresentationTap,
                icon: const Icon(Icons.layers_outlined),
              ),
            IconButton(
              tooltip: gridMode ? 'Cambiar a lista' : 'Cambiar a vista grid',
              onPressed: onToggleView,
              icon: Icon(
                gridMode ? Icons.grid_view : Icons.view_agenda_outlined,
              ),
            ),
          ],
        ),
        if (subtitle != null && subtitle!.isNotEmpty) ...[
          const SizedBox(height: 4),
          Text(subtitle!, style: theme.textTheme.bodySmall),
        ],
      ],
    );
  }
}

class CatalogFilters extends StatelessWidget {
  final String status;
  final ValueChanged<String> onStatusChanged;

  const CatalogFilters({
    super.key,
    required this.status,
    required this.onStatusChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return AdminSurface(
      padding: const EdgeInsets.all(10),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Filtros por estado',
            style: theme.textTheme.labelLarge?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children:
                  _statusOptions.map((option) {
                    final selected = status == option.$1;
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: ChoiceChip(
                        label: Text(option.$2),
                        selected: selected,
                        onSelected: (_) => onStatusChanged(option.$1),
                        labelPadding: const EdgeInsets.symmetric(
                          horizontal: 12,
                          vertical: 4,
                        ),
                        visualDensity: VisualDensity.compact,
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        labelStyle: TextStyle(
                          color:
                              selected
                                  ? Colors.white
                                  : theme.textTheme.bodyMedium?.color,
                        ),
                        selectedColor: theme.colorScheme.primary,
                      ),
                    );
                  }).toList(),
            ),
          ),
        ],
      ),
    );
  }

  static const _statusOptions = [
    ('all', 'Todos'),
    ('published', 'Publicados'),
    ('draft', 'Borradores'),
    ('hidden', 'Ocultos'),
  ];
}

class CatalogKpiSummary extends StatelessWidget {
  final List<PublicProduct> products;
  const CatalogKpiSummary({super.key, required this.products});

  @override
  Widget build(BuildContext context) {
    final active = products.where((p) => p.isVisible && p.isActive).length;
    final hidden = products.where((p) => !p.isVisible).length;
    final drafts = products.where((p) => !p.isActive).length;
    final stats = [
      ('Activos', active),
      ('Ocultos', hidden),
      ('Borradores', drafts),
    ];

    return Row(
      children: [
        for (var i = 0; i < stats.length; i++)
          Expanded(
            child: Padding(
              padding: EdgeInsets.only(right: i == stats.length - 1 ? 0 : 12),
              child: AdminSurface(
                padding: const EdgeInsets.symmetric(
                  vertical: 14,
                  horizontal: 12,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '${stats[i].$2}',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      stats[i].$1,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ],
                ),
              ),
            ),
          ),
      ],
    );
  }
}

typedef CategoryNameResolver = String Function(String? categoryId);
typedef ProductAction = void Function(PublicProduct product);
typedef ProductVisibilityAction = void Function(PublicProduct product, bool visible);

class CatalogProductGrid extends StatelessWidget {
  final List<PublicProduct> products;
  final int columns;
  final bool gridMode;
  final CategoryNameResolver categoryNameResolver;
  final ProductAction onEdit;
  final ProductAction onPreview;
  final ProductVisibilityAction onToggleVisibility;

  const CatalogProductGrid({
    super.key,
    required this.products,
    required this.columns,
    required this.gridMode,
    required this.categoryNameResolver,
    required this.onEdit,
    required this.onPreview,
    required this.onToggleVisibility,
  });

  @override
  Widget build(BuildContext context) {
    return gridMode ? _buildGrid() : _buildList();
  }

  Widget _buildGrid() {
    return SliverGrid(
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: columns,
        mainAxisSpacing: 16,
        crossAxisSpacing: 16,
        childAspectRatio: columns == 1 ? 1.2 : 0.78,
      ),
      delegate: SliverChildBuilderDelegate((context, index) {
        final product = products[index];
        return AdminProductCard(
          product: product,
          categoryLabel: categoryNameResolver(product.categoryId),
          onEdit: () => onEdit(product),
          onPreview: () => onPreview(product),
          onToggleVisibility: (visible) => onToggleVisibility(product, visible),
        );
      }, childCount: products.length),
    );
  }

  Widget _buildList() {
    return SliverList(
      delegate: SliverChildBuilderDelegate((context, index) {
        final product = products[index];
        return Padding(
          padding: const EdgeInsets.only(bottom: 16),
          child: AdminProductCard(
            product: product,
            categoryLabel: categoryNameResolver(product.categoryId),
            onEdit: () => onEdit(product),
            onPreview: () => onPreview(product),
            onToggleVisibility:
                (visible) => onToggleVisibility(product, visible),
          ),
        );
      }, childCount: products.length),
    );
  }
}

class CatalogEmptyState extends StatelessWidget {
  final CatalogEmptyType type;
  final String? categoryName;
  final String statusFilter;
  final VoidCallback onCreateProduct;
  final VoidCallback onCreateCategory;
  final bool showActionButton;

  const CatalogEmptyState({
    super.key,
    required this.type,
    required this.categoryName,
    required this.statusFilter,
    required this.onCreateProduct,
    required this.onCreateCategory,
    this.showActionButton = true,
  });

  @override
  Widget build(BuildContext context) {
    final config = _EmptyStateConfig.resolve(
      type: type,
      categoryName: categoryName,
      statusFilter: statusFilter,
      onCreateProduct: onCreateProduct,
      onCreateCategory: onCreateCategory,
    );

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: AdminSurface(
        padding: const EdgeInsets.all(28),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.inbox_outlined, size: 48),
            const SizedBox(height: 12),
            Text(
              config.title,
              textAlign: TextAlign.center,
              style: Theme.of(
                context,
              ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w700),
            ),
            const SizedBox(height: 8),
            Text(config.subtitle, textAlign: TextAlign.center),
            if (showActionButton || config.showTips) ...[
              const SizedBox(height: 16),
              FilledButton.icon(
                onPressed: config.action,
                icon: const Icon(Icons.add),
                label: Text(config.buttonLabel),
              ),
            ],
            if (config.showTips) ...[
              const SizedBox(height: 12),
              const _TipRow(
                text: 'Usa fotos cuadradas y nitidas.',
                icon: Icons.photo_camera_outlined,
              ),
              const _TipRow(
                text: 'Define precio, SKU y stock.',
                icon: Icons.local_offer_outlined,
              ),
              const _TipRow(
                text: 'Controla visibilidad por estado.',
                icon: Icons.visibility_outlined,
              ),
            ],
          ],
        ),
      ),
    );
  }
}

class _TipRow extends StatelessWidget {
  final String text;
  final IconData icon;
  const _TipRow({required this.text, required this.icon});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(icon, size: 16),
          const SizedBox(width: 6),
          Expanded(child: Text(text)),
        ],
      ),
    );
  }
}

const _kNewProductLabel = 'Nuevo producto';

class _EmptyStateConfig {
  final String title;
  final String subtitle;
  final String buttonLabel;
  final VoidCallback action;
  final bool showTips;

  const _EmptyStateConfig({
    required this.title,
    required this.subtitle,
    required this.buttonLabel,
    required this.action,
    this.showTips = false,
  });

  static _EmptyStateConfig resolve({
    required CatalogEmptyType type,
    required String? categoryName,
    required String statusFilter,
    required VoidCallback onCreateProduct,
    required VoidCallback onCreateCategory,
  }) {
    _EmptyStateConfig productConfig({
      required String title,
      required String subtitle,
      bool showTips = false,
    }) {
      return _EmptyStateConfig(
        title: title,
        subtitle: subtitle,
        buttonLabel: _kNewProductLabel,
        action: onCreateProduct,
        showTips: showTips,
      );
    }

    switch (type) {
      case CatalogEmptyType.catalog:
        return productConfig(
          title: 'Tu catalogo esta vacio',
          subtitle: 'Usa fotos, precios y SKU para destacar tus productos.',
          showTips: true,
        );
      case CatalogEmptyType.noCategories:
        return _EmptyStateConfig(
          title: 'Aun no hay categorias',
          subtitle: 'Crea categorias para organizar tus productos por tipo.',
          buttonLabel: 'Nueva categoria',
          action: onCreateCategory,
        );
      case CatalogEmptyType.category:
        return productConfig(
          title: 'No hay productos en "${categoryName ?? 'esta categoria'}"',
          subtitle: 'Comienza creando un producto dentro de esta categoria.',
        );
      case CatalogEmptyType.status:
        final label = switch (statusFilter) {
          'draft' => 'borradores',
          'hidden' => 'ocultos',
          'published' => 'publicados',
          _ => 'este filtro',
        };
        return productConfig(
          title: 'No hay productos $label',
          subtitle: 'Crea o edita productos para este estado.',
        );
    }
  }
}

 END FILE: modules/features/admin/presentation/pages/catalog/admin_catalog_workspace_host.dart 

 FILE: modules/features/admin/presentation/pages/catalog/admin_product_detail_page.dart 
import 'package:flutter/material.dart';

import '../../../../catalog/domain/entities/public_product.dart';
import '../../widgets/shared/admin_tag_chip.dart';

class AdminProductDetailPage extends StatelessWidget {
  final PublicProduct product;
  const AdminProductDetailPage({super.key, required this.product});

  @override
  Widget build(BuildContext context) {
    final price = product.basePrice;
    return Scaffold(
      appBar: AppBar(title: Text(product.name)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(16),
            child: Container(
              height: 220,
              color: Colors.grey.shade100,
              child:
                  product.imageUrl == null
                      ? const Icon(Icons.image_outlined, size: 64)
                      : Image.network(product.imageUrl!, fit: BoxFit.cover),
            ),
          ),
          const SizedBox(height: 16),
          Wrap(
            spacing: 8,
            children: [
              ...product.tags.map((tag) => AdminTagChip(label: tag)),
              if (product.categoryId.isNotEmpty)
                AdminTagChip(label: product.categoryId),
            ],
          ),
          const SizedBox(height: 16),
          Text(
            '\$${price.toStringAsFixed(2)}',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 8),
          Text(product.description ?? 'Sin descripciÃ³n'),
          const SizedBox(height: 24),
          _InfoRow(label: 'SKU', value: product.sku ?? 'Sin SKU'),
          _InfoRow(label: 'Stock', value: '${product.stock}'),
          _InfoRow(label: 'Stock mÃ­nimo', value: '${product.minStock}'),
          _InfoRow(
            label: 'Estado',
            value: product.isVisible ? 'Publicado' : 'Oculto',
          ),
          const SizedBox(height: 24),
          FilledButton.icon(
            onPressed:
                () => ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('AcciÃ³n prÃ³ximamente')),
                ),
            icon: const Icon(Icons.check_circle_outline),
            label: const Text('Publicar cambios'),
          ),
        ],
      ),
    );
  }
}

class _InfoRow extends StatelessWidget {
  final String label;
  final String value;
  const _InfoRow({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          Expanded(
            flex: 2,
            child: Text(
              label,
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
          ),
          Expanded(flex: 3, child: Text(value)),
        ],
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/pages/catalog/admin_product_detail_page.dart 

 FILE: modules/features/admin/presentation/pages/catalog/catalog_presentation_page.dart 
import 'package:flutter/material.dart';

class CatalogPresentationPage extends StatelessWidget {
  const CatalogPresentationPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(title: const Text('Presentaciones')),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.layers_outlined, size: 56),
              const SizedBox(height: 16),
              Text(
                'GestiÃ³n de presentaciones prÃ³ximamente',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              const Text(
                'Pronto podrÃ¡s administrar presentaciones, variantes y combos desde aquÃ­.',
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/pages/catalog/catalog_presentation_page.dart 

Dentro de /dashboard:

 FILE: modules/features/admin/presentation/pages/dashboard/admin_dashboard_page.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../domain/entities/admin_dashboard_summary.dart';
import '../../blocs/admin_dashboard_cubit.dart';
import '../../widgets/dashboard/admin_dashboard_sections.dart';

class AdminDashboardPage extends StatelessWidget {
  const AdminDashboardPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<AdminDashboardCubit, AdminDashboardState>(
      builder: (context, state) {
        return switch (state) {
          AdminDashboardLoading() => const Center(
            child: CircularProgressIndicator(),
          ),
          AdminDashboardError(:final message) => _DashboardError(
            message: message,
            onRetry: () => context.read<AdminDashboardCubit>().start(),
          ),
          AdminDashboardLoaded(:final summary) => _DashboardContent(
            summary: summary,
          ),
        };
      },
    );
  }
}

class _DashboardContent extends StatelessWidget {
  final AdminDashboardSummary summary;
  const _DashboardContent({required this.summary});

  @override
  Widget build(BuildContext context) {
    final statusChips =
        summary.statusCounts.entries
            .map((e) => AdminSummaryChipData(_statusLabel(e.key), e.value))
            .toList();

    final kpiItems = [
      AdminKpiData(
        title: 'Pedidos (7 dÃ­as)',
        value: summary.ordersLast7Days.toString(),
        subtitle:
            '${_dateLabel(summary.rangeStart)} â ${_dateLabel(summary.rangeEnd)}',
      ),
      if (summary.topProducts.isNotEmpty)
        AdminKpiData(
          title: 'Top producto',
          value: summary.topProducts.first.name,
          subtitle: '+${summary.topProducts.first.total}',
        ),
      AdminKpiData(
        title: 'Tiempos promedio',
        value:
            summary.avgPreparationMinutes == null
                ? 'â'
                : 'Prep ${summary.avgPreparationMinutes!.toStringAsFixed(0)}m',
        subtitle:
            summary.avgDeliveryMinutes == null
                ? null
                : 'Entrega ${summary.avgDeliveryMinutes!.toStringAsFixed(0)}m',
      ),
      AdminKpiData(
        title: 'AnomalÃ­as',
        value: summary.expiredVouchers.toString(),
        subtitle: 'Vouchers vencidos',
      ),
    ];

    final quickActions = [
      QuickActionData(
        icon: Icons.add_box_outlined,
        label: 'Producto',
        onTap: () => _comingSoon(context),
      ),
      QuickActionData(
        icon: Icons.playlist_add_circle_outlined,
        label: 'PresentaciÃ³n',
        onTap: () => _comingSoon(context),
      ),
      QuickActionData(
        icon: Icons.calendar_month_outlined,
        label: 'Consultar por fecha',
        onTap: () => _comingSoon(context),
      ),
      QuickActionData(
        icon: Icons.map_outlined,
        label: 'Zonas / acuerdos',
        onTap: () => _comingSoon(context),
      ),
    ];

    return RefreshIndicator(
      onRefresh: () async => context.read<AdminDashboardCubit>().start(),
      child: ListView(
        padding: const EdgeInsets.fromLTRB(16, 16, 16, 120),
        children: [
          AdminDashboardHeader(
            referenceDate: summary.rangeEnd,
            onRefresh: () => context.read<AdminDashboardCubit>().start(),
          ),
          const SizedBox(height: 20),
          AdminSummaryChipRow(
            items: statusChips,
            onSelected: (_) => _comingSoon(context),
          ),
          const SizedBox(height: 24),
          AdminKpiGrid(items: kpiItems),
          const SizedBox(height: 24),
          const Text(
            'Accesos rÃ¡pidos',
            style: TextStyle(fontWeight: FontWeight.w700, fontSize: 16),
          ),
          const SizedBox(height: 12),
          AdminQuickActions(actions: quickActions),
          const SizedBox(height: 24),
          AdminNotificationsCard(
            items: const [],
            onViewAll: () => _comingSoon(context),
          ),
          const SizedBox(height: 24),
          AdminViewAllCard(
            title: 'Analytics',
            description: 'Explora tendencias y mÃ©tricas detalladas.',
            onView: () => _comingSoon(context),
          ),
        ],
      ),
    );
  }

  void _comingSoon(BuildContext context) {
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(const SnackBar(content: Text('PrÃ³ximamente')));
  }

  String _statusLabel(String status) {
    switch (status) {
      case 'new':
      case 'nuevo':
        return 'Nuevos';
      case 'pending_payment':
      case 'pendiente':
        return 'Pago pendiente';
      case 'in_process':
      case 'preparacion':
        return 'En preparaciÃ³n';
      case 'completed':
      case 'completado':
        return 'Completados';
      case 'canceled':
      case 'cancelado':
        return 'Cancelados';
      default:
        return status;
    }
  }

  String _dateLabel(DateTime date) =>
      '${date.day}/${date.month.toString().padLeft(2, '0')}';
}

class _DashboardError extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;
  const _DashboardError({required this.message, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('Error al cargar: $message'),
          const SizedBox(height: 12),
          FilledButton.icon(
            onPressed: onRetry,
            icon: const Icon(Icons.refresh),
            label: const Text('Reintentar'),
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/pages/dashboard/admin_dashboard_page.dart 

Dentro de /management:

 FILE: modules/features/admin/presentation/pages/management/admin_management_host.dart 
// lib/modules/features/admin/presentation/pages/management/admin_management_host.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:flutter_application_emprendedoras/modules/core/config/app_theme.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/admin_routes.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/blocs/admin_nav_cubit.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/admin_module_button.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/profile_routes.dart';

class AdminManagementHost extends StatelessWidget {
  const AdminManagementHost({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: ColoredBox(
        color: AppTheme.lightBg,
        child: ListView(
          padding: const EdgeInsets.fromLTRB(16, 16, 16, 120),
          children: [
            const Text(
              'Panel de gesti\u00f3n',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.w800),
            ),
            const SizedBox(height: 8),
            AdminModuleButton(
              icon: Icons.person,
              title: 'Tu cuenta',
              subtitle: 'Perfil y seguridad de la cuenta',
              onTap: () => Navigator.pushNamed(context, ProfileRoutes.account),
            ),
            const SizedBox(height: 20),
            const Text(
              '\u00c1reas de gesti\u00f3n',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
            ),
            const SizedBox(height: 8),
            AdminModuleButton(
              icon: Icons.receipt_long_outlined,
              title: 'Pedidos',
              subtitle: 'Revisa y actualiza estados',
              onTap: () => context.read<AdminNavCubit>().setTab(1),
            ),
            AdminModuleButton(
              icon: Icons.inventory_2_outlined,
              title: 'Cat\u00e1logo',
              subtitle: 'Gestiona productos y visibilidad',
              onTap: () => context.read<AdminNavCubit>().setTab(2),
            ),
            AdminModuleButton(
              icon: Icons.category_outlined,
              title: 'Categor\u00edas',
              subtitle: 'Organiza el cat\u00e1logo por secciones',
              onTap: () => Navigator.pushNamed(
                context,
                '${AdminRoutes.base}/catalog/categories',
              ),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/pages/management/admin_management_host.dart 

Dentro de /orders:

- FILE: modules/features/admin/presentation/pages/orders/admin_orders_host.dart 
// lib/modules/features/admin/presentation/pages/admin_orders_host.dart
import 'package:flutter/material.dart';

class AdminOrdersHost extends StatelessWidget {
  const AdminOrdersHost({super.key});

  @override
  Widget build(BuildContext context) {
    // AquÃ­ luego irÃ¡n tabs/filtros de pedidos
    return const Center(child: Text('Pedidos (host)'));
  }
}

 END FILE: modules/features/admin/presentation/pages/orders/admin_orders_host.dart 

Dentro de /widgets:

-- FILE: modules/features/admin/presentation/widgets/admin_module_button.dart --
import 'package:flutter/material.dart';

import '../../../../core/config/app_theme.dart';

class AdminModuleButton extends StatelessWidget {
  const AdminModuleButton({
    super.key,
    required this.icon,
    required this.title,
    this.subtitle,
    required this.onTap,
    this.destructive = false,
  });

  final IconData icon;
  final String title;
  final String? subtitle;
  final VoidCallback onTap;
  final bool destructive;

  @override
  Widget build(BuildContext context) {
    final baseColor = destructive ? Colors.red.shade50 : AppTheme.white;
    final accent = destructive ? Colors.red.shade600 : AppTheme.purpleDark;
    final borderColor = destructive
        ? Colors.red.shade100
        : Colors.black.withValues(alpha: 0.08);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Material(
        color: baseColor,
        borderRadius: BorderRadius.circular(14),
        child: InkWell(
          borderRadius: BorderRadius.circular(14),
          onTap: onTap,
          child: Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(14),
              border: Border.all(color: borderColor),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
            child: Row(
              children: [
                CircleAvatar(
                  radius: 20,
                  backgroundColor: accent.withValues(alpha: 0.12),
                  child: Icon(icon, color: accent),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: const TextStyle(
                          fontWeight: FontWeight.w700,
                          fontSize: 15,
                          color: AppTheme.black,
                        ),
                      ),
                      if (subtitle != null && subtitle!.trim().isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            subtitle!,
                            style: TextStyle(
                              color: Colors.black.withValues(alpha: 0.65),
                              fontSize: 13,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
                const Icon(Icons.chevron_right),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/admin_module_button.dart 

Dentro de /catalog:

 FILE: modules/features/admin/presentation/widgets/catalog/admin_categories_strip.dart 
import 'package:flutter/material.dart';

import '../../../../catalog/domain/entities/category.dart';
import '../../../../catalog/presentation/widgets/categories/category_carousel.dart';
import '../shared/admin_dashed_surface.dart';

class AdminCategoriesStrip extends StatelessWidget {
  final bool isLoading;
  final List<Category> categories;
  final String? selectedCategoryId;
  final ValueChanged<String?> onCategorySelected;
  final VoidCallback onManageCategories;
  final VoidCallback onCreateCategory;

  const AdminCategoriesStrip({
    super.key,
    required this.isLoading,
    required this.categories,
    required this.selectedCategoryId,
    required this.onCategorySelected,
    required this.onManageCategories,
    required this.onCreateCategory,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final hasCategories = categories.isNotEmpty;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(Icons.folder_open_outlined, color: theme.colorScheme.primary),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Categorias',
                    style: theme.textTheme.labelMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  Text(
                    'Agrupa tus productos en secciones.',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.textTheme.bodySmall?.color?.withValues(
                        alpha: 0.7,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            if (hasCategories)
              TextButton.icon(
                onPressed: onManageCategories,
                icon: const Icon(Icons.edit_outlined, size: 18),
                label: const Text('Personalizar'),
                style: TextButton.styleFrom(
                  visualDensity: VisualDensity.compact,
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                ),
              ),
          ],
        ),
        const SizedBox(height: 8),
        if (isLoading) const LinearProgressIndicator(minHeight: 2),
        if (isLoading) const SizedBox(height: 12),
        AdminDashedSurface(
          padding: const EdgeInsets.all(12),
          child:
              categories.isEmpty
                  ? _EmptyCategories(onCreateCategory: onCreateCategory)
                  : CategoryChipCarousel(
                    categories: categories,
                    selectedCategoryId: selectedCategoryId,
                    onCategorySelected: onCategorySelected,
                  ),
        ),
      ],
    );
  }
}

class _EmptyCategories extends StatelessWidget {
  final VoidCallback onCreateCategory;
  const _EmptyCategories({required this.onCreateCategory});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Icon(
          Icons.create_new_folder_outlined,
          color: theme.colorScheme.primary,
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'AÃºn no hay categorÃ­as',
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                'Crea la primera para empezar.',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.textTheme.bodySmall?.color?.withValues(
                    alpha: 0.7,
                  ),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(width: 12),
        FilledButton.icon(
          onPressed: onCreateCategory,
          icon: const Icon(Icons.add),
          label: const Text('Nueva categoria'),
          style: FilledButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),
            shape: const StadiumBorder(),
          ),
        ),
      ],
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/catalog/admin_categories_strip.dart 

Dentro de /dashboard:

 FILE: modules/features/admin/presentation/widgets/dashboard/admin_dashboard_sections.dart 
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../../../../core/config/app_theme.dart';
import 'quick_action_tile.dart';

class AdminDashboardHeader extends StatelessWidget {
  const AdminDashboardHeader({
    super.key,
    required this.referenceDate,
    required this.onRefresh,
  });

  final DateTime referenceDate;
  final VoidCallback onRefresh;

  @override
  Widget build(BuildContext context) {
    final now = DateTime.now();
    final bool isToday = DateUtils.isSameDay(referenceDate, now);
    final fechaLarga = DateFormat.yMMMMEEEEd('es_EC').format(referenceDate);
    final prefix =
        isToday
            ? 'Hoy'
            : _capitalize(DateFormat.EEEE('es_EC').format(referenceDate));
    final title = '$prefix - $fechaLarga';

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Row(
          children: [
            Expanded(
              child: Text(
                title,
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.w700,
                  color: AppTheme.purpleDark,
                ),
              ),
            ),
            FilledButton.icon(
              onPressed: onRefresh,
              icon: const Icon(Icons.refresh),
              label: const Text('Actualizar'),
            ),
          ],
        ),
      ),
    );
  }

  String _capitalize(String value) {
    if (value.isEmpty) return value;
    return value[0].toUpperCase() + value.substring(1);
  }
}

class AdminSummaryChipRow extends StatelessWidget {
  const AdminSummaryChipRow({
    super.key,
    required this.items,
    required this.onSelected,
  });

  final List<AdminSummaryChipData> items;
  final ValueChanged<AdminSummaryChipData> onSelected;

  @override
  Widget build(BuildContext context) {
    if (items.isEmpty) {
      return const Text(
        'AÃºn no hay pedidos registrados.',
        style: TextStyle(color: Colors.black54),
      );
    }

    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children:
          items
              .map(
                (item) => FilterChip(
                  label: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(item.label),
                      const SizedBox(width: 6),
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 6,
                          vertical: 2,
                        ),
                        decoration: BoxDecoration(
                          color: AppTheme.blue.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(999),
                        ),
                        child: Text(
                          item.count.toString(),
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                      ),
                    ],
                  ),
                  selectedColor: AppTheme.blueLight.withValues(alpha: 0.2),
                  selected: false,
                  onSelected: (_) => onSelected(item),
                ),
              )
              .toList(),
    );
  }
}

class AdminSummaryChipData {
  final String label;
  final int count;
  const AdminSummaryChipData(this.label, this.count);
}

class AdminKpiGrid extends StatelessWidget {
  const AdminKpiGrid({super.key, required this.items});

  final List<AdminKpiData> items;

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children:
          items
              .map(
                (item) => SizedBox(
                  width: 160,
                  child: Card(
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            item.title,
                            style: const TextStyle(color: Colors.black54),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            item.value,
                            style: const TextStyle(
                              fontSize: 22,
                              fontWeight: FontWeight.bold,
                              color: AppTheme.purpleDark,
                            ),
                          ),
                          if (item.subtitle != null) ...[
                            const SizedBox(height: 4),
                            Text(
                              item.subtitle!,
                              style: const TextStyle(
                                fontSize: 12,
                                color: Colors.black54,
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                  ),
                ),
              )
              .toList(),
    );
  }
}

class AdminKpiData {
  final String title;
  final String value;
  final String? subtitle;
  const AdminKpiData({required this.title, required this.value, this.subtitle});
}

class AdminNotificationsCard extends StatelessWidget {
  const AdminNotificationsCard({
    super.key,
    required this.items,
    required this.onViewAll,
  });

  final List<AdminNotificationPreview> items;
  final VoidCallback onViewAll;

  @override
  Widget build(BuildContext context) {
    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Text(
                  'Notificaciones',
                  style: TextStyle(fontWeight: FontWeight.w700),
                ),
                const Spacer(),
                TextButton(
                  onPressed: onViewAll,
                  child: const Text('Ver todas'),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (items.isEmpty)
              const Text(
                'No tienes notificaciones recientes.',
                style: TextStyle(color: Colors.black54),
              )
            else
              ...items.map(
                (n) => ListTile(
                  contentPadding: EdgeInsets.zero,
                  leading: Icon(n.icon, color: AppTheme.purpleDark),
                  title: Text(n.title),
                  subtitle: Text(n.subtitle),
                  trailing: Text(
                    n.relativeTime,
                    style: const TextStyle(color: Colors.black45, fontSize: 12),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class AdminNotificationPreview {
  final String title;
  final String subtitle;
  final String relativeTime;
  final IconData icon;

  const AdminNotificationPreview({
    required this.title,
    required this.subtitle,
    required this.relativeTime,
    this.icon = Icons.notifications_none_outlined,
  });
}

class AdminQuickActions extends StatelessWidget {
  const AdminQuickActions({super.key, required this.actions});

  final List<QuickActionData> actions;

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children:
          actions
              .map(
                (a) => QuickActionTile(
                  icon: a.icon,
                  label: a.label,
                  onTap: a.onTap,
                ),
              )
              .toList(),
    );
  }
}

class QuickActionData {
  final IconData icon;
  final String label;
  final VoidCallback onTap;
  const QuickActionData({
    required this.icon,
    required this.label,
    required this.onTap,
  });
}

class AdminViewAllCard extends StatelessWidget {
  const AdminViewAllCard({
    super.key,
    required this.title,
    required this.description,
    required this.onView,
  });

  final String title;
  final String description;
  final VoidCallback onView;

  @override
  Widget build(BuildContext context) {
    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: const TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 6),
                  Text(description),
                ],
              ),
            ),
            FilledButton(onPressed: onView, child: const Text('Ver todo')),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/dashboard/admin_dashboard_sections.dart 

 FILE: modules/features/admin/presentation/widgets/dashboard/quick_action_tile.dart 
// lib/modules/features/admin/presentation/widgets/quick_action_tile.dart
import 'package:flutter/material.dart';

/// Variante ListTile M3 para acciones rÃ¡pidas (Admin Dashboard).
/// Reemplaza surfaceVariant (deprecated) -> surfaceContainerHighest.
class QuickActionTile extends StatelessWidget {
  const QuickActionTile({
    super.key,
    required this.icon,
    required this.label,
    this.onTap,
  });
  final IconData icon;
  final String label;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;
    return SizedBox(
      width: 180,
      child: ListTile(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        tileColor: scheme.surfaceContainerHighest, // <-- fix deprecado
        leading: Icon(icon),
        title: Text(label),
        onTap: onTap,
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/dashboard/quick_action_tile.dart 

Dentro de /forms:

 FILE: modules/features/admin/presentation/widgets/forms/admin_form_section.dart 
import 'package:flutter/material.dart';

import '../shared/admin_surface.dart';

class AdminFormSection extends StatelessWidget {
  final String title;
  final String? subtitle;
  final Widget? leading;
  final Widget? trailing;
  final List<Widget> children;
  final EdgeInsetsGeometry padding;

  const AdminFormSection({
    super.key,
    required this.title,
    this.subtitle,
    this.leading,
    this.trailing,
    required this.children,
    this.padding = const EdgeInsets.all(20),
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return AdminSurface(
      padding: padding,
      borderRadius: 24,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (leading != null) ...[leading!, const SizedBox(width: 12)],
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                    if (subtitle != null && subtitle!.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        subtitle!,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.textTheme.bodySmall?.color?.withValues(
                            alpha: 0.75,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              if (trailing != null) ...[const SizedBox(width: 12), trailing!],
            ],
          ),
          if (children.isNotEmpty) ...[
            const SizedBox(height: 16),
            ..._withSpacing(children),
          ],
        ],
      ),
    );
  }

  List<Widget> _withSpacing(List<Widget> widgets) {
    final list = <Widget>[];
    for (var i = 0; i < widgets.length; i++) {
      list.add(widgets[i]);
      if (i != widgets.length - 1) {
        list.add(const SizedBox(height: 12));
      }
    }
    return list;
  }
}

class AdminFormButtonBar extends StatelessWidget {
  final List<Widget> buttons;
  final double spacing;

  const AdminFormButtonBar({
    super.key,
    required this.buttons,
    this.spacing = 12,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final canRow = constraints.maxWidth >= 520 && buttons.length <= 3;
        if (canRow) {
          return Row(
            children: [
              for (var i = 0; i < buttons.length; i++) ...[
                Expanded(child: buttons[i]),
                if (i != buttons.length - 1) SizedBox(width: spacing),
              ],
            ],
          );
        }
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            for (var i = 0; i < buttons.length; i++) ...[
              buttons[i],
              if (i != buttons.length - 1) SizedBox(height: spacing),
            ],
          ],
        );
      },
    );
  }
}

class AdminSwitchTile extends StatelessWidget {
  final String title;
  final String? subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;

  const AdminSwitchTile({
    super.key,
    required this.title,
    this.subtitle,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20),
        color: theme.colorScheme.surfaceContainerHighest.withValues(alpha: 0.4),
      ),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  title,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
                ),
                if (subtitle != null && subtitle!.isNotEmpty) ...[
                  const SizedBox(height: 4),
                  Text(subtitle!, style: theme.textTheme.bodySmall),
                ],
              ],
            ),
          ),
          Switch.adaptive(value: value, onChanged: onChanged),
        ],
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/forms/admin_form_section.dart 

 FILE: modules/features/admin/presentation/widgets/forms/admin_media_picker_field.dart 
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_application_emprendedoras/modules/core/services/media/i_image_source.dart';

import '../shared/admin_dashed_surface.dart';

class AdminMediaPickerField extends StatelessWidget {
  final String title;
  final String subtitle;
  final String? imageUrl;
  final Uint8List? imageBytes;
  final bool processing;
  final Future<void> Function(NavigatorState navigator, AppImageSource source)?
  onPickImage;
  final Future<void> Function()? onPasteUrl;
  final VoidCallback? onRemove;

  const AdminMediaPickerField({
    super.key,
    required this.title,
    required this.subtitle,
    this.imageUrl,
    this.imageBytes,
    this.processing = false,
    this.onPickImage,
    this.onPasteUrl,
    this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final hasActions = onPickImage != null || onPasteUrl != null;
    final hasImage = imageBytes != null || (imageUrl?.isNotEmpty ?? false);
    return AdminDashedSurface(
      padding: const EdgeInsets.all(16),
      borderRadius: 24,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(16),
                  color: theme.colorScheme.primary.withValues(alpha: 0.08),
                ),
                child: Icon(
                  Icons.image_outlined,
                  color: theme.colorScheme.primary,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      subtitle,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.textTheme.bodySmall?.color?.withValues(
                          alpha: 0.7,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 12),
              if (hasActions)
                FilledButton.tonalIcon(
                  onPressed:
                      processing ? null : () => _showPickerSheet(context),
                  icon: const Icon(Icons.cloud_upload_outlined),
                  label: const Text('Subir'),
                ),
            ],
          ),
          if (imageBytes != null) ...[
            const SizedBox(height: 16),
            ClipRRect(
              borderRadius: BorderRadius.circular(18),
              child: AspectRatio(
                aspectRatio: 1,
                child: Image.memory(imageBytes!, fit: BoxFit.cover),
              ),
            ),
          ] else if (imageUrl != null && imageUrl!.isNotEmpty) ...[
            const SizedBox(height: 16),
            ClipRRect(
              borderRadius: BorderRadius.circular(18),
              child: AspectRatio(
                aspectRatio: 1,
                child: Image.network(
                  imageUrl!,
                  fit: BoxFit.cover,
                  errorBuilder: (context, _, _) {
                    return Container(
                      color: theme.colorScheme.surfaceContainerHighest,
                      alignment: Alignment.center,
                      child: const Icon(Icons.broken_image_outlined),
                    );
                  },
                ),
              ),
            ),
          ] else ...[
            const SizedBox(height: 16),
            Container(
              height: 120,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(18),
                border: Border.all(
                  color: theme.dividerColor.withValues(alpha: 0.5),
                  style: BorderStyle.solid,
                ),
              ),
              alignment: Alignment.center,
              child: Text(
                'Aun no has seleccionado una imagen.',
                style: theme.textTheme.bodySmall,
              ),
            ),
          ],
          if (_hasActionRow(hasImage)) ...[
            const SizedBox(height: 12),
            Wrap(
              spacing: 12,
              runSpacing: 8,
              children: [
                if (onPasteUrl != null)
                  TextButton.icon(
                    onPressed: processing ? null : onPasteUrl,
                    icon: const Icon(Icons.link_outlined),
                    label: const Text('Pegar URL'),
                  ),
                if (onRemove != null && hasImage)
                  TextButton.icon(
                    onPressed: processing ? null : onRemove,
                    icon: const Icon(Icons.delete_outline),
                    label: const Text('Quitar imagen'),
                    style: TextButton.styleFrom(
                      foregroundColor: theme.colorScheme.error,
                    ),
                  ),
                if (processing)
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 4),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: const [
                        SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        ),
                        SizedBox(width: 8),
                        Text('Procesando imagen...'),
                      ],
                    ),
                  ),
              ],
            ),
          ],
        ],
      ),
    );
  }

  bool _hasActionRow(bool hasImage) {
    return onPasteUrl != null || (onRemove != null && hasImage) || processing;
  }

  void _showPickerSheet(BuildContext context) {
    final pickHandler = onPickImage;
    final pasteHandler = onPasteUrl;
    if (pickHandler == null && pasteHandler == null) return;
    showModalBottomSheet(
      context: context,
      builder: (ctx) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (pickHandler != null) ...[
                ListTile(
                  leading: const Icon(Icons.photo_camera_outlined),
                  title: const Text('Tomar foto'),
                  onTap: () async {
                    Navigator.of(ctx).pop();
                    await pickHandler(Navigator.of(ctx), AppImageSource.camera);
                  },
                ),
                ListTile(
                  leading: const Icon(Icons.photo_library_outlined),
                  title: const Text('Elegir de galerÃ­a'),
                  onTap: () async {
                    Navigator.of(ctx).pop();
                    await pickHandler(
                      Navigator.of(ctx),
                      AppImageSource.gallery,
                    );
                  },
                ),
              ],
              if (pasteHandler != null)
                ListTile(
                  leading: const Icon(Icons.link_outlined),
                  title: const Text('Pegar URL'),
                  onTap: () async {
                    Navigator.of(ctx).pop();
                    await pasteHandler();
                  },
                ),
            ],
          ),
        );
      },
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/forms/admin_media_picker_field.dart 

Dentro de /product:

 FILE: modules/features/admin/presentation/widgets/product/admin_image_picker_grid.dart 
import 'package:flutter/material.dart';

import '../shared/admin_surface.dart';

class AdminImagePickerGrid extends StatelessWidget {
  final List<String> images;
  final VoidCallback onAddImage;
  final ValueChanged<int>? onRemoveImage;
  final bool dense;

  const AdminImagePickerGrid({
    super.key,
    required this.images,
    required this.onAddImage,
    this.onRemoveImage,
    this.dense = false,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = dense ? 10.0 : 14.0;
    final tiles = <Widget>[
      ...List.generate(
        images.length,
        (index) => _ImageTile(
          imageUrl: images[index],
          onRemove: onRemoveImage == null ? null : () => onRemoveImage!(index),
          dense: dense,
        ),
      ),
      _AddTile(onTap: onAddImage, dense: dense),
    ];

    return Wrap(spacing: spacing, runSpacing: spacing, children: tiles);
  }
}

class _ImageTile extends StatelessWidget {
  final String imageUrl;
  final VoidCallback? onRemove;
  final bool dense;

  const _ImageTile({required this.imageUrl, this.onRemove, this.dense = false});

  @override
  Widget build(BuildContext context) {
    final size = dense ? 88.0 : 104.0;
    return Stack(
      clipBehavior: Clip.none,
      children: [
        AdminSurface(
          padding: EdgeInsets.zero,
          borderRadius: 18,
          child: ClipRRect(
            borderRadius: BorderRadius.circular(18),
            child: Container(
              width: size,
              height: size,
              color: Colors.grey.shade900.withValues(alpha: 0.15),
              child:
                  imageUrl.isEmpty
                      ? const Icon(Icons.image_not_supported_outlined)
                      : Image.network(imageUrl, fit: BoxFit.cover),
            ),
          ),
        ),
        if (onRemove != null)
          Positioned(
            right: 8,
            top: 8,
            child: GestureDetector(
              onTap: onRemove,
              child: Container(
                decoration: const BoxDecoration(
                  color: Colors.black87,
                  shape: BoxShape.circle,
                ),
                padding: const EdgeInsets.all(4),
                child: const Icon(Icons.close, color: Colors.white, size: 15),
              ),
            ),
          ),
      ],
    );
  }
}

class _AddTile extends StatelessWidget {
  final VoidCallback onTap;
  final bool dense;

  const _AddTile({required this.onTap, this.dense = false});

  @override
  Widget build(BuildContext context) {
    final size = dense ? 88.0 : 104.0;
    final textTheme = Theme.of(context).textTheme;
    return GestureDetector(
      onTap: onTap,
      child: AdminSurface(
        padding: EdgeInsets.zero,
        borderRadius: 18,
        child: Container(
          width: size,
          height: size,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(18),
            border: Border.all(
              color: Colors.white.withValues(alpha: 0.2),
              style: BorderStyle.solid,
              width: 1.2,
            ),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.add_photo_alternate_outlined),
              const SizedBox(height: 4),
              Text('Agregar', style: textTheme.labelMedium),
              Text(
                'Imagen / cÃ¡mara',
                style: textTheme.bodySmall?.copyWith(fontSize: 10),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/product/admin_image_picker_grid.dart 

 FILE: modules/features/admin/presentation/widgets/product/admin_product_card.dart 
import 'package:flutter/material.dart';

import '../../../../catalog/domain/entities/public_product.dart';
import '../shared/admin_surface.dart';

class AdminProductCard extends StatelessWidget {
  final PublicProduct product;
  final VoidCallback? onEdit;
  final VoidCallback? onPreview;
  final ValueChanged<bool>? onToggleVisibility;
  final String? categoryLabel;

  const AdminProductCard({
    super.key,
    required this.product,
    this.onEdit,
    this.onPreview,
    this.onToggleVisibility,
    this.categoryLabel,
  });

  @override
  Widget build(BuildContext context) {
    final price = product.basePrice;
    final skuText =
        (product.sku ?? '').isEmpty ? 'Sin SKU' : 'SKU ${product.sku}';
    final categoryText =
        (categoryLabel ?? '').isEmpty ? 'Sin categoria' : categoryLabel!;
    final statusChips = <Widget>[
      _StatusPill(
        label: product.isVisible ? 'Visible' : 'Oculto',
        color: product.isVisible ? Colors.green : Colors.orange,
      ),
      if (!product.isActive)
        const _StatusPill(label: 'Borrador', color: Colors.amber),
    ];

    return AdminSurface(
      padding: EdgeInsets.zero,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ClipRRect(
            borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
            child: _ProductImage(imageUrl: product.imageUrl),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  product.name,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  '\$${price.toStringAsFixed(2)}',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                Text(skuText, style: Theme.of(context).textTheme.bodySmall),
                const SizedBox(height: 2),
                Text(
                  categoryText,
                  style: Theme.of(
                    context,
                  ).textTheme.bodySmall?.copyWith(color: Colors.grey.shade600),
                ),
                const SizedBox(height: 12),
                Wrap(spacing: 8, runSpacing: 8, children: statusChips),
                const SizedBox(height: 12),
                Divider(color: Colors.grey.shade200),
                const SizedBox(height: 8),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _ActionIconButton(
                      icon: Icons.remove_red_eye_outlined,
                      tooltip: 'Vista previa',
                      onPressed: onPreview,
                    ),
                    _ActionIconButton(
                      icon:
                          product.isVisible
                              ? Icons.visibility_off_outlined
                              : Icons.visibility_outlined,
                      tooltip: product.isVisible ? 'Ocultar' : 'Publicar',
                      onPressed:
                          onToggleVisibility == null
                              ? null
                              : () => onToggleVisibility!(!product.isVisible),
                    ),
                    _ActionIconButton(
                      icon: Icons.edit_outlined,
                      tooltip: 'Editar',
                      onPressed: onEdit,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _ProductImage extends StatelessWidget {
  final String? imageUrl;
  const _ProductImage({this.imageUrl});

  @override
  Widget build(BuildContext context) {
    return AspectRatio(
      aspectRatio: 4 / 3,
      child: Container(
        width: double.infinity,
        color: Colors.grey.shade200,
        child:
            imageUrl == null || imageUrl!.isEmpty
                ? const Icon(Icons.image_outlined, size: 32)
                : Image.network(imageUrl!, fit: BoxFit.cover),
      ),
    );
  }
}

class _StatusPill extends StatelessWidget {
  final String label;
  final Color color;
  const _StatusPill({required this.label, required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.12),
        borderRadius: BorderRadius.circular(999),
      ),
      child: Text(
        label,
        style: TextStyle(color: color, fontWeight: FontWeight.w600),
      ),
    );
  }
}

class _ActionIconButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final VoidCallback? onPressed;

  const _ActionIconButton({
    required this.icon,
    required this.tooltip,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return IconButton(
      tooltip: tooltip,
      onPressed: onPressed,
      style: IconButton.styleFrom(backgroundColor: Colors.grey.shade100),
      icon: Icon(icon),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/product/admin_product_card.dart 

 FILE: modules/features/admin/presentation/widgets/product/admin_product_form_actions.dart 
import 'package:flutter/material.dart';

import '../shared/admin_autosave_indicator.dart';
import '../shared/admin_surface.dart';

class AdminProductFormActions extends StatelessWidget {
  final bool isNew;
  final bool isSaving;
  final DateTime? lastSavedAt;
  final VoidCallback onPrimary;
  final VoidCallback onSecondary;
  final VoidCallback? onDelete;

  const AdminProductFormActions({
    super.key,
    required this.isNew,
    required this.isSaving,
    required this.lastSavedAt,
    required this.onPrimary,
    required this.onSecondary,
    this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      top: false,
      child: AdminSurface(
        highlight: true,
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            AdminAutosaveIndicator(
              lastSavedAt: lastSavedAt,
              isSaving: isSaving,
              isDraft: isNew,
            ),
            const SizedBox(height: 16),
            isNew ? _BuildCreateActions(this) : _BuildEditActions(this),
          ],
        ),
      ),
    );
  }
}

class _BuildCreateActions extends StatelessWidget {
  final AdminProductFormActions data;
  const _BuildCreateActions(this.data);

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: OutlinedButton(
            onPressed: data.isSaving ? null : data.onSecondary,
            child: const Text('Guardar borrador'),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: FilledButton(
            onPressed: data.isSaving ? null : data.onPrimary,
            child:
                data.isSaving
                    ? const SizedBox(
                      height: 18,
                      width: 18,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                    : const Text('Crear producto'),
          ),
        ),
      ],
    );
  }
}

class _BuildEditActions extends StatelessWidget {
  final AdminProductFormActions data;
  const _BuildEditActions(this.data);

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(
          tooltip: 'Eliminar',
          onPressed: data.onDelete,
          icon: const Icon(Icons.delete_outline),
        ),
        const SizedBox(width: 8),
        Expanded(
          child: FilledButton(
            onPressed: data.isSaving ? null : data.onPrimary,
            child:
                data.isSaving
                    ? const SizedBox(
                      height: 18,
                      width: 18,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                    : const Text('Guardar cambios'),
          ),
        ),
      ],
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/product/admin_product_form_actions.dart 

Dentro de /shared:

 FILE: modules/features/admin/presentation/widgets/shared/admin_autosave_indicator.dart 
import 'package:flutter/material.dart';

class AdminAutosaveIndicator extends StatelessWidget {
  final DateTime? lastSavedAt;
  final bool isSaving;
  final bool isDraft;

  const AdminAutosaveIndicator({
    super.key,
    required this.lastSavedAt,
    this.isSaving = false,
    this.isDraft = true,
  });

  @override
  Widget build(BuildContext context) {
    final text =
        isSaving
            ? 'Guardando cambios...'
            : lastSavedAt == null
            ? (isDraft ? 'Borrador sin guardar' : 'Listo para publicar')
            : 'Borrador guardado ${_relativeTime(lastSavedAt!)}';

    return Row(
      children: [
        Icon(
          isSaving ? Icons.autorenew : Icons.check_circle,
          size: 16,
          color: isSaving ? Colors.orange : Colors.green,
        ),
        const SizedBox(width: 6),
        Text(
          text,
          style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
        ),
      ],
    );
  }

  String _relativeTime(DateTime date) {
    final diff = DateTime.now().difference(date);
    if (diff.inMinutes < 1) return 'hace segundos';
    if (diff.inMinutes == 1) return 'hace 1 minuto';
    if (diff.inMinutes < 60) return 'hace ${diff.inMinutes} min';
    if (diff.inHours == 1) return 'hace 1 hora';
    if (diff.inHours < 24) return 'hace ${diff.inHours} h';
    return 'hace ${diff.inDays} d';
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_autosave_indicator.dart 

--- FILE: modules/features/admin/presentation/widgets/shared/admin_badge.dart --
// lib/modules/features/admin/presentation/widgets/admin_badge.dart
import 'package:flutter/material.dart';

import '../../../../../core/config/app_theme.dart';

class AdminBadge extends StatelessWidget {
  const AdminBadge({super.key});

  @override
  Widget build(BuildContext context) {
    return Chip(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
      visualDensity: VisualDensity.compact,
      shape: StadiumBorder(
        side: BorderSide(color: AppTheme.purpleDark.withValues(alpha: 0.2)),
      ),
      avatar: const Icon(
        Icons.verified_user,
        size: 16,
        color: AppTheme.purpleDark,
      ),
      label: const Text(
        'ADMIN',
        style: TextStyle(
          color: AppTheme.purpleDark,
          fontWeight: FontWeight.w600,
          letterSpacing: 0.5,
        ),
      ),
      backgroundColor: AppTheme.purpleDark.withValues(alpha: 0.05),
    );
  }
}

- END FILE: modules/features/admin/presentation/widgets/shared/admin_badge.dart 

 FILE: modules/features/admin/presentation/widgets/shared/admin_bottom_cta.dart 
import 'package:flutter/material.dart';

class AdminBottomCta extends StatelessWidget {
  final String label;
  final IconData? icon;
  final VoidCallback onPressed;
  final EdgeInsetsGeometry margin;

  const AdminBottomCta({
    super.key,
    required this.label,
    required this.onPressed,
    this.icon,
    this.margin = const EdgeInsets.fromLTRB(16, 0, 16, 16),
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: margin,
      child: SizedBox(
        width: double.infinity,
        child: FilledButton.icon(
          onPressed: onPressed,
          icon: Icon(icon ?? Icons.add),
          label: Text(label),
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_bottom_cta.dart 

 FILE: modules/features/admin/presentation/widgets/shared/admin_dashed_surface.dart 
import 'package:flutter/material.dart';

class AdminDashedSurface extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;
  final double borderRadius;
  final double strokeWidth;
  final double dashWidth;
  final double dashGap;
  final Color? borderColor;
  final Color? backgroundColor;

  const AdminDashedSurface({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(16),
    this.borderRadius = 16,
    this.strokeWidth = 1.5,
    this.dashWidth = 6,
    this.dashGap = 4,
    this.borderColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final color =
        borderColor ??
        Theme.of(context).colorScheme.primary.withValues(alpha: 0.4);
    final bg = backgroundColor ?? Theme.of(context).colorScheme.surface;

    return CustomPaint(
      painter: _DashedBorderPainter(
        color: color,
        strokeWidth: strokeWidth,
        dashWidth: dashWidth,
        dashGap: dashGap,
        radius: borderRadius,
      ),
      child: Container(
        decoration: BoxDecoration(
          color: bg,
          borderRadius: BorderRadius.circular(borderRadius),
        ),
        padding: padding,
        child: child,
      ),
    );
  }
}

class _DashedBorderPainter extends CustomPainter {
  final Color color;
  final double strokeWidth;
  final double dashWidth;
  final double dashGap;
  final double radius;

  _DashedBorderPainter({
    required this.color,
    required this.strokeWidth,
    required this.dashWidth,
    required this.dashGap,
    required this.radius,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final rect = Offset.zero & size;
    final rrect = RRect.fromRectAndRadius(rect, Radius.circular(radius));
    final paint =
        Paint()
          ..color = color
          ..style = PaintingStyle.stroke
          ..strokeWidth = strokeWidth;

    final path = Path()..addRRect(rrect);
    final dashed = _createDashedPath(path, dashWidth, dashGap);
    canvas.drawPath(dashed, paint);
  }

  Path _createDashedPath(Path source, double dashWidth, double dashGap) {
    final metrics = source.computeMetrics();
    final Path dest = Path();
    for (final metric in metrics) {
      double distance = 0;
      while (distance < metric.length) {
        final length = dashWidth.clamp(0.0, metric.length - distance);
        dest.addPath(
          metric.extractPath(distance, distance + length),
          Offset.zero,
        );
        distance += dashWidth + dashGap;
      }
    }
    return dest;
  }

  @override
  bool shouldRepaint(covariant _DashedBorderPainter oldDelegate) {
    return oldDelegate.color != color ||
        oldDelegate.strokeWidth != strokeWidth ||
        oldDelegate.dashWidth != dashWidth ||
        oldDelegate.dashGap != dashGap ||
        oldDelegate.radius != radius;
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_dashed_surface.dart 

 FILE: modules/features/admin/presentation/widgets/shared/admin_form_field.dart 
import 'package:flutter/material.dart';

class AdminFormField extends StatelessWidget {
  final String label;
  final TextEditingController controller;
  final String? hintText;
  final ValueChanged<String>? onChanged;
  final TextInputType? keyboardType;
  final bool enabled;
  final int maxLines;
  final int? minLines;
  final TextInputAction? textInputAction;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final String? supportingText;
  final TextCapitalization textCapitalization;

  const AdminFormField({
    super.key,
    required this.label,
    required this.controller,
    this.hintText,
    this.onChanged,
    this.keyboardType,
    this.enabled = true,
    this.maxLines = 1,
    this.textInputAction,
    this.minLines,
    this.prefixIcon,
    this.suffixIcon,
    this.supportingText,
    this.textCapitalization = TextCapitalization.sentences,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: theme.textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 6),
        TextField(
          controller: controller,
          enabled: enabled,
          keyboardType: keyboardType,
          maxLines: maxLines,
          minLines: minLines,
          textCapitalization: textCapitalization,
          textInputAction: textInputAction,
          decoration: InputDecoration(
            hintText: hintText,
            prefixIcon: prefixIcon,
            suffixIcon: suffixIcon,
            helperText: supportingText,
          ),
          onChanged: onChanged,
        ),
      ],
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_form_field.dart 

--- FILE: modules/features/admin/presentation/widgets/shared/admin_only.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../profile/presentation/blocs/profile_overview_cubit.dart';
import '../../../../auth/domain/role_utils.dart';

/// Envuelve contenido visible SOLO para roles admin/staff (desde ProfileCubit).
class AdminOnly extends StatelessWidget {
  final Widget child;
  const AdminOnly({super.key, required this.child});

  bool _isAdmin(ProfileState st) {
    if (st is! ProfileLoaded) return false;
    return isAdminRole(st.profile.role) || isSuperRole(st.profile.role);
  }

  @override
  Widget build(BuildContext context) {
    final st = context.watch<ProfileCubit>().state;
    if (_isAdmin(st)) return child;
    return const SizedBox.shrink();
  }
}

- END FILE: modules/features/admin/presentation/widgets/shared/admin_only.dart -

 FILE: modules/features/admin/presentation/widgets/shared/admin_section_header.dart 
import 'package:flutter/material.dart';

class AdminSectionHeader extends StatelessWidget {
  final String title;
  final String? subtitle;
  final Widget? trailing;
  final EdgeInsetsGeometry padding;

  const AdminSectionHeader({
    super.key,
    required this.title,
    this.subtitle,
    this.trailing,
    this.padding = const EdgeInsets.only(bottom: 12),
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: padding,
      child: Row(
        crossAxisAlignment:
            subtitle == null
                ? CrossAxisAlignment.center
                : CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                if (subtitle != null) ...[
                  const SizedBox(height: 4),
                  Text(subtitle!, style: theme.textTheme.bodySmall),
                ],
              ],
            ),
          ),
          if (trailing != null) trailing!,
        ],
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_section_header.dart 

-- FILE: modules/features/admin/presentation/widgets/shared/admin_surface.dart -
import 'package:flutter/material.dart';

/// Base surface used across the admin experience.
///
/// Provides a consistent rounded container with optional gradient highlight
/// so widgets feel cohesive and can be reused between product, catalog and
/// dashboard screens.
class AdminSurface extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;
  final EdgeInsetsGeometry? margin;
  final bool highlight;
  final double borderRadius;

  const AdminSurface({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(16),
    this.margin,
    this.highlight = false,
    this.borderRadius = 24,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final baseColor =
        isDark ? const Color(0xFF11192E) : theme.colorScheme.surface;

    final decoration = BoxDecoration(
      color: highlight ? null : baseColor.withValues(alpha: isDark ? 0.95 : 1),
      gradient:
          highlight
              ? const LinearGradient(
                colors: [Color(0xFF0D1B3E), Color(0xFF152D54)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              )
              : null,
      borderRadius: BorderRadius.circular(borderRadius),
      border: Border.all(
        color:
            isDark
                ? Colors.white.withValues(alpha: 0.06)
                : Colors.black.withValues(alpha: 0.05),
      ),
      boxShadow: [
        BoxShadow(
          color: Colors.black.withValues(alpha: isDark ? 0.45 : 0.07),
          blurRadius: highlight ? 32 : 20,
          offset: const Offset(0, 14),
        ),
      ],
    );

    return Container(
      margin: margin,
      padding: padding,
      decoration: decoration,
      child: child,
    );
  }
}

class AdminFormSectionCard extends StatelessWidget {
  final String title;
  final String? subtitle;
  final List<Widget> children;
  final Widget? trailing;

  const AdminFormSectionCard({
    super.key,
    required this.title,
    this.subtitle,
    required this.children,
    this.trailing,
  });

  @override
  Widget build(BuildContext context) {
    final header = Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: Theme.of(
                  context,
                ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w700),
              ),
              if (subtitle != null) ...[
                const SizedBox(height: 4),
                Text(
                  subtitle!,
                  style: Theme.of(
                    context,
                  ).textTheme.bodySmall?.copyWith(color: Colors.white70),
                ),
              ],
            ],
          ),
        ),
        if (trailing != null) trailing!,
      ],
    );

    return AdminSurface(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          header,
          const SizedBox(height: 16),
          ..._withSpacing(children),
        ],
      ),
    );
  }

  List<Widget> _withSpacing(List<Widget> widgets) {
    final result = <Widget>[];
    for (var i = 0; i < widgets.length; i++) {
      result.add(widgets[i]);
      if (i != widgets.length - 1) {
        result.add(const SizedBox(height: 12));
      }
    }
    return result;
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_surface.dart 

- FILE: modules/features/admin/presentation/widgets/shared/admin_tag_chip.dart -
import 'package:flutter/material.dart';

import '../../../../../core/config/app_theme.dart';

class AdminTagChip extends StatelessWidget {
  final String label;
  final bool selected;
  final VoidCallback? onTap;

  const AdminTagChip({
    super.key,
    required this.label,
    this.selected = true,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final bgColor =
        selected
            ? AppTheme.purpleLight.withValues(alpha: 0.15)
            : Colors.grey.shade200;
    final textColor = selected ? AppTheme.purpleDark : Colors.black54;
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
        decoration: BoxDecoration(
          color: bgColor,
          borderRadius: BorderRadius.circular(999),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: textColor,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_tag_chip.dart 

-- FILE: modules/features/admin/presentation/widgets/shared/admin_top_bar.dart -
import 'package:flutter/material.dart';

import '../../../../../core/config/app_theme.dart';
import 'admin_badge.dart';

class AdminTopBar extends StatelessWidget implements PreferredSizeWidget {
  const AdminTopBar({
    super.key,
    required this.title,
    this.onNotifications,
    this.actions,
    this.showBadge = true,
    this.useTopSafeArea = true,
  });

  final String title;
  final VoidCallback? onNotifications;
  final List<Widget>? actions;
  final bool showBadge;
  final bool useTopSafeArea;

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight + 8);

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;

    final bar = Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    fontSize: 22,
                    fontWeight: FontWeight.w700,
                    color: AppTheme.purpleDark,
                  ),
                ),
                if (showBadge) ...[
                  const SizedBox(height: 4),
                  const AdminBadge(),
                ],
              ],
            ),
          ),
          if (onNotifications != null)
            IconButton(
              tooltip: 'Notificaciones',
              onPressed: onNotifications,
              icon: const Icon(Icons.notifications_none_outlined),
            ),
          if (actions != null) ...actions!,
        ],
      ),
    );

    final content = useTopSafeArea ? SafeArea(bottom: false, child: bar) : bar;

    return Material(color: scheme.surface, elevation: 0, child: content);
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_top_bar.dart 

 FILE: modules/features/admin/presentation/widgets/shared/admin_visibility_toggle.dart 
import 'package:flutter/material.dart';

class AdminVisibilityToggle extends StatelessWidget {
  final bool value;
  final ValueChanged<bool> onChanged;
  final String label;

  const AdminVisibilityToggle({
    super.key,
    required this.value,
    required this.onChanged,
    this.label = 'Visible en catalogo',
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: const TextStyle(fontWeight: FontWeight.w600)),
              const SizedBox(height: 4),
              Text(
                value
                    ? 'Los clientes pueden ver este producto'
                    : 'Inactivo para los clientes',
                style: TextStyle(color: Colors.grey.shade600, fontSize: 12),
              ),
            ],
          ),
        ),
        Switch(value: value, onChanged: onChanged),
      ],
    );
  }
}

 END FILE: modules/features/admin/presentation/widgets/shared/admin_visibility_toggle.dart 

Dentro de /auth:

----------------- FILE: modules/features/auth/auth_routes.dart -----------------
// modules/features/auth/auth_routes.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// FlutterFire
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

// Pages
import 'presentation/pages/welcome_page.dart';
import 'presentation/pages/role_selection_page.dart';
import 'presentation/pages/register_page.dart';
import 'presentation/pages/access_request_page.dart';
import 'presentation/pages/email_verification_page.dart';
import 'presentation/pages/login_page.dart' as login_page;
import 'presentation/pages/forgot_password_page.dart' as forgot;

// Blocs
import 'presentation/blocs/role_selection_cubit.dart';
import 'presentation/blocs/access_request_cubit.dart';
import 'presentation/blocs/password_reset_cubit.dart';
import 'presentation/blocs/email_verification_cubit.dart';

// Access Request + Invites
import 'data/datasources/access_request_remote_datasource.dart';
import 'data/repositories/access_request_repository_impl.dart';
import 'domain/usecases/get_my_access_request.dart';
import 'domain/usecases/submit_access_request.dart';

import 'data/datasources/invite_codes_remote_datasource.dart';
import 'data/repositories/invite_codes_repository_impl.dart';
import 'domain/usecases/verify_admin_invite.dart';
import 'domain/usecases/consume_admin_invite.dart';

// Storage
import '../../core/services/storage/cloudinary_storage_service.dart';

// Registro directo
import 'data/datasources/remote_auth_datasource.dart';
import 'data/repositories/auth_repository_impl.dart';
import 'domain/usecases/register_user.dart';
import 'domain/usecases/send_email_verification.dart';
import 'domain/usecases/reload_user.dart';
import 'domain/usecases/update_verification_grace.dart';

// Password reset
import 'data/datasources/password_reset_remote_datasource.dart';
import 'data/repositories/password_reset_repository_impl.dart';
import 'domain/usecases/send_password_reset_email.dart';
import 'domain/usecases/start_phone_verification.dart';
import 'domain/usecases/recovery_lookup.dart';
import 'domain/usecases/finish_password_reset_with_proof.dart';
import 'domain/usecases/verify_otp_get_proof.dart';

// Proveedores
import '../../core/services/otp/firebase_otp_provider.dart';
import '../../core/services/otp/otp_provider.dart';
import '../../core/services/email/firebase_email_reset_provider.dart';
import '../../core/services/email/email_reset_provider.dart';
import '../../core/services/storage/verification_grace_storage.dart';

class AuthRoutes {
  static const welcome = '/auth/welcome';
  static const roleSelection = '/auth/role_selection';
  static const accessRequest = '/auth/access_request';
  static const register = '/auth/register';
  static const login = '/auth/login';
  static const emailVerification = '/auth/email_verification';
  static const forgotPassword = '/auth/forgot_password';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case welcome:
      case '/auth':
        return MaterialPageRoute(
          settings: settings,
          builder: (_) => const WelcomePage(),
        );

      case roleSelection:
        return MaterialPageRoute(
          settings: settings,
          builder:
              (_) => BlocProvider(
                create: (_) => RoleSelectionCubit(),
                child: const RoleSelectionPage(),
              ),
        );

      case accessRequest:
        {
          final fs = FirebaseFirestore.instance;

          // Invites
          final invitesDs = InviteCodesRemoteDataSource(fs);
          final invitesRepo = InviteCodesRepositoryImpl(invitesDs);
          final verifyInvite = VerifyAdminInvite(invitesRepo);
          final consumeInvite = ConsumeAdminInvite(invitesRepo);

          // Access requests
          final accessDs = AccessRequestRemoteDataSource(fs);
          final accessRepo = AccessRequestRepositoryImpl(accessDs);
          final getMy = GetMyAccessRequest(accessRepo);
          final submit = SubmitAccessRequest(accessRepo);

          // Storage
          final storage = CloudinaryStorageService();

          // Auth para registro directo
          final auth = FirebaseAuth.instance;
          final remoteAuth = RemoteAuthDataSource(auth, fs);
          final authRepo = AuthRepositoryImpl(remoteAuth);
          final registerUC = RegisterUser(authRepo);

          return MaterialPageRoute(
            settings: settings,
            builder:
                (_) => BlocProvider(
                  create:
                      (_) => AccessRequestCubit(
                        getMy: getMy,
                        submitUseCase: submit,
                        storage: storage,
                        auth: auth,
                        verifyInvite: verifyInvite,
                        registerUser: registerUC,
                        consumeInvite: consumeInvite,
                      ),
                  child: const AccessRequestPage(),
                ),
          );
        }

      case register:
        final role = settings.arguments as String;
        return MaterialPageRoute(
          settings: settings,
          builder: (_) => RegisterPage(role: role),
        );

      case AuthRoutes.login:
        return MaterialPageRoute(
          settings: settings,
          builder: (_) => const login_page.LoginPage(),
        );

      case AuthRoutes.emailVerification:
        {
          final args =
              settings.arguments as EmailVerificationPageArguments?;
          final auth = FirebaseAuth.instance;
          final firestore = FirebaseFirestore.instance;
          final remoteAuth = RemoteAuthDataSource(auth, firestore);
          final authRepo = AuthRepositoryImpl(remoteAuth);
          final sendEmailVerification = SendEmailVerification(authRepo);
          final reloadUser = ReloadUser(authRepo);
          final updateGrace = UpdateVerificationGrace(authRepo);

          return MaterialPageRoute(
            settings: settings,
            builder: (context) {
              final graceStorage =
                  RepositoryProvider.of<VerificationGraceStorage>(
                context,
                listen: false,
              );
              return BlocProvider(
                create: (_) => EmailVerificationCubit(
                  sendEmailVerification: sendEmailVerification,
                  reloadUser: reloadUser,
                  auth: auth,
                  graceStorage: graceStorage,
                  updateGrace: updateGrace,
                ),
                child: EmailVerificationPage(user: args?.user),
              );
            },
          );
        }

      case AuthRoutes.forgotPassword:
        {
          final auth = FirebaseAuth.instance;

          // Proveedores desacoplados
          final EmailResetProvider emailProv = FirebaseEmailResetProvider(auth);
          final OtpProvider otpProv = FirebaseOtpProvider(auth);

          final ds = PasswordResetRemoteDataSource(
            emailProvider: emailProv,
            otpProvider: otpProv,
          );

          final repo = PasswordResetRepositoryImpl(ds);
          final sendEmail = SendPasswordResetEmail(repo);
          final startPhone = StartPhoneVerification(repo);
          final lookup = RecoveryLookup(repo);
          final verifyOtp = VerifyOtpGetProof(repo);
          final finishWithProof = FinishPasswordResetWithProof(repo);

          return MaterialPageRoute(
            settings: settings,
            builder:
                (_) => BlocProvider(
                  create:
                      (_) => PasswordResetCubit(
                        sendPasswordResetEmail: sendEmail,
                        startPhoneVerification: startPhone,
                        recoveryLookup: lookup,
                        verifyOtpGetProof: verifyOtp,
                        finishWithProof: finishWithProof,
                      ),
                  child: const forgot.ForgotPasswordPage(),
                ),
          );
        }

      default:
        return MaterialPageRoute(
          settings: const RouteSettings(name: welcome),
          builder: (_) => const WelcomePage(),
        );
    }
  }
}

--------------- END FILE: modules/features/auth/auth_routes.dart ---------------

Dentro de /data:

Dentro de /datasources:

 FILE: modules/features/auth/data/datasources/access_request_remote_datasource.dart 
// modules/features/auth/data/datasources/access_request_remote_datasource.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/access_request_model.dart';

class AccessRequestRemoteDataSource {
  final FirebaseFirestore firestore;
  AccessRequestRemoteDataSource(this.firestore);

  CollectionReference<Map<String,dynamic>> get _col =>
      firestore.collection('admin_access_requests');

  Future<AccessRequestModel?> getMy(String uid) async {
    final doc = await _col.doc(uid).get();
    if (!doc.exists) return null;
    return AccessRequestModel.fromDoc(doc);
  }

  Future<void> submit(AccessRequestModel data) async {
    final reqRef = _col.doc(data.uid);
    final invRef = firestore.collection('admin_invites').doc(data.inviteCode);

    await firestore.runTransaction((tx) async {
      // 1) Validar/consumir invite
      final invSnap = await tx.get(invRef);
      if (!invSnap.exists) throw Exception('CÃ³digo invÃ¡lido');

      final d = invSnap.data()!;
      final isActive = (d['isActive'] ?? false) == true;
      if (!isActive) throw Exception('CÃ³digo ya usado/inactivo');

      // 2) Crear/actualizar la solicitud
      final now = FieldValue.serverTimestamp();
      final map = data.toMapForCreate();
      map['updatedAt'] = now;

      final existing = await tx.get(reqRef);
      if (!existing.exists) {
        tx.set(reqRef, map, SetOptions(merge: false));
      } else {
        tx.update(reqRef, data.toMapForUpdatePending());
      }

      // 3) Marcar invite como usado
      tx.update(invRef, {
        'isActive': false,
        'usedCount': (d['usedCount'] ?? 0) + 1,
        'usedBy': data.uid,
        'usedAt': now,
      });
    });
  }
}

 END FILE: modules/features/auth/data/datasources/access_request_remote_datasource.dart 

 FILE: modules/features/auth/data/datasources/invite_codes_remote_datasource.dart 
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/invite_code_model.dart';

class InviteCodesRemoteDataSource {
  final FirebaseFirestore firestore;
  InviteCodesRemoteDataSource(this.firestore);

  Future<InviteCodeModel> verify(String code) async {
    final ref = firestore.collection('admin_invites').doc(code);
    final snap = await ref.get();
    if (!snap.exists) throw Exception('CÃ³digo invÃ¡lido');
    return InviteCodeModel.fromDoc(code, snap);
  }

  Future<void> consume(String code, String uid) async {
    final ref = firestore.collection('admin_invites').doc(code);
    await firestore.runTransaction((tx) async {
      final snap = await tx.get(ref);
      if (!snap.exists) throw Exception('CÃ³digo invÃ¡lido');

      final data = snap.data()!;
      final isActive = (data['isActive'] ?? data['active'] ?? true) == true && data['usedAt'] == null;
      if (!isActive) throw Exception('CÃ³digo ya usado/inactivo');

      tx.update(ref, {
        'isActive': false,
        'usedBy': uid,
        'usedAt': FieldValue.serverTimestamp(),
        'usedCount': (data['usedCount'] ?? 0) + 1,
      });
    });
  }
}

 END FILE: modules/features/auth/data/datasources/invite_codes_remote_datasource.dart 

 FILE: modules/features/auth/data/datasources/password_reset_remote_datasource.dart 
// lib/modules/features/auth/data/datasources/password_reset_remote_datasource.dart
import 'package:cloud_functions/cloud_functions.dart';
import '../../../../core/services/functions/functions_client.dart';
import '../../../../core/services/otp/otp_provider.dart';
import '../../../../core/services/email/email_reset_provider.dart';

class RecoveryLookupResult {
  final List<String> channels;
  final String? maskedEmail;
  final String? maskedPhone;
  final String? phoneE164;

  const RecoveryLookupResult({
    required this.channels,
    this.maskedEmail,
    this.maskedPhone,
    this.phoneE164,
  });

  factory RecoveryLookupResult.fromMap(Map<String, dynamic> m) {
    return RecoveryLookupResult(
      channels: (m['channels'] as List?)?.cast<String>() ?? const [],
      maskedEmail: (m['maskedEmail'] as String?)?.trim(),
      maskedPhone: (m['maskedPhone'] as String?)?.trim(),
      phoneE164: (m['phoneE164'] as String?)?.trim(),
    );
  }
}

class PasswordResetRemoteDataSource {
  final EmailResetProvider _emailProvider;
  final OtpProvider _otpProvider;
  final FunctionsClient _fx;

  PasswordResetRemoteDataSource({
    required EmailResetProvider emailProvider,
    required OtpProvider otpProvider,
    FirebaseFunctions? functions,
  }) : _emailProvider = emailProvider,
       _otpProvider = otpProvider,
       _fx = FunctionsClient(functions: functions, region: 'us-central1');

  // ----------------- Email -----------------
  Future<void> sendPasswordResetEmail(String email) {
    return _emailProvider.sendPasswordResetEmail(email.trim());
  }

  // ----------------- Phone (OTP) -----------------
  Future<String> startPhoneVerification(String phoneNumber) {
    return _otpProvider.startPhoneVerification(phoneNumber.trim());
  }

  Future<String> verifyOtpAndGetAuthProof({
    required String verificationId,
    required String smsCode,
  }) {
    return _otpProvider.signInAndGetAuthProof(
      verificationId: verificationId,
      smsCode: smsCode,
    );
  }

  // ----------------- Lookup â channels -----------------
  Future<RecoveryLookupResult> recoveryLookup(String identifier) async {
    final data =
        await _fx.call(
              'recoveryLookup',
              data: {'identifier': identifier.trim()},
            )
            as Map<String, dynamic>;
    return RecoveryLookupResult.fromMap(data);
  }

  // ----------------- Finalizar reset con proof (servidor) -----------------
  Future<void> finishPasswordResetWithProof({
    required String authProof, // idToken del proveedor (OTP verificado)
    required String newPassword,
    required String identifier,
  }) async {
    await _fx.call(
      'finishPasswordReset',
      data: {
        'authProvider': _otpProvider.providerId,
        'idToken': authProof,
        'newPassword': newPassword.trim(),
        'identifier': identifier.trim(),
      },
    );
  }
}

 END FILE: modules/features/auth/data/datasources/password_reset_remote_datasource.dart 

--- FILE: modules/features/auth/data/datasources/remote_auth_datasource.dart ---
// DataSource con soporte de identificador (cÃ©dula o email) + perfil Firestore.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/utils/validation/validators.dart';
import '../../domain/entities/user_entity.dart';
import '../models/user_model.dart';

class RemoteAuthDataSource {
  final FirebaseAuth _auth;
  final FirebaseFirestore _db;

  static const _usersCol = 'users';
  static const _cedulasCol = 'cedulas';

  RemoteAuthDataSource(this._auth, this._db);

  // --- Helpers ---

  bool _looksLikeEmail(String input) =>
      RegExp(r'^[\w\.\-]+@[\w\.\-]+\.\w{2,}$').hasMatch(input);

  Future<String> _resolveEmailFromIdentifier(String identifier) async {
    final id = identifier.trim();
    if (_looksLikeEmail(id)) return id.toLowerCase();

    // Si es cÃ©dula (solo dÃ­gitos), intenta resolver desde Firestore
    final isCedula = int.tryParse(id) != null;
    if (isCedula) {
      try {
        final cedulaDoc = await _db.collection(_cedulasCol).doc(id).get();
        if (cedulaDoc.exists) {
          final data = cedulaDoc.data()!;
          final email = (data['email'] as String?)?.trim();
          if (email != null && email.isNotEmpty) return email.toLowerCase();

          final uid = data['uid'] as String?;
          if (uid != null) {
            final userDoc = await _db.collection(_usersCol).doc(uid).get();
            if (userDoc.exists) {
              final uEmail = (userDoc.data()?['email'] as String?)?.trim();
              if (uEmail != null && uEmail.isNotEmpty) return uEmail.toLowerCase();
            }
          }
        }
      } catch (_) {
        // Ignorado: si las reglas no permiten leer, seguimos con el fallback
      }

      // Fallback legacy (si usabas mapeo a fake domain)
      return '$id@$fakeEmailDomain'.toLowerCase();
    }

    // Si no es email ni cÃ©dula clara, lo tratamos como email "tal cual"
    return id.toLowerCase();
  }

  Future<UserModel> _mapAuthUserToModel(User user) async {
    // Intenta leer el perfil de Firestore: users/{uid}
    final doc = await _db.collection(_usersCol).doc(user.uid).get();

    if (doc.exists) {
      final d = doc.data()!;
      final timestamp = d['verificationGraceDeadline'];
      DateTime? graceDeadline;
      if (timestamp is Timestamp) {
        graceDeadline = timestamp.toDate();
      }
      final storedEmail = (d['email'] as String?)?.trim();
      final effectiveEmail = storedEmail?.isNotEmpty == true ? storedEmail : user.email;
      final requiresVerification = requiresEmailVerification(effectiveEmail);
      return UserModel(
        uid: user.uid,
        name: (d['name'] as String?) ?? '',
        lastName: (d['lastName'] as String?) ?? '',
        phone: (d['phone'] as String?) ?? '',
        cedula: (d['cedula'] as String?) ?? '',
        email: effectiveEmail,
        address: (d['address'] as String?) ?? '',
        role: (d['role'] as String?) ?? '',
        isVerified: requiresVerification ? user.emailVerified : true,
        graceDeadline: graceDeadline,
        graceUsed: (d['verificationGraceUsed'] as bool?) ?? false,
      );
    }

    // Si no hay doc aÃºn, devuelve info mÃ­nima desde Auth
    final effectiveEmail = user.email;
    final requiresVerification = requiresEmailVerification(effectiveEmail);
    return UserModel(
      uid: user.uid,
      name: user.displayName ?? '',
      lastName: '',
      phone: '',
      cedula: '',
      email: effectiveEmail,
      address: '',
      role: '',
      isVerified: requiresVerification ? user.emailVerified : true,
      graceDeadline: null,
      graceUsed: false,
    );
  }

  // --- API principal ---

  /// Login con identificador (cÃ©dula o email) + password.
  Future<UserEntity> login(String identifier, String password) async {
    final email = await _resolveEmailFromIdentifier(identifier);
    final cred = await _auth.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
    final u = cred.user!;
    final model = await _mapAuthUserToModel(u);
    return model;
  }

  /// Registro en Auth y persistencia del perfil en Firestore.
  Future<void> register(UserModel user, String password, String role) async {
    if (user.email == null || user.email!.isEmpty) {
      throw Exception('Email requerido para registro');
    }
    final cred = await _auth.createUserWithEmailAndPassword(
      email: user.email!.trim(),
      password: password,
    );

    final uid = cred.user!.uid;
    await cred.user!.updateDisplayName(
      '${user.name.trim()} ${user.lastName.trim()}'.trim(),
    );

    await _db.collection(_usersCol).doc(uid).set({
      'email': user.email,
      'name': user.name,
      'lastName': user.lastName,
      'phone': user.phone,
      'cedula': user.cedula,
      'address': user.address,
      'role': role,
      'createdAt': FieldValue.serverTimestamp(),
      'verificationGraceUsed': false,
    });
  }

  Future<void> sendEmailVerification() async {
    final u = _auth.currentUser;
    if (u == null) throw Exception('No hay sesiÃ³n');
    await u.sendEmailVerification();
  }

  Future<void> signOut() => _auth.signOut();

  Future<void> reloadUser() async {
    final u = _auth.currentUser;
    if (u != null) await u.reload();
  }

  Future<void> resetPassword(String email) =>
      _auth.sendPasswordResetEmail(email: email.trim());

  User? get currentUser => _auth.currentUser;

  Future<void> updateVerificationGrace({
    DateTime? deadline,
    bool? used,
  }) async {
    final u = _auth.currentUser;
    if (u == null) throw Exception('No hay sesiÃ³n');
    final data = <String, dynamic>{
      'verificationGraceUpdatedAt': FieldValue.serverTimestamp(),
    };
    if (deadline != null) {
      data['verificationGraceDeadline'] = Timestamp.fromDate(deadline);
    } else {
      data['verificationGraceDeadline'] = FieldValue.delete();
    }
    if (used != null) data['verificationGraceUsed'] = used;
    await _db.collection(_usersCol).doc(u.uid).set(data, SetOptions(merge: true));
  }
}

- END FILE: modules/features/auth/data/datasources/remote_auth_datasource.dart -

Dentro de /models:

------- FILE: modules/features/auth/data/models/access_request_model.dart ------
// modules/features/auth/data/models/access_request_model.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/access_request.dart';

class AttachmentModel extends AttachmentEntity {
  const AttachmentModel({
    required super.url,
    required super.fileName,
    required super.contentType,
    required super.size,
    required super.provider,
  });

  Map<String, dynamic> toMap() => {
    'url': url,
    'fileName': fileName,
    'contentType': contentType,
    'size': size,
    'provider': provider,
  };

  factory AttachmentModel.fromMap(Map<String, dynamic> m) => AttachmentModel(
    url: (m['url'] ?? '') as String,
    fileName: (m['fileName'] ?? '') as String,
    contentType: (m['contentType'] ?? 'application/octet-stream') as String,
    size: (m['size'] ?? 0) as int,
    provider: (m['provider'] ?? '') as String,
  );
}

class AccessRequestModel extends AccessRequestEntity {
  const AccessRequestModel({
    required super.uid,
    required super.name,
    required super.idNumber,
    required super.position,
    required super.motive,
    required super.status,
    required super.attachments,
    required super.inviteCode,
    super.createdAt,
    super.updatedAt,
    super.reviewedBy,
    super.reviewedAt,
    super.decisionNote,
  });

  Map<String, dynamic> toMapForCreate() => {
    'uid': uid,
    'name': name,
    'idNumber': idNumber,
    'position': position,
    'motive': motive,
    'status': 'pending',
    'attachments':
        attachments.map((a) => (a as AttachmentModel).toMap()).toList(),
    'inviteCode': inviteCode, // â guarda
    'createdAt': FieldValue.serverTimestamp(),
    'updatedAt': FieldValue.serverTimestamp(),
  };

  Map<String, dynamic> toMapForUpdatePending() => {
    'name': name,
    'idNumber': idNumber,
    'position': position,
    'motive': motive,
    'attachments':
        attachments.map((a) => (a as AttachmentModel).toMap()).toList(),
    'updatedAt': FieldValue.serverTimestamp(),
  };

  static AccessRequestModel fromDoc(
    DocumentSnapshot<Map<String, dynamic>> doc,
  ) {
    final d = doc.data() ?? {};
    AccessRequestStatus st;
    switch ((d['status'] ?? 'pending') as String) {
      case 'approved':
        st = AccessRequestStatus.approved;
        break;
      case 'rejected':
        st = AccessRequestStatus.rejected;
        break;
      default:
        st = AccessRequestStatus.pending;
    }

    DateTime? toDate(v) => v is Timestamp ? v.toDate() : null;

    final atts =
        ((d['attachments'] ?? []) as List)
            .map((e) => AttachmentModel.fromMap(Map<String, dynamic>.from(e)))
            .toList();

    return AccessRequestModel(
      uid: (d['uid'] ?? doc.id) as String,
      name: (d['name'] ?? '') as String,
      idNumber: (d['idNumber'] ?? '') as String,
      position: (d['position'] ?? '') as String,
      motive: (d['motive'] ?? '') as String,
      status: st,
      attachments: atts,
      inviteCode: (d['inviteCode'] ?? '') as String,
      createdAt: toDate(d['createdAt']),
      updatedAt: toDate(d['updatedAt']),
      reviewedBy: d['reviewedBy'] as String?,
      reviewedAt: toDate(d['reviewedAt']),
      decisionNote: d['decisionNote'] as String?,
    );
  }
}

----- END FILE: modules/features/auth/data/models/access_request_model.dart ----

-------- FILE: modules/features/auth/data/models/invite_code_model.dart --------
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/invite_code.dart';

class InviteCodeModel extends InviteCode {
  const InviteCodeModel({
    required super.code,
    required super.role,
    required super.isActive,
    super.expiresAt,
  });

  static DateTime? _toDate(dynamic v) {
    if (v is Timestamp) return v.toDate();
    if (v is int) return DateTime.fromMillisecondsSinceEpoch(v);
    if (v is String) return DateTime.tryParse(v);
    return null;
  }

  factory InviteCodeModel.fromDoc(
    String code,
    DocumentSnapshot<Map<String, dynamic>> doc,
  ) {
    final d = doc.data() ?? {};

    final usedAt = d['usedAt'];
    final rawIsActive = d['isActive'];
    final rawActive   = d['active']; // fallback por si el documento usa esta clave

    // Regla: activo si:
    // - isActive == true, o
    // - active == true, o
    // - ninguna bandera presente y no tiene usedAt
    final isActive = (rawIsActive is bool && rawIsActive == true)
        || (rawActive is bool && rawActive == true)
        || (rawIsActive == null && rawActive == null && usedAt == null);

    return InviteCodeModel(
      code: code,
      role: (d['role'] ?? 'admin') as String,
      isActive: isActive,
      expiresAt: _toDate(d['expiresAt']),
    );
  }
}

------ END FILE: modules/features/auth/data/models/invite_code_model.dart ------

------------ FILE: modules/features/auth/data/models/user_model.dart -----------
import '../../domain/entities/user_entity.dart';

class UserModel extends UserEntity {
  const UserModel({
    required super.uid,
    required super.name,
    required super.lastName,
    required super.phone,
    required super.cedula,
    super.email,
    required super.address,
    required super.role,
    required super.isVerified,
    super.graceDeadline,
    super.graceUsed,
  });

  Map<String, dynamic> toMap() {
    return {
      'uid': uid,
      'name': name,
      'lastName': lastName,
      'phone': phone,
      'cedula': cedula,
      'email': email,
      'address': address,
      'role': role,
    };
  }

  factory UserModel.fromEntity(UserEntity entity) {
    return UserModel(
      uid: entity.uid,
      name: entity.name,
      lastName: entity.lastName,
      phone: entity.phone,
      cedula: entity.cedula,
      email: entity.email,
      address: entity.address,
      role: entity.role,
      isVerified: entity.isVerified,
      graceDeadline: entity.graceDeadline,
      graceUsed: entity.graceUsed,
    );
  }
}

---------- END FILE: modules/features/auth/data/models/user_model.dart ---------

Dentro de /repositories:

 FILE: modules/features/auth/data/repositories/access_request_repository_impl.dart 
import '../../domain/entities/access_request.dart';
import '../../domain/repositories/access_request_repository.dart';
import '../datasources/access_request_remote_datasource.dart';
import '../models/access_request_model.dart';

class AccessRequestRepositoryImpl implements AccessRequestRepository {
  final AccessRequestRemoteDataSource remote;
  AccessRequestRepositoryImpl(this.remote);

  @override
  Future<AccessRequestEntity?> getMy(String uid) => remote.getMy(uid);

  @override
  Future<void> submit(AccessRequestEntity data) {
    final model = AccessRequestModel(
      uid: data.uid,
      name: data.name,
      idNumber: data.idNumber,
      position: data.position,
      motive: data.motive,
      status: data.status,
      attachments: data.attachments,
      inviteCode: data.inviteCode,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt,
    );
    return remote.submit(model);
  }
}

 END FILE: modules/features/auth/data/repositories/access_request_repository_impl.dart 

---- FILE: modules/features/auth/data/repositories/auth_repository_impl.dart ---
// modules/features/auth/data/repositories/auth_repository_impl.dart
import '../../domain/entities/user_entity.dart';
import '../../domain/repositories/auth_repository.dart';
import '../datasources/remote_auth_datasource.dart';
import '../models/user_model.dart';

class AuthRepositoryImpl implements AuthRepository {
  final RemoteAuthDataSource remote;
  AuthRepositoryImpl(this.remote);

  @override
  Future<void> register(UserEntity user, String password, String role) {
    return remote.register(UserModel.fromEntity(user), password, role);
  }

  @override
  Future<UserEntity> login(String identifier, String password) {
    // Delegamos toda la resoluciÃ³n (correo/documento) al DataSource.
    return remote.login(identifier, password);
  }

  @override
  Future<void> sendEmailVerification() => remote.sendEmailVerification();

  @override
  Future<void> signOut() => remote.signOut();

  @override
  Future<void> reloadUser() => remote.reloadUser();

  @override
  Future<void> updateVerificationGrace({DateTime? deadline, bool? used}) {
    return remote.updateVerificationGrace(deadline: deadline, used: used);
  }
}

-- END FILE: modules/features/auth/data/repositories/auth_repository_impl.dart -

 FILE: modules/features/auth/data/repositories/invite_codes_repository_impl.dart 
import '../../domain/entities/invite_code.dart';
import '../../domain/repositories/invite_codes_repository.dart';
import '../datasources/invite_codes_remote_datasource.dart';

class InviteCodesRepositoryImpl implements InviteCodesRepository {
  final InviteCodesRemoteDataSource remote;
  InviteCodesRepositoryImpl(this.remote);

  @override
  Future<InviteCode> verify(String code) => remote.verify(code);

  @override
  Future<void> consume(String code, String uid) => remote.consume(code, uid);
}

 END FILE: modules/features/auth/data/repositories/invite_codes_repository_impl.dart 

 FILE: modules/features/auth/data/repositories/password_reset_repository_impl.dart 
// lib/modules/features/auth/data/repositories/password_reset_repository_impl.dart
import '../../domain/repositories/password_reset_repository.dart';
import '../datasources/password_reset_remote_datasource.dart';

class PasswordResetRepositoryImpl implements PasswordResetRepository {
  final PasswordResetRemoteDataSource remote;
  PasswordResetRepositoryImpl(this.remote);

  @override
  Future<void> sendPasswordResetEmail(String email) =>
      remote.sendPasswordResetEmail(email);

  @override
  Future<String> startPhoneVerification(String phoneNumber) =>
      remote.startPhoneVerification(phoneNumber);

  @override
  Future<RecoveryLookupResult> recoveryLookup(String identifier) =>
      remote.recoveryLookup(identifier);

  @override
  Future<String> verifyOtpAndGetAuthProof({
    required String verificationId,
    required String smsCode,
  }) => remote.verifyOtpAndGetAuthProof(
    verificationId: verificationId,
    smsCode: smsCode,
  );

  @override
  Future<void> finishPasswordResetWithProof({
    required String authProof,
    required String newPassword,
    required String identifier,
  }) => remote.finishPasswordResetWithProof(
    authProof: authProof,
    newPassword: newPassword,
    identifier: identifier,
  );
}

 END FILE: modules/features/auth/data/repositories/password_reset_repository_impl.dart 

Dentro de /domain:

-------------- FILE: modules/features/auth/domain/role_utils.dart --------------
bool isSuperRole(String? role) {
  final value = role?.toLowerCase().trim();
  if (value == null || value.isEmpty) return false;
  return value == 'super';
}

bool isAdminRole(String? role) {
  final value = role?.toLowerCase().trim();
  if (value == null || value.isEmpty) return false;
  return value == 'admin' || isSuperRole(value);
}

------------ END FILE: modules/features/auth/domain/role_utils.dart ------------

Dentro de /entities:

-------- FILE: modules/features/auth/domain/entities/access_request.dart -------
// modules/features/auth/domain/entities/access_request.dart
class AttachmentEntity {
  final String url;
  final String fileName;
  final String contentType;
  final int size;
  final String provider;

  const AttachmentEntity({
    required this.url,
    required this.fileName,
    required this.contentType,
    required this.size,
    required this.provider,
  });
}

enum AccessRequestStatus { pending, approved, rejected }

class AccessRequestEntity {
  final String uid;
  final String name;
  final String idNumber;   // cÃ©dula/RUC/pasaporte
  final String position;   // cargo
  final String motive;
  final AccessRequestStatus status;
  final List<AttachmentEntity> attachments;
  final String inviteCode; // â nuevo campo

  final DateTime? createdAt;
  final DateTime? updatedAt;
  final String? reviewedBy;
  final DateTime? reviewedAt;
  final String? decisionNote;

  const AccessRequestEntity({
    required this.uid,
    required this.name,
    required this.idNumber,
    required this.position,
    required this.motive,
    required this.status,
    required this.attachments,
    required this.inviteCode,
    this.createdAt,
    this.updatedAt,
    this.reviewedBy,
    this.reviewedAt,
    this.decisionNote,
  });
}

------ END FILE: modules/features/auth/domain/entities/access_request.dart -----

--------- FILE: modules/features/auth/domain/entities/invite_code.dart ---------
class InviteCode {
  final String code;
  final String role;     // ej. 'admin'
  final bool isActive;
  final DateTime? expiresAt;

  const InviteCode({
    required this.code,
    required this.role,
    required this.isActive,
    this.expiresAt,
  });
}

------- END FILE: modules/features/auth/domain/entities/invite_code.dart -------

--------- FILE: modules/features/auth/domain/entities/user_entity.dart ---------
class UserEntity {
  final String uid;
  final String name;
  final String lastName;
  final String phone;
  final String cedula;
  final String? email;
  final String address;

  /// rol del usuario (emprendedora, cliente, admin, super)
  final String role;
  /// Campo para verificaciÃ³n de correo
  final bool isVerified;
  final DateTime? graceDeadline;
  final bool graceUsed;

  const UserEntity({
    required this.uid,
    required this.name,
    required this.lastName,
    required this.phone,
    required this.cedula,
    this.email,
    required this.address,
    this.role = '',
    this.isVerified = false,
    this.graceDeadline,
    this.graceUsed = false,
  });
}

------- END FILE: modules/features/auth/domain/entities/user_entity.dart -------

Dentro de /repositories:

 FILE: modules/features/auth/domain/repositories/access_request_repository.dart 
import '../entities/access_request.dart';

abstract class AccessRequestRepository {
  Future<AccessRequestEntity?> getMy(String uid);
  Future<void> submit(AccessRequestEntity data);
}

 END FILE: modules/features/auth/domain/repositories/access_request_repository.dart 

----- FILE: modules/features/auth/domain/repositories/auth_repository.dart -----
// modules/features/auth/domain/repositories/auth_repository.dart
import '../entities/user_entity.dart';

abstract class AuthRepository {
  /// Login con identificador flexible (correo o documento).
  Future<UserEntity> login(String identifier, String password);

  Future<void> register(UserEntity user, String password, String role);

  // aÃ±adidos
  Future<void> sendEmailVerification();
  Future<void> signOut();
  Future<void> reloadUser(); // para refrescar emailVerified
  Future<void> updateVerificationGrace({DateTime? deadline, bool? used});
}

--- END FILE: modules/features/auth/domain/repositories/auth_repository.dart ---

- FILE: modules/features/auth/domain/repositories/invite_codes_repository.dart -
import '../entities/invite_code.dart';

abstract class InviteCodesRepository {
  Future<InviteCode> verify(String code); // solo validaciÃ³n/lectura
  Future<void> consume(String code, String uid); // marcar usado de forma atÃ³mica
}

 END FILE: modules/features/auth/domain/repositories/invite_codes_repository.dart 

 FILE: modules/features/auth/domain/repositories/password_reset_repository.dart 
// lib/modules/features/auth/domain/repositories/password_reset_repository.dart
import '../../data/datasources/password_reset_remote_datasource.dart';

abstract class PasswordResetRepository {
  Future<void> sendPasswordResetEmail(String email);
  Future<String> startPhoneVerification(String phoneNumber);

  // SeparaciÃ³n estricta de pasos (activo)
  Future<String> verifyOtpAndGetAuthProof({
    required String verificationId,
    required String smsCode,
  });

  Future<void> finishPasswordResetWithProof({
    required String authProof,
    required String newPassword,
    required String identifier,
  });

  Future<RecoveryLookupResult> recoveryLookup(String identifier);
}

 END FILE: modules/features/auth/domain/repositories/password_reset_repository.dart 

Dentro de /usecases:

----- FILE: modules/features/auth/domain/usecases/consume_admin_invite.dart ----
// modules/features/auth/domain/usecases/consume_admin_invite.dart
import '../repositories/invite_codes_repository.dart';

class ConsumeAdminInvite {
  final InviteCodesRepository repo;
  ConsumeAdminInvite(this.repo);
  
  Future<void> call({required String code, required String uid}) {
    return repo.consume(code, uid);
  }
}
--- END FILE: modules/features/auth/domain/usecases/consume_admin_invite.dart --

 FILE: modules/features/auth/domain/usecases/finish_password_reset_with_proof.dart 
// lib/modules/features/auth/domain/usecases/finish_password_reset_with_proof.dart
import '../repositories/password_reset_repository.dart';

class FinishPasswordResetWithProof {
  final PasswordResetRepository repo;
  FinishPasswordResetWithProof(this.repo);

  Future<void> call({
    required String authProof,
    required String newPassword,
    required String identifier,
  }) {
    return repo.finishPasswordResetWithProof(
      authProof: authProof,
      newPassword: newPassword.trim(),
      identifier: identifier.trim(),
    );
  }
}

 END FILE: modules/features/auth/domain/usecases/finish_password_reset_with_proof.dart 

---- FILE: modules/features/auth/domain/usecases/get_my_access_request.dart ----
import '../entities/access_request.dart';
import '../repositories/access_request_repository.dart';

class GetMyAccessRequest {
  final AccessRequestRepository repo;
  GetMyAccessRequest(this.repo);

  Future<AccessRequestEntity?> call(String uid) => repo.getMy(uid);
}

-- END FILE: modules/features/auth/domain/usecases/get_my_access_request.dart --

------ FILE: modules/features/auth/domain/usecases/link_phone_number.dart ------
// lib/modules/features/auth/domain/usecases/link_phone_number.dart
import '../../../../core/services/phone_link/phone_link_provider.dart';

class LinkPhoneNumber {
  final PhoneLinkProvider provider;
  LinkPhoneNumber(this.provider);

  /// Paso 1: envÃ­a SMS y devuelve verificationId
  Future<String> start(String phoneE164) =>
      provider.startLinkVerification(phoneE164.trim());

  /// Paso 2: confirma y enlaza
  Future<void> confirm({
    required String verificationId,
    required String smsCode,
  }) => provider.linkWithSmsCode(
    verificationId: verificationId,
    smsCode: smsCode.trim(),
  );
}

---- END FILE: modules/features/auth/domain/usecases/link_phone_number.dart ----

---------- FILE: modules/features/auth/domain/usecases/login_user.dart ---------
// lib/modules/features/auth/domain/usecases/login_user.dart
import '../entities/user_entity.dart';
import '../repositories/auth_repository.dart';

class LoginUser {
  final AuthRepository repository;

  LoginUser(this.repository);

  /// Acepta correo o documento como `identifier`.
  Future<UserEntity> call(String identifier, String password) {
    return repository.login(identifier, password);
  }
}

-------- END FILE: modules/features/auth/domain/usecases/login_user.dart -------

------- FILE: modules/features/auth/domain/usecases/recovery_lookup.dart -------
import '../../data/datasources/password_reset_remote_datasource.dart';
import '../repositories/password_reset_repository.dart';

class RecoveryLookup {
  final PasswordResetRepository repo;
  RecoveryLookup(this.repo);

  Future<RecoveryLookupResult> call(String raw) {
    return repo.recoveryLookup(raw.trim());
  }
}

----- END FILE: modules/features/auth/domain/usecases/recovery_lookup.dart -----

-------- FILE: modules/features/auth/domain/usecases/register_user.dart --------
import '../entities/user_entity.dart';
import '../repositories/auth_repository.dart';

class RegisterUser {
  final AuthRepository repository;

  RegisterUser(this.repository);

  Future<void> call(UserEntity user, String password, String role) {
    return repository.register(user, password, role);
  }
}

------ END FILE: modules/features/auth/domain/usecases/register_user.dart ------

--------- FILE: modules/features/auth/domain/usecases/reload_user.dart ---------
// modules/features/auth/domain/usecases/reload_user.dart

import '../repositories/auth_repository.dart';

class ReloadUser {
  final AuthRepository repo;
  ReloadUser(this.repo);
  Future<void> call() => repo.reloadUser();
}

------- END FILE: modules/features/auth/domain/usecases/reload_user.dart -------

--- FILE: modules/features/auth/domain/usecases/send_email_verification.dart ---
// modules/features/auth/domain/usecases/send_email_verification.dart

import '../repositories/auth_repository.dart';

class SendEmailVerification {
  final AuthRepository repo;
  SendEmailVerification(this.repo);
  Future<void> call() => repo.sendEmailVerification();
}

- END FILE: modules/features/auth/domain/usecases/send_email_verification.dart -

-- FILE: modules/features/auth/domain/usecases/send_password_reset_email.dart --
import '../repositories/password_reset_repository.dart';
import '../../../../core/utils/validation/validators.dart';

class SendPasswordResetEmail {
  final PasswordResetRepository repo;
  SendPasswordResetEmail(this.repo);

  Future<void> call(String rawEmail) async {
    final email = rawEmail.trim().toLowerCase();
    if (isFakeEmail(email)) {
      throw Exception('Tu cuenta usa documento (cÃ©dula). Elige la opciÃ³n "CÃ©dula + telÃ©fono".');
    }
    await repo.sendPasswordResetEmail(email);
  }
}

 END FILE: modules/features/auth/domain/usecases/send_password_reset_email.dart 

----------- FILE: modules/features/auth/domain/usecases/sign_out.dart ----------
// modules/features/auth/domain/usecases/sign_out.dart

import '../repositories/auth_repository.dart';

class SignOut {
  final AuthRepository repo;
  SignOut(this.repo);
  Future<void> call() => repo.signOut();
}

--------- END FILE: modules/features/auth/domain/usecases/sign_out.dart --------

--- FILE: modules/features/auth/domain/usecases/start_phone_verification.dart --
import '../repositories/password_reset_repository.dart';

class StartPhoneVerification {
  final PasswordResetRepository repo;
  StartPhoneVerification(this.repo);

  Future<String> call(String phoneNumber) {
    return repo.startPhoneVerification(phoneNumber.trim());
  }
}

- END FILE: modules/features/auth/domain/usecases/start_phone_verification.dart 

---- FILE: modules/features/auth/domain/usecases/submit_access_request.dart ----
import '../entities/access_request.dart';
import '../repositories/access_request_repository.dart';

class SubmitAccessRequest {
  final AccessRequestRepository repo;
  SubmitAccessRequest(this.repo);

  Future<void> call(AccessRequestEntity data) => repo.submit(data);
}

-- END FILE: modules/features/auth/domain/usecases/submit_access_request.dart --

-- FILE: modules/features/auth/domain/usecases/update_verification_grace.dart --
import '../repositories/auth_repository.dart';

class UpdateVerificationGrace {
  final AuthRepository repo;
  UpdateVerificationGrace(this.repo);

  Future<void> call({DateTime? deadline, bool? used}) {
    return repo.updateVerificationGrace(deadline: deadline, used: used);
  }
}

 END FILE: modules/features/auth/domain/usecases/update_verification_grace.dart 

----- FILE: modules/features/auth/domain/usecases/verify_admin_invite.dart -----
import '../entities/invite_code.dart';
import '../repositories/invite_codes_repository.dart';

class VerifyAdminInvite {
  final InviteCodesRepository repo;
  VerifyAdminInvite(this.repo);

  Future<InviteCode> call(String raw) async {
    final code = raw.trim();
    if (code.length < 8) {
      throw Exception('CÃ³digo invÃ¡lido');
    }
    final invite = await repo.verify(code);
    if (!invite.isActive) throw Exception('CÃ³digo ya usado/inactivo');
    if (invite.expiresAt != null && invite.expiresAt!.isBefore(DateTime.now())) {
      throw Exception('CÃ³digo expirado');
    }
    return invite;
  }
}

--- END FILE: modules/features/auth/domain/usecases/verify_admin_invite.dart ---

----- FILE: modules/features/auth/domain/usecases/verify_otp_get_proof.dart ----
// lib/modules/features/auth/domain/usecases/verify_otp_get_proof.dart
import '../repositories/password_reset_repository.dart';

class VerifyOtpGetProof {
  final PasswordResetRepository repo;
  VerifyOtpGetProof(this.repo);

  Future<String> call({
    required String verificationId,
    required String smsCode,
  }) {
    return repo.verifyOtpAndGetAuthProof(
      verificationId: verificationId,
      smsCode: smsCode.trim(),
    );
  }
}

--- END FILE: modules/features/auth/domain/usecases/verify_otp_get_proof.dart --

Dentro de /presentation:

Dentro de /blocs:

--- FILE: modules/features/auth/presentation/blocs/access_request_cubit.dart ---
// modules/features/auth/presentation/blocs/access_request_cubit.dart
import 'dart:typed_data';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../../domain/usecases/verify_admin_invite.dart';
import '../../domain/entities/access_request.dart';
import '../../domain/usecases/get_my_access_request.dart';
import '../../domain/usecases/submit_access_request.dart';
import '../../../../core/services/storage/i_file_storage_service.dart';
import '../../../../core/config/storage_config.dart';

// Nuevos para crear cuenta y consumir el invite
import '../../domain/usecases/register_user.dart';
import '../../domain/usecases/consume_admin_invite.dart';
import '../../domain/entities/user_entity.dart';

class AccessRequestState {
  final bool loading;
  final AccessRequestEntity? current; // null si no existe
  final String? error;
  final String? inviteCode; // cÃ³digo validado
  final bool? inviteVerified; // gate abierto

  const AccessRequestState({
    this.loading = false,
    this.current,
    this.error,
    this.inviteCode,
    this.inviteVerified = false,
  });

  AccessRequestState copyWith({
    bool? loading,
    AccessRequestEntity? current,
    String? error,
    String? inviteCode,
    bool? inviteVerified,
  }) {
    return AccessRequestState(
      loading: loading ?? this.loading,
      current: current ?? this.current,
      error: error,
      inviteCode: inviteCode ?? this.inviteCode,
      inviteVerified: inviteVerified ?? this.inviteVerified,
    );
  }
}

class AccessRequestCubit extends Cubit<AccessRequestState> {
  final GetMyAccessRequest getMy;
  final SubmitAccessRequest submitUseCase;
  final IFileStorageService storage;
  final FirebaseAuth auth;
  final VerifyAdminInvite verifyInvite;

  // Nuevos
  final RegisterUser registerUser;
  final ConsumeAdminInvite consumeInvite;

  AccessRequestCubit({
    required this.getMy,
    required this.submitUseCase,
    required this.storage,
    required this.auth,
    required this.verifyInvite,
    required this.registerUser,
    required this.consumeInvite,
  }) : super(const AccessRequestState());

  String? get uid => auth.currentUser?.uid;

  void reset() {
    emit(const AccessRequestState());
  }

  Future<void> _ensureAnonymousAuth() async {
    if (auth.currentUser == null) {
      try {
        await auth.signInAnonymously();
      } on FirebaseAuthException catch (e) {
        if (e.code == 'admin-restricted-operation' || e.code == 'operation-not-allowed') {
          throw Exception('El inicio de sesiÃ³n anÃ³nimo estÃ¡ deshabilitado en Firebase Authentication.');
        }
        rethrow;
      }
    }
  }

  // Mantengo load() por compatibilidad con el antiguo flujo de "revisar estado"
  Future<void> load() async {
    emit(state.copyWith(loading: true, error: null));
    try {
      await _ensureAnonymousAuth();
      final me = auth.currentUser!;
      final req = await getMy(me.uid);
      emit(state.copyWith(loading: false, current: req));
    } catch (e) {
      emit(state.copyWith(loading: false, error: e.toString()));
    } finally {
      if (auth.currentUser?.isAnonymous == true) {
        try { await auth.signOut(); } catch (_) {}
      }
    }
  }

  Future<void> verifyInviteCode(String raw) async {
    emit(state.copyWith(loading: true, error: null));
    try {
      await _ensureAnonymousAuth();
      final invite = await verifyInvite(raw);
      emit(state.copyWith(
        loading: false,
        inviteCode: invite.code,
        inviteVerified: true,
        error: null,
      ));
    } catch (e) {
      emit(state.copyWith(
        loading: false,
        error: e.toString(),
        inviteCode: null,
        inviteVerified: false,
      ));
    } finally {
      if (auth.currentUser?.isAnonymous == true) {
        try { await auth.signOut(); } catch (_) {}
      }
    }
  }

  // Subida de adjuntos (queda disponible por si alguna vez se reutiliza en otro flujo),
  // pero para el gate self-service no la usamos.
  Future<AttachmentEntity> uploadAttachment({
    required Uint8List bytes,
    required String fileName,
    required String contentType,
  }) async {
    if (bytes.length > StorageConfig.maxFileBytes) {
      throw Exception('Archivo excede ${StorageConfig.maxFileBytes ~/ (1024 * 1024)} MB');
    }
    if (StorageConfig.allowedMime.isNotEmpty && !StorageConfig.allowedMime.contains(contentType)) {
      throw Exception('Tipo de archivo no permitido');
    }
    await _ensureAnonymousAuth();
    final me = auth.currentUser!;
    final targetFolder = 'admin/access_requests/${me.uid}/attachments';
    final up = await storage.uploadBytes(
      bytes: bytes,
      fileName: fileName,
      contentType: contentType,
      folder: targetFolder,
    );

    return AttachmentEntity(
      url: up.url,
      fileName: up.fileName,
      contentType: up.contentType,
      size: up.size,
      provider: up.provider,
    );
  }

  // Mantengo submit() por compatibilidad si decides conservar el flujo de revisiÃ³n manual,
  // pero con el gate self-service usarÃ¡s createAccount().
  Future<void> submit({
    required String name,
    required String idNumber,
    required String position,
    required String motive,
    required List<AttachmentEntity> attachments,
  }) async {
    if ((state.inviteVerified ?? false) == false || (state.inviteCode ?? '').isEmpty) {
      throw Exception('Debes verificar un cÃ³digo vÃ¡lido antes de enviar.');
    }

    await _ensureAnonymousAuth();
    final me = auth.currentUser;
    if (me == null) throw Exception('SesiÃ³n requerida');

    final entity = AccessRequestEntity(
      uid: me.uid,
      name: name.trim(),
      idNumber: idNumber.trim(),
      position: position.trim(),
      motive: motive.trim(),
      status: AccessRequestStatus.pending,
      attachments: attachments,
      inviteCode: state.inviteCode!,
    );

    await submitUseCase(entity);
    await load();
  }

  // Nuevo flujo: crear cuenta directamente y consumir el cÃ³digo
  Future<void> createAccount({
    required String name,
    required String idNumber,
    required String phone,
    required String? email,
    required String address,
    required String password,
    String roleFallback = 'admin',
  }) async {
    final code = state.inviteCode;
    if ((state.inviteVerified ?? false) == false || code == null || code.isEmpty) {
      throw Exception('Primero valida tu cÃ³digo de invitaciÃ³n.');
    }

    emit(state.copyWith(loading: true, error: null));
    try {
      // Revalidar invite rÃ¡pido
      final inv = await verifyInvite(code);
      final role = inv.role.isNotEmpty ? inv.role : roleFallback;

      final user = UserEntity(
        uid: '',
        name: name.trim(),
        lastName: '',
        phone: phone.trim(),
        cedula: idNumber.trim(),
        email: (email?.trim().isEmpty ?? true) ? null : email!.trim(),
        address: address.trim(),
        role: role,
      );

      await registerUser(user, password, role);

      final newUid = auth.currentUser?.uid;
      if (newUid == null) throw Exception('No se pudo obtener la sesiÃ³n.');
      await consumeInvite(code: code, uid: newUid);

      emit(state.copyWith(loading: false, error: null));
    } catch (e) {
      emit(state.copyWith(loading: false, error: e.toString()));
      rethrow;
    }
  }
}

- END FILE: modules/features/auth/presentation/blocs/access_request_cubit.dart -

- FILE: modules/features/auth/presentation/blocs/email_verification_cubit.dart -
import 'dart:async';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/services/storage/verification_grace_storage.dart';
import '../../../../core/utils/validation/validators.dart';
import '../../domain/usecases/reload_user.dart';
import '../../domain/usecases/send_email_verification.dart';
import '../../domain/usecases/update_verification_grace.dart';

class EmailVerificationState {
  final bool initializing;
  final bool sending;
  final bool checking;
  final bool continuing;
  final bool emailSent;
  final bool verified;
  final String? error;
  final String? email;
  final String? userId;
  final int resendSeconds;
  final DateTime? graceDeadline;
  final bool graceUsed;

  const EmailVerificationState({
    this.initializing = true,
    this.sending = false,
    this.checking = false,
    this.continuing = false,
    this.emailSent = false,
    this.verified = false,
    this.error,
    this.email,
    this.userId,
    this.resendSeconds = 0,
    this.graceDeadline,
    this.graceUsed = false,
  });

  EmailVerificationState copyWith({
    bool? initializing,
    bool? sending,
    bool? checking,
    bool? continuing,
    bool? emailSent,
    bool? verified,
    String? error,
    String? email,
    String? userId,
    int? resendSeconds,
    DateTime? graceDeadline,
    bool? graceUsed,
  }) {
    return EmailVerificationState(
      initializing: initializing ?? this.initializing,
      sending: sending ?? this.sending,
      checking: checking ?? this.checking,
      continuing: continuing ?? this.continuing,
      emailSent: emailSent ?? this.emailSent,
      verified: verified ?? this.verified,
      error: error,
      email: email ?? this.email,
      userId: userId ?? this.userId,
      resendSeconds: resendSeconds ?? this.resendSeconds,
      graceDeadline: graceDeadline ?? this.graceDeadline,
      graceUsed: graceUsed ?? this.graceUsed,
    );
  }

  bool get canResendEmail {
    if (sending) return false;
    return resendSeconds <= 0;
  }

  Duration? get resendWait {
    if (resendSeconds <= 0) return null;
    return Duration(seconds: resendSeconds);
  }

  bool get hasActiveGrace {
    final deadline = graceDeadline;
    if (deadline == null) return false;
    return deadline.isAfter(DateTime.now());
  }

  Duration? get graceRemaining {
    final deadline = graceDeadline;
    if (deadline == null) return null;
    final remaining = deadline.difference(DateTime.now());
    return remaining.isNegative ? null : remaining;
  }

  bool get canRequestGrace => !graceUsed;
}

class EmailVerificationCubit extends Cubit<EmailVerificationState> {
  EmailVerificationCubit({
    required SendEmailVerification sendEmailVerification,
    required ReloadUser reloadUser,
    required FirebaseAuth auth,
    required VerificationGraceStorage graceStorage,
    required UpdateVerificationGrace updateGrace,
  })  : _sendEmailVerification = sendEmailVerification,
        _reloadUser = reloadUser,
        _auth = auth,
        _graceStorage = graceStorage,
        _updateGrace = updateGrace,
        super(const EmailVerificationState());

  static const graceDuration = Duration(days: 7);
  static const resendCooldown = Duration(seconds: 45);

  final SendEmailVerification _sendEmailVerification;
  final ReloadUser _reloadUser;
  final FirebaseAuth _auth;
  final VerificationGraceStorage _graceStorage;
  final UpdateVerificationGrace _updateGrace;
  Timer? _resendTicker;

  Future<void> hydrate({
    String? email,
    String? uid,
    DateTime? initialGraceDeadline,
    bool? initialGraceUsed,
  }) async {
    final user = _auth.currentUser;
    final resolvedUid = uid ?? user?.uid;
    final resolvedEmail = email ?? user?.email;
    DateTime? storedDeadline;
    bool storedUsed = false;
    if (resolvedUid != null) {
      storedDeadline = _graceStorage.getDeadline(resolvedUid);
      storedUsed = _graceStorage.hasUsedGrace(resolvedUid);
    }
    final deadline = storedDeadline ?? initialGraceDeadline;
    final used = storedUsed || (initialGraceUsed ?? false);
    if (resolvedUid != null) {
      if (deadline != null && storedDeadline == null) {
        await _graceStorage.saveDeadline(resolvedUid, deadline);
      }
      if (used && !storedUsed) {
        await _graceStorage.markGraceUsed(resolvedUid);
      }
    }
    final requiresVerification = requiresEmailVerification(resolvedEmail);
    emit(
      state.copyWith(
        initializing: false,
        email: resolvedEmail,
        userId: resolvedUid,
        graceDeadline: deadline,
        graceUsed: used,
        verified: requiresVerification ? user?.emailVerified ?? false : true,
      ),
    );
  }

  Future<void> sendVerificationEmail() async {
    if (!state.canResendEmail) return;
    emit(
      state.copyWith(
        sending: true,
        error: null,
        emailSent: false,
      ),
    );
    try {
      await _sendEmailVerification();
      emit(
        state.copyWith(
          sending: false,
          emailSent: true,
          resendSeconds: resendCooldown.inSeconds,
        ),
      );
      _startResendCountdown(resendCooldown.inSeconds);
    } catch (e) {
      emit(
        state.copyWith(
          sending: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  Future<void> refreshStatus() async {
    emit(state.copyWith(checking: true, error: null));
    try {
      await _reloadUser();
      final verified = _auth.currentUser?.emailVerified ?? false;
      DateTime? deadline = state.graceDeadline;
      bool graceUsed = state.graceUsed;
      String? errorMessage;
      final requiresVerification = requiresEmailVerification(state.email);
      if (!requiresVerification) {
        emit(
          state.copyWith(
            checking: false,
            verified: true,
            graceDeadline: null,
            graceUsed: false,
            error: null,
          ),
        );
        return;
      }
      if (verified && state.userId != null) {
        await _graceStorage.clearDeadline(state.userId!);
        await _graceStorage.clearGraceUsage(state.userId!);
        await _updateGrace(deadline: null, used: false);
        deadline = null;
        graceUsed = false;
      } else if (!verified) {
        errorMessage =
            'AÃºn no detectamos la verificaciÃ³n. Revisa tu correo y vuelve a intentarlo.';
      }
      emit(
        state.copyWith(
          checking: false,
          verified: verified,
          graceDeadline: deadline,
          graceUsed: graceUsed,
          error: errorMessage,
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          checking: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  Future<void> allowTemporaryAccess() async {
    final uid = state.userId ?? _auth.currentUser?.uid;
    if (uid == null) {
      emit(state.copyWith(error: 'No hay una sesiÃ³n activa.'));
      return;
    }
    if (!requiresEmailVerification(state.email)) {
      emit(
        state.copyWith(
          error: 'Esta cuenta no requiere verificaciÃ³n por correo.',
        ),
      );
      return;
    }
    if (state.graceUsed) {
      emit(
        state.copyWith(
          error:
              'Ya usaste el periodo temporal. Debes verificar tu cuenta para ingresar.',
        ),
      );
      return;
    }
    emit(state.copyWith(continuing: true, error: null));
    try {
      final deadline = DateTime.now().add(graceDuration);
      await _updateGrace(deadline: deadline, used: true);
      await _graceStorage.saveDeadline(uid, deadline);
      await _graceStorage.markGraceUsed(uid);
      await _graceStorage.markReminderShown(uid, instant: DateTime.now());
      emit(
        state.copyWith(
          continuing: false,
          graceDeadline: deadline,
          graceUsed: true,
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          continuing: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  void _startResendCountdown(int seconds) {
    _resendTicker?.cancel();
    if (seconds <= 0) {
      emit(state.copyWith(resendSeconds: 0));
      return;
    }
    var remaining = seconds;
    emit(state.copyWith(resendSeconds: remaining));
    _resendTicker = Timer.periodic(const Duration(seconds: 1), (timer) {
      remaining -= 1;
      if (remaining <= 0) {
        timer.cancel();
        emit(state.copyWith(resendSeconds: 0));
      } else {
        emit(state.copyWith(resendSeconds: remaining));
      }
    });
  }

  @override
  Future<void> close() {
    _resendTicker?.cancel();
    return super.close();
  }
}

 END FILE: modules/features/auth/presentation/blocs/email_verification_cubit.dart 

-------- FILE: modules/features/auth/presentation/blocs/login_bloc.dart --------
// lib/modules/features/auth/presentation/blocs/login_bloc.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/usecases/login_user.dart';
import '../../domain/entities/user_entity.dart';

abstract class LoginEvent {}

class LoginSubmittedEvent extends LoginEvent {
  /// Puede ser correo o documento (cÃ©dula/RUC/pasaporte).
  final String identifier;
  final String password;

  LoginSubmittedEvent({
    required this.identifier,
    required this.password,
  });
}

abstract class LoginBlocState {}

class LoginInitial extends LoginBlocState {}
class LoginLoading extends LoginBlocState {}
class LoginSuccess extends LoginBlocState {
  final UserEntity user;
  LoginSuccess(this.user);
}
class LoginFailure extends LoginBlocState {
  final String error;
  LoginFailure(this.error);
}

class LoginBloc extends Bloc<LoginEvent, LoginBlocState> {
  final LoginUser loginUser;

  LoginBloc({required this.loginUser}) : super(LoginInitial()) {
    on<LoginSubmittedEvent>(_onLoginSubmitted);
  }

  Future<void> _onLoginSubmitted(
    LoginSubmittedEvent event,
    Emitter<LoginBlocState> emit,
  ) async {
    emit(LoginLoading());
    try {
      // Sin lÃ³gica de cÃ©dula aquÃ­: lo maneja el DataSource
      final user = await loginUser(event.identifier.trim(), event.password.trim());
      emit(LoginSuccess(user));
    } catch (e) {
      emit(LoginFailure(e.toString().replaceFirst('Exception: ', '')));
    }
  }
}

------ END FILE: modules/features/auth/presentation/blocs/login_bloc.dart ------

-------- FILE: modules/features/auth/presentation/blocs/login_cubit.dart -------
// lib/modules/features/auth/presentation/blocs/login_cubit.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class LoginCubit extends Cubit<bool> {
  LoginCubit() : super(false);

  final formKey = GlobalKey<FormState>();

  void onFieldChanged(
    TextEditingController user,
    TextEditingController password,
  ) {
    emit(_validate(user, password));
  }

  bool _validate(TextEditingController user, TextEditingController password) {
    final userValid = user.text.trim().isNotEmpty; // flexible: correo o cedula
    final passwordValid = password.text.trim().length >= 6;
    return userValid && passwordValid;
  }

  // â Exponlo como mÃ©todo pÃºblico:
  String? validateUser(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Usuario obligatorio';
    }
    final emailRegex = RegExp(r"^[\w-\.]+@([\w-]+\.)+[\w]{2,4}$");
    final isEmail = emailRegex.hasMatch(value.trim());
    final isId = int.tryParse(value.trim()) != null;

    if (!isEmail && !isId) {
      return 'Debe ser correo o nÃºmero vÃ¡lido';
    }

    return null;
  }

  String? validatePassword(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'ContraseÃ±a obligatoria';
    }
    if (value.trim().length < 6) {
      return 'MÃ­nimo 6 caracteres';
    }
    return null;
  }
}

------ END FILE: modules/features/auth/presentation/blocs/login_cubit.dart -----

--- FILE: modules/features/auth/presentation/blocs/password_reset_cubit.dart ---
// lib/modules/features/auth/presentation/blocs/password_reset_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/usecases/send_password_reset_email.dart';
import '../../domain/usecases/start_phone_verification.dart';
import '../../domain/usecases/recovery_lookup.dart';
import '../../domain/usecases/verify_otp_get_proof.dart';
import '../../domain/usecases/finish_password_reset_with_proof.dart';
import '../../../../core/utils/validation/phone_normalizer.dart';

enum FinderMode { cedula, email }

class PasswordResetState {
  final bool loading;
  final String? error;
  final String? info;

  final String? identifier;
  final FinderMode finderMode;

  final bool lookupDone;
  final List<String> channels; // ['phone'|'sms', 'email']
  final String? maskedEmail;
  final String? maskedPhone;
  final String? phoneE164;

  final String? verificationId;
  final bool codeSent;

  final String? selectedChannel; // 'phone' | 'email'
  final bool awaitingNewPassword;

  final bool needsPhoneEntry;

  // Auth proof verificado
  final String? cachedAuthProof;

  const PasswordResetState({
    this.loading = false,
    this.error,
    this.info,
    this.identifier,
    this.finderMode = FinderMode.cedula,
    this.lookupDone = false,
    this.channels = const [],
    this.maskedEmail,
    this.maskedPhone,
    this.phoneE164,
    this.verificationId,
    this.codeSent = false,
    this.selectedChannel,
    this.awaitingNewPassword = false,
    this.needsPhoneEntry = false,
    this.cachedAuthProof,
  });

  PasswordResetState copyWith({
    bool? loading,
    String? error,
    String? info,
    String? identifier,
    FinderMode? finderMode,
    bool? lookupDone,
    List<String>? channels,
    String? maskedEmail,
    String? maskedPhone,
    String? phoneE164,
    String? verificationId,
    bool? codeSent,
    String? selectedChannel,
    bool? awaitingNewPassword,
    bool? needsPhoneEntry,
    String? cachedAuthProof,
  }) {
    return PasswordResetState(
      loading: loading ?? this.loading,
      error: error,
      info: info,
      identifier: identifier ?? this.identifier,
      finderMode: finderMode ?? this.finderMode,
      lookupDone: lookupDone ?? this.lookupDone,
      channels: channels ?? this.channels,
      maskedEmail: maskedEmail ?? this.maskedEmail,
      maskedPhone: maskedPhone ?? this.maskedPhone,
      phoneE164: phoneE164 ?? this.phoneE164,
      verificationId: verificationId ?? this.verificationId,
      codeSent: codeSent ?? this.codeSent,
      selectedChannel: selectedChannel ?? this.selectedChannel,
      awaitingNewPassword: awaitingNewPassword ?? this.awaitingNewPassword,
      needsPhoneEntry: needsPhoneEntry ?? this.needsPhoneEntry,
      cachedAuthProof: cachedAuthProof ?? this.cachedAuthProof,
    );
  }
}

class PasswordResetCubit extends Cubit<PasswordResetState> {
  final SendPasswordResetEmail sendPasswordResetEmail;
  final StartPhoneVerification startPhoneVerification;
  final RecoveryLookup recoveryLookup;

  final VerifyOtpGetProof verifyOtpGetProof;
  final FinishPasswordResetWithProof finishWithProof;

  PasswordResetCubit({
    required this.sendPasswordResetEmail,
    required this.startPhoneVerification,
    required this.recoveryLookup,
    required this.verifyOtpGetProof,
    required this.finishWithProof,
  }) : super(const PasswordResetState());

  void clearMessages() => emit(state.copyWith(error: null, info: null));

  void setFinderMode(FinderMode m) => emit(
    state.copyWith(
      finderMode: m,
      identifier: null,
      lookupDone: false,
      channels: const [],
      maskedEmail: null,
      maskedPhone: null,
      phoneE164: null,
      codeSent: false,
      verificationId: null,
      selectedChannel: null,
      awaitingNewPassword: false,
      needsPhoneEntry: false,
      cachedAuthProof: null,
      error: null,
      info: null,
    ),
  );

  void resetToFinder() => emit(
    state.copyWith(
      lookupDone: false,
      channels: const [],
      maskedEmail: null,
      maskedPhone: null,
      phoneE164: null,
      codeSent: false,
      verificationId: null,
      selectedChannel: null,
      awaitingNewPassword: false,
      needsPhoneEntry: false,
      cachedAuthProof: null,
      error: null,
      info: null,
    ),
  );

  void cancelNewPassword() =>
      emit(state.copyWith(awaitingNewPassword: false, cachedAuthProof: null));

  // ---------------- LOOKUP ----------------
  Future<void> findAccount(String identifier) async {
    emit(
      state.copyWith(
        loading: true,
        error: null,
        info: null,
        identifier: identifier,
        lookupDone: false,
        channels: const [],
        maskedEmail: null,
        maskedPhone: null,
        phoneE164: null,
        codeSent: false,
        verificationId: null,
        selectedChannel: null,
        awaitingNewPassword: false,
        needsPhoneEntry: false,
        cachedAuthProof: null,
      ),
    );
    try {
      final r = await recoveryLookup(identifier);
      final normalized =
          r.channels
              .map((c) => c.toLowerCase().trim())
              .map((c) => c == 'sms' ? 'phone' : c)
              .toList();

      emit(
        state.copyWith(
          loading: false,
          lookupDone: true,
          channels: normalized,
          maskedEmail: r.maskedEmail,
          maskedPhone: r.maskedPhone,
          phoneE164: r.phoneE164, // ya en E.164 si backend lo envÃ­a
          info: 'Si tu cuenta existe, muestra los mÃ©todos disponibles.',
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          loading: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  // ---------------- SELECCIÃN ----------------
  void selectChannel(String channel) {
    final needPhone =
        channel == 'phone' &&
        (state.phoneE164 == null || state.phoneE164!.isEmpty);
    emit(
      state.copyWith(
        selectedChannel: channel,
        codeSent: false,
        verificationId: null,
        awaitingNewPassword: false,
        needsPhoneEntry: needPhone,
        cachedAuthProof: null,
        error: null,
        info: null,
      ),
    );
  }

  Future<void> startSelectedChannel() async {
    final ch = state.selectedChannel;
    if (ch == null) return;

    if (ch == 'phone') {
      if (state.needsPhoneEntry) {
        emit(
          state.copyWith(info: 'Confirma tu telÃ©fono para enviarte el SMS.'),
        );
        return;
      }
      await requestOtp(); // usa phoneE164 del lookup si vino
      return;
    }

    // email
    final emailToUse = state.identifier ?? '';
    if (emailToUse.isEmpty) {
      emit(state.copyWith(error: 'Ingresa tu correo en el buscador.'));
      return;
    }
    await resetByEmail(emailToUse);
  }

  // ---------------- EMAIL ----------------
  Future<void> resetByEmail(String email) async {
    emit(state.copyWith(loading: true, error: null, info: null));
    try {
      await sendPasswordResetEmail(email);
      emit(
        state.copyWith(
          loading: false,
          info: 'Te enviamos un enlace para restablecer la contraseÃ±a.',
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          loading: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  // ---------------- TELÃFONO ----------------
  Future<void> requestOtp() async {
    final raw = state.phoneE164 ?? '';
    // A veces lookup trae "raw"; normalizamos por si acaso.
    final e164 = PhoneNormalizerEC.toE164(raw) ?? raw;

    if (PhoneNormalizerEC.toE164(e164) == null) {
      emit(
        state.copyWith(
          needsPhoneEntry: true,
          error: 'TelÃ©fono invÃ¡lido. CorrÃ­gelo e intÃ©ntalo nuevamente.',
        ),
      );
      return;
    }

    emit(state.copyWith(loading: true, error: null, info: null));
    try {
      final verId = await startPhoneVerification(e164);
      emit(
        state.copyWith(
          loading: false,
          phoneE164: e164,
          verificationId: verId,
          codeSent: true,
          needsPhoneEntry: false,
          info: 'Te enviamos un SMS. Ingresa el cÃ³digo para continuar.',
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          loading: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  Future<void> requestOtpForPhone(String userInputPhone) async {
    final e164 = PhoneNormalizerEC.toE164(userInputPhone);
    if (e164 == null) {
      emit(state.copyWith(error: 'TelÃ©fono invÃ¡lido. Verifica el formato.'));
      return;
    }
    emit(state.copyWith(loading: true, error: null, info: null));
    try {
      final verId = await startPhoneVerification(e164);
      emit(
        state.copyWith(
          loading: false,
          phoneE164: e164,
          verificationId: verId,
          codeSent: true,
          needsPhoneEntry: false,
          info: 'Te enviamos un SMS. Ingresa el cÃ³digo para continuar.',
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          loading: false,
          error: e.toString().replaceFirst('Exception: ', ''),
        ),
      );
    }
  }

  // -------- VerificaciÃ³n estricta en servidor --------
  Future<void> verifyOtpRemotely(String code) async {
    final c = code.trim();
    if (!RegExp(r'^\d{6}$').hasMatch(c)) {
      emit(state.copyWith(error: 'El cÃ³digo debe tener 6 dÃ­gitos.'));
      return;
    }
    if ((state.verificationId ?? '').isEmpty) {
      emit(state.copyWith(error: 'Primero solicita el cÃ³digo SMS.'));
      return;
    }

    emit(state.copyWith(loading: true, error: null, info: null));
    try {
      final proof = await verifyOtpGetProof(
        verificationId: state.verificationId!,
        smsCode: c,
      );
      emit(
        state.copyWith(
          loading: false,
          cachedAuthProof: proof,
          awaitingNewPassword: true,
          info: 'CÃ³digo verificado. Crea tu nueva contraseÃ±a.',
        ),
      );
    } catch (_) {
      emit(
        state.copyWith(
          loading: false,
          error: 'CÃ³digo incorrecto o expirado. Solicita uno nuevo.',
        ),
      );
    }
  }

  // ConfirmaciÃ³n final con el proof verificado
  Future<void> confirmWithCachedOtp(String newPassword) async {
    if (!(state.awaitingNewPassword &&
        (state.cachedAuthProof ?? '').isNotEmpty)) {
      emit(state.copyWith(error: 'Valida primero el cÃ³digo SMS.'));
      return;
    }
    if (newPassword.trim().length < 6) {
      emit(
        state.copyWith(
          error: 'La nueva contraseÃ±a debe tener al menos 6 caracteres.',
        ),
      );
      return;
    }
    final identifier = (state.identifier ?? '').trim();
    if (identifier.isEmpty) {
      emit(
        state.copyWith(
          error: 'Falta el identificador de la cuenta. Vuelve a buscar.',
        ),
      );
      return;
    }

    emit(state.copyWith(loading: true, error: null, info: null));
    try {
      await finishWithProof(
        authProof: state.cachedAuthProof!,
        newPassword: newPassword.trim(),
        identifier: identifier,
      );
      emit(
        state.copyWith(
          loading: false,
          info: 'Â¡Listo! Ya puedes iniciar sesiÃ³n con tu nueva contraseÃ±a.',
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          loading: false,
          error: e.toString().replaceFirst(
            'Exception: ',
            'No pudimos cambiar la contraseÃ±a.',
          ),
        ),
      );
    }
  }

  void backToChannels() => emit(
    state.copyWith(
      selectedChannel: null,
      codeSent: false,
      verificationId: null,
      awaitingNewPassword: false,
      needsPhoneEntry: false,
      cachedAuthProof: null,
      error: null,
      info: null,
    ),
  );
}

- END FILE: modules/features/auth/presentation/blocs/password_reset_cubit.dart -

------- FILE: modules/features/auth/presentation/blocs/register_bloc.dart ------
// lib/modules/features/auth/presentation/blocs/register_bloc.dart

import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/user_entity.dart';
import '../../domain/usecases/register_user.dart';

abstract class RegisterEvent {}

class SubmitRegisterEvent extends RegisterEvent {
  final UserEntity user;
  final String password;
  final String role;

  SubmitRegisterEvent({
    required this.user,
    required this.password,
    required this.role,
  });
}

abstract class RegisterBlocState {}

class RegisterInitial extends RegisterBlocState {}

class RegisterLoading extends RegisterBlocState {}

class RegisterSuccess extends RegisterBlocState {}

class RegisterFailure extends RegisterBlocState {
  final String error;
  RegisterFailure(this.error);
}

class RegisterBloc extends Bloc<RegisterEvent, RegisterBlocState> {
  final RegisterUser registerUser;

  RegisterBloc({required this.registerUser}) : super(RegisterInitial()) {
    on<SubmitRegisterEvent>(_onSubmitRegister);
  }

  Future<void> _onSubmitRegister(
    SubmitRegisterEvent event,
    Emitter<RegisterBlocState> emit,
  ) async {
    emit(RegisterLoading());
    try {
      await registerUser(event.user, event.password, event.role);
      emit(RegisterSuccess());
    } catch (e) {
      emit(RegisterFailure(e.toString()));
    }
  }

  @override
  Future<void> close() {
    // ð CAMBIO: Si necesitas limpiar recursos adicionales, hazlo aquÃ­.
    return super.close();
  }
}

----- END FILE: modules/features/auth/presentation/blocs/register_bloc.dart ----

------ FILE: modules/features/auth/presentation/blocs/register_cubit.dart ------
// lib/modules/features/auth/presentation/blocs/register_cubit.dart

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

part 'register_state.dart';

class RegisterCubit extends Cubit<RegisterCubitState> {
  final String role;

  RegisterCubit({required this.role})
      : super(RegisterCubitState(selectedDocumentType: 'CÃ©dula'));

  final formKeyStep1 = GlobalKey<FormState>();
  final formKeyStep2 = GlobalKey<FormState>();

  final TextEditingController cedulaController = TextEditingController();
  final TextEditingController emailController = TextEditingController();
  final TextEditingController phoneController = TextEditingController();
  final TextEditingController passwordController = TextEditingController();
  final TextEditingController nameController = TextEditingController();
  final TextEditingController addressController = TextEditingController();
  final TextEditingController businessNameController = TextEditingController();

  bool acceptedPrivacy = false;

  String selectedDocumentType = 'CÃ©dula';

  void onDocumentTypeChanged(String? type) {
    selectedDocumentType = type ?? 'CÃ©dula';
    cedulaController.clear();
    emit(state.copyWith(
      selectedDocumentType: selectedDocumentType,
      isStep1Valid: false,
    ));
  }

  void setAcceptedPrivacy(bool? value) {
    acceptedPrivacy = value ?? false;
    emit(state.copyWith(isStep2Valid: _validateStep2()));
  }

  void onFieldChanged() {
    emit(state.copyWith(isStep1Valid: _validateStep1()));
  }

  void onFieldChangedStep2() {
    emit(state.copyWith(isStep2Valid: _validateStep2()));
  }

  bool _validateStep1() {
    final emailRegex = RegExp(
      r"^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+"
      r"@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z]{2,}$",
    );

    if (role == 'entrepreneur' || role == 'emprendedora') {
      final docValid = cedulaController.text.trim().length >= 5;
      final phoneValid = phoneController.text.trim().length >= 9;
      final emailValid = emailController.text.trim().isEmpty ||
          emailRegex.hasMatch(emailController.text.trim());
      final passwordValid = passwordController.text.trim().length >= 6;

      return docValid && phoneValid && emailValid && passwordValid;
    } else {
      return emailRegex.hasMatch(emailController.text.trim()) &&
          passwordController.text.trim().length >= 6;
    }
  }

  bool _validateStep2() {
    final nameValid = nameController.text.trim().isNotEmpty;
    final addressValid = role == 'entrepreneur' || role == 'emprendedora'
        ? addressController.text.trim().isNotEmpty
        : true;
    final phoneValid = role == 'client' || role == 'cliente'
        ? phoneController.text.trim().length >= 9
        : true;

    return nameValid && addressValid && phoneValid && acceptedPrivacy;
  }

  void goToStep2() {
    final isValid = formKeyStep1.currentState?.validate() ?? false;
    if (isValid) {
      emit(state.copyWith(step: 2, isStep2Valid: _validateStep2()));
    }
  }

  void goToStep1() {
    emit(state.copyWith(step: 1));
  }

  @override
  Future<void> close() {
    cedulaController.dispose();
    emailController.dispose();
    phoneController.dispose();
    passwordController.dispose();
    nameController.dispose();
    addressController.dispose();
    businessNameController.dispose();
    return super.close();
  }
}

---- END FILE: modules/features/auth/presentation/blocs/register_cubit.dart ----

------ FILE: modules/features/auth/presentation/blocs/register_state.dart ------
// lib/modules/features/auth/presentation/blocs/register_state.dart
part of 'register_cubit.dart';

class RegisterCubitState {
  final int step;
  final bool isStep1Valid;
  final bool isStep2Valid;
  final String selectedDocumentType;

  RegisterCubitState({
    this.step = 1,
    this.isStep1Valid = false,
    this.isStep2Valid = false,
    required this.selectedDocumentType,
  });

  RegisterCubitState copyWith({
    int? step,
    bool? isStep1Valid,
    bool? isStep2Valid,
    String? selectedDocumentType,
  }) {
    return RegisterCubitState(
      step: step ?? this.step,
      isStep1Valid: isStep1Valid ?? this.isStep1Valid,
      isStep2Valid: isStep2Valid ?? this.isStep2Valid,
      selectedDocumentType: selectedDocumentType ?? this.selectedDocumentType,
    );
  }
}

---- END FILE: modules/features/auth/presentation/blocs/register_state.dart ----

--- FILE: modules/features/auth/presentation/blocs/role_selection_cubit.dart ---
// features/auth/presentation/blocs/role_selection_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';

part 'role_selection_state.dart';

enum UserRole { none, client, entrepreneur, admin }

class RoleSelectionCubit extends Cubit<RoleSelectionState> {
  RoleSelectionCubit() : super(RoleSelectionState());

  void selectRole(UserRole role) {
    emit(state.copyWith(selectedRole: role));
  }

  void continueToRegister() {
    if (state.selectedRole == UserRole.none) {
      emit(state.copyWith(error: 'Por favor selecciona un rol.'));
    } else {
      emit(state.copyWith(continueToRegister: true));
    }
  }
}

- END FILE: modules/features/auth/presentation/blocs/role_selection_cubit.dart -

--- FILE: modules/features/auth/presentation/blocs/role_selection_state.dart ---
// features/auth/presentation/blocs/role_selection_state.dart
part of 'role_selection_cubit.dart';

class RoleSelectionState {
  final UserRole selectedRole;
  final bool continueToRegister;
  final String? error;

  RoleSelectionState({
    this.selectedRole = UserRole.none,
    this.continueToRegister = false,
    this.error,
  });

  RoleSelectionState copyWith({
    UserRole? selectedRole,
    bool? continueToRegister,
    String? error,
  }) {
    return RoleSelectionState(
      selectedRole: selectedRole ?? this.selectedRole,
      continueToRegister: continueToRegister ?? false,
      error: error,
    );
  }
}

- END FILE: modules/features/auth/presentation/blocs/role_selection_state.dart -

------- FILE: modules/features/auth/presentation/blocs/welcome_cubit.dart ------
// modules/features/auth/presentation/blocs/welcome_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';

part 'welcome_state.dart';

class WelcomeCubit extends Cubit<WelcomeState> {
  WelcomeCubit() : super(WelcomeInitial());

  void continueAsGuest() => emit(ContinueAsGuest());
  void goToRegister()    => emit(GoToRegister());
  void goToLogin()       => emit(GoToLogin());

  // << NUEVO: para evitar que el listener navegue de nuevo al reconstruir Welcome
  void reset() => emit(WelcomeInitial());
}

----- END FILE: modules/features/auth/presentation/blocs/welcome_cubit.dart ----

------- FILE: modules/features/auth/presentation/blocs/welcome_state.dart ------
// modules/features/auth/presentation/blocs/welcome_state.dart
part of 'welcome_cubit.dart';

abstract class WelcomeState {}

class WelcomeInitial extends WelcomeState {}

class ContinueAsGuest extends WelcomeState {}

class GoToLogin extends WelcomeState {}

class GoToRegister extends WelcomeState {}


----- END FILE: modules/features/auth/presentation/blocs/welcome_state.dart ----

Dentro de /pages:

---- FILE: modules/features/auth/presentation/pages/access_request_page.dart ---
// lib/modules/features/auth/presentation/pages/access_request_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/feedback/blocking_loader.dart';
import '../blocs/access_request_cubit.dart';
import '../widgets/access_request/invite_gate.dart';
import '../widgets/access_request/status_card.dart';
// ð nuevo wizard
import '../widgets/admin_wizard/admin_wizard.dart';
import '../../domain/entities/access_request.dart';

class AccessRequestPage extends StatelessWidget {
  const AccessRequestPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<AccessRequestCubit, AccessRequestState>(
      listenWhen: (p, c) => p.error != c.error && c.error != null,
      listener: (context, state) {
        if (state.error != null && !state.loading) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.error!.replaceFirst('Exception: ', ''))),
          );
        }
      },
      builder: (context, state) {
        Widget body;

        if (state.current != null) {
          switch (state.current!.status) {
            case AccessRequestStatus.pending:
              body = const AccessStatusCard(
                icon: Icons.hourglass_bottom_rounded,
                title: 'Solicitud enviada',
                subtitle:
                    'Estamos revisando tu solicitud. Te avisaremos cuando haya una decisiÃ³n.',
              );
              break;
            case AccessRequestStatus.approved:
              body = const AccessStatusCard(
                icon: Icons.verified_rounded,
                title: 'Â¡Solicitud aprobada!',
                subtitle:
                    'Vuelve a iniciar sesiÃ³n. Si tu rol ya es "admin", verÃ¡s el panel administrativo.',
              );
              break;
            case AccessRequestStatus.rejected:
              body = const AccessStatusCard(
                icon: Icons.cancel_rounded,
                title: 'Solicitud rechazada',
                subtitle: 'Puedes contactar a soporte si consideras que hay un error.',
              );
              break;
          }
        } else {
          body = (state.inviteVerified == true)
              ? const AdminWizard() // â aquÃ­ usamos el wizard
              : const InviteGate();
        }

        return PopScope(
          onPopInvokedWithResult: (didPop, result) {
            context.read<AccessRequestCubit>().reset();
          },
          child: Scaffold(
            resizeToAvoidBottomInset: false, // â no empujar toda la pantalla
            appBar: AppBar(
              title: const Text('Solicitud de Acceso'),
              backgroundColor: AppTheme.purpleDark,
              foregroundColor: AppTheme.white,
            ),
            body: Stack(
              children: [
                AnimatedSwitcher(
                  duration: const Duration(milliseconds: 200),
                  child: body,
                ),
                if (state.loading) const BlockingLoader(),
              ],
            ),
          ),
        );
      },
    );
  }
}

-- END FILE: modules/features/auth/presentation/pages/access_request_page.dart -

-- FILE: modules/features/auth/presentation/pages/email_verification_page.dart -
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';

import '../../../../core/config/app_routes.dart';
import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../../../core/widgets/layout/app_logo.dart';
import '../../../admin/admin_routes.dart';
import '../../domain/entities/user_entity.dart';
import '../../domain/role_utils.dart';
import '../blocs/email_verification_cubit.dart';
import '../../../../core/services/storage/session_storage.dart';

class EmailVerificationPageArguments {
  final UserEntity? user;
  const EmailVerificationPageArguments({this.user});
}

class EmailVerificationPage extends StatefulWidget {
  final UserEntity? user;
  const EmailVerificationPage({super.key, this.user});

  @override
  State<EmailVerificationPage> createState() => _EmailVerificationPageState();
}

class _EmailVerificationPageState extends State<EmailVerificationPage> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<EmailVerificationCubit>().hydrate(
            email: widget.user?.email,
            uid: widget.user?.uid,
            initialGraceDeadline: widget.user?.graceDeadline,
            initialGraceUsed: widget.user?.graceUsed,
          );
    });
  }

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, _) {
        if (didPop) return;
        if (!mounted) return;
        final messenger = ScaffoldMessenger.of(context);
        messenger
          ..removeCurrentSnackBar()
          ..showSnackBar(
            const SnackBar(
              content: Text('Debes verificar tu correo para continuar.'),
            ),
          );
      },
      child: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
            ),
          ),
          child: SafeArea(
            child: LayoutBuilder(
              builder: (context, constraints) {
                final horizontalPadding = constraints.maxWidth >= 640 ? 32.0 : 20.0;
                final contentWidth =
                    constraints.maxWidth >= 640
                        ? 560.0
                        : constraints.maxWidth - horizontalPadding * 2;
                final maxContentWidth =
                    contentWidth.clamp(280.0, constraints.maxWidth).toDouble();

                return BlocConsumer<EmailVerificationCubit, EmailVerificationState>(
                  listener: (context, state) {
                    if (state.error != null && state.error!.isNotEmpty) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(state.error!)),
                      );
                    }
                    if (state.verified) {
                      _goHome(context);
                    }
                  },
                  builder: (context, state) {
                    final email = state.email ?? widget.user?.email ?? 'tu correo';
                    final resendWait = state.resendWait;
                    final graceRemaining = state.graceRemaining;
                    final graceDeadline = state.graceDeadline;
                    final continueLabel = state.hasActiveGrace
                        ? 'Continuar a la app${graceRemaining != null ? ' (te restan ${_formatDuration(graceRemaining)})' : ''}'
                        : state.graceUsed
                            ? 'PerÃ­odo temporal agotado'
                            : 'Continuar sin verificar (7 dÃ­as)';

                    return SingleChildScrollView(
                      padding: EdgeInsets.symmetric(
                        horizontal: horizontalPadding,
                        vertical: 24,
                      ),
                      child: Center(
                        child: ConstrainedBox(
                          constraints: BoxConstraints(maxWidth: maxContentWidth),
                          child: Column(
                            children: [
                              const SizedBox(height: 8),
                              const AppLogo(size: 120),
                              const SizedBox(height: 16),
                              Card(
                                elevation: 8,
                                color: Colors.white,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(32),
                                ),
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(
                                    horizontal: 28,
                                    vertical: 32,
                                  ),
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.stretch,
                                    children: [
                                      Column(
                                        crossAxisAlignment: CrossAxisAlignment.center,
                                        children: [
                                          const Text(
                                            'Verifica tu correo',
                                            textAlign: TextAlign.center,
                                            style: TextStyle(
                                              fontSize: 26,
                                              fontWeight: FontWeight.bold,
                                              color: AppTheme.purpleDark,
                                            ),
                                          ),
                                          const SizedBox(height: 12),
                                          Text(
                                            'Necesitamos confirmar tu correo para activar tu cuenta. '
                                            'Revisa la bandeja de entrada y el spam.',
                                            textAlign: TextAlign.center,
                                            style: TextStyle(
                                              color: Colors.grey.shade700,
                                              height: 1.4,
                                            ),
                                          ),
                                        ],
                                      ),
                                      const SizedBox(height: 24),
                                      _EmailBadge(email: email),
                                      const SizedBox(height: 24),
                                      PrimaryButton(
                                        text:
                                            state.sending
                                                ? 'Enviando...'
                                                : 'Enviar correo de verificaciÃ³n',
                                        isLoading: state.sending,
                                        onPressed:
                                            state.canResendEmail
                                                ? () => context
                                                    .read<EmailVerificationCubit>()
                                                    .sendVerificationEmail()
                                                : null,
                                      ),
                                      const SizedBox(height: 12),
                                      AnimatedSwitcher(
                                        duration: const Duration(milliseconds: 300),
                                        child:
                                            resendWait != null
                                                ? Text(
                                                  'PodrÃ¡s reenviar en ${_formatDuration(resendWait)}',
                                                  key: ValueKey(resendWait.inSeconds),
                                                  textAlign: TextAlign.center,
                                                  style: const TextStyle(
                                                    color: Colors.black54,
                                                    fontSize: 13,
                                                  ),
                                                )
                                                : const SizedBox.shrink(),
                                      ),
                                      if (state.emailSent) ...[
                                        const SizedBox(height: 8),
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.center,
                                          children: const [
                                            Icon(Icons.check_circle, color: Colors.green),
                                            SizedBox(width: 6),
                                            Flexible(
                                              child: Text(
                                                'Correo enviado, revisa tu bandeja.',
                                                style: TextStyle(
                                                  color: Colors.green,
                                                  fontWeight: FontWeight.w600,
                                                ),
                                              ),
                                            ),
                                          ],
                                        ),
                                      ],
                                      const SizedBox(height: 24),
                                      PrimaryButton(
                                        text:
                                            state.checking
                                                ? 'Comprobando...'
                                                : 'Ya verifiquÃ©, continuar',
                                        isLoading: state.checking,
                                        onPressed:
                                            state.checking
                                                ? null
                                                : () => context
                                                    .read<EmailVerificationCubit>()
                                                    .refreshStatus(),
                                      ),
                                      const SizedBox(height: 24),
                                      _InfoSteps(),
                                      const SizedBox(height: 24),
                                      _TempAccessSection(
                                        hasActiveGrace: state.hasActiveGrace,
                                        graceRemaining: graceRemaining,
                                        graceDeadline: graceDeadline,
                                        graceUsed: state.graceUsed,
                                      ),
                                      const SizedBox(height: 12),
                                      OutlinedButton(
                                        onPressed:
                                            (state.continuing ||
                                                    (state.graceUsed && !state.hasActiveGrace))
                                                ? null
                                                : () => _handleContinue(state),
                                        child: Text(continueLabel),
                                      ),
                                      const SizedBox(height: 16),
                                      TextButton.icon(
                                        onPressed: () async {
                                          final navigator = Navigator.of(context);
                                          final sessionStorage =
                                              context.read<SessionStorage>();
                                          final uid =
                                              FirebaseAuth.instance.currentUser?.uid;
                                          await FirebaseAuth.instance.signOut();
                                          if (uid != null) {
                                            await sessionStorage.clearRole(uid);
                                          }
                                          if (!mounted) return;
                                          navigator.pushNamedAndRemoveUntil(
                                            AppRoutes.welcome,
                                            (route) => false,
                                          );
                                        },
                                        style: TextButton.styleFrom(
                                          foregroundColor: Colors.red.shade400,
                                        ),
                                        icon: const Icon(Icons.logout),
                                        label: const Text('Cerrar sesiÃ³n'),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                );
              },
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _handleContinue(EmailVerificationState state) async {
    final cubit = context.read<EmailVerificationCubit>();
    if (state.hasActiveGrace) {
      _goHome(context);
      return;
    }
    await cubit.allowTemporaryAccess();
    if (!mounted) return;
    if (cubit.state.hasActiveGrace) {
      _goHome(context);
    }
  }

  void _goHome(BuildContext context) {
    final role = widget.user?.role;
    final targetRoute =
        role != null && isAdminRole(role) ? AdminRoutes.base : AppRoutes.home;
    Navigator.pushNamedAndRemoveUntil(
      context,
      targetRoute,
      (route) => false,
    );
  }

  static String _formatDuration(Duration duration) {
    final totalMinutes = duration.inMinutes;
    if (totalMinutes >= 60) {
      final hours = duration.inHours;
      final minutes = totalMinutes % 60;
      if (minutes == 0) {
        return '$hours h';
      }
      return '$hours h ${minutes}m';
    }
    final seconds = duration.inSeconds % 60;
    final minutes = duration.inMinutes;
    if (minutes > 0) {
      return seconds == 0 ? '$minutes min' : '$minutes min ${seconds}s';
    }
    return '${duration.inSeconds}s';
  }
}

class _EmailBadge extends StatelessWidget {
  final String email;
  const _EmailBadge({required this.email});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(18),
      decoration: BoxDecoration(
        color: AppTheme.purpleMedium.withValues(alpha: 0.12),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Row(
        children: [
          Container(
            height: 46,
            width: 46,
            decoration: const BoxDecoration(
              color: AppTheme.purpleMedium,
              shape: BoxShape.circle,
            ),
            child: const Icon(Icons.mark_email_read_outlined, color: Colors.white),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Correo pendiente',
                  style: TextStyle(
                    color: AppTheme.purpleMedium.withValues(alpha: 0.8),
                    fontWeight: FontWeight.w600,
                    fontSize: 13,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  email,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _InfoSteps extends StatelessWidget {
  static const List<_StepData> _steps = [
    _StepData(
      icon: Icons.mail_outline,
      title: '1. Abre tu correo',
      subtitle: 'Busca el mensaje de 100 Mujeres Trabajando (revisa spam).',
    ),
    _StepData(
      icon: Icons.verified_outlined,
      title: '2. Presiona "Verificar"',
      subtitle: 'El enlace activarÃ¡ tu cuenta al instante.',
    ),
    _StepData(
      icon: Icons.refresh,
      title: '3. Regresa a esta pantalla',
      subtitle: 'Toca "Ya verifiquÃ©" para continuar.',
    ),
  ];

  const _InfoSteps();

  @override
  Widget build(BuildContext context) {
    return Column(
      children: _steps
          .map(
            (step) => Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: AppTheme.blue.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Icon(step.icon, color: AppTheme.blue),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          step.title,
                          style: const TextStyle(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          step.subtitle,
                          style: TextStyle(
                            color: Colors.grey.shade600,
                            height: 1.3,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          )
          .toList(),
    );
  }
}

class _StepData {
  final IconData icon;
  final String title;
  final String subtitle;
  const _StepData({
    required this.icon,
    required this.title,
    required this.subtitle,
  });
}

class _TempAccessSection extends StatelessWidget {
  final bool hasActiveGrace;
  final Duration? graceRemaining;
  final DateTime? graceDeadline;
  final bool graceUsed;
  const _TempAccessSection({
    required this.hasActiveGrace,
    required this.graceRemaining,
    required this.graceDeadline,
    required this.graceUsed,
  });

  @override
  Widget build(BuildContext context) {
    if (!hasActiveGrace || graceDeadline == null) {
      if (graceUsed) {
        return Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.red.shade50,
            borderRadius: BorderRadius.circular(16),
          ),
          child: const Text(
            'Ya usaste el acceso temporal de 7 dÃ­as. Debes verificar tu correo para seguir usando la app.',
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.redAccent),
          ),
        );
      }
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.orange.shade50,
          borderRadius: BorderRadius.circular(16),
        ),
        child: const Text(
          'Si necesitas usar la app antes de verificar, puedes habilitar un acceso temporal mÃ¡ximo de 7 dÃ­as. '
          'Pasado ese tiempo volveremos a bloquear el ingreso hasta que completes la verificaciÃ³n.',
          textAlign: TextAlign.center,
          style: TextStyle(color: Colors.black87),
        ),
      );
    }

    final formatter = DateFormat('dd/MM/yyyy HH:mm', 'es_EC');
    final deadlineText = formatter.format(graceDeadline!.toLocal());
    final remainingText =
        graceRemaining == null ? '' : _formatRemaining(graceRemaining!);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.orange.shade50,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Text(
        'Acceso temporal activo hasta $deadlineText.\n'
        '$remainingText\n\nRecuerda verificar antes de esa fecha para evitar bloqueos.',
        textAlign: TextAlign.center,
        style: const TextStyle(color: Colors.black87),
      ),
    );
  }

  String _formatRemaining(Duration duration) {
    final days = duration.inDays;
    final hours = duration.inHours % 24;
    if (days > 0) {
      return hours == 0 ? '$days dÃ­as restantes' : '$days d $hours h restantes';
    }
    final minutes = duration.inMinutes % 60;
    if (duration.inHours > 0) {
      return minutes == 0
          ? '${duration.inHours} h restantes'
          : '${duration.inHours} h ${minutes}m restantes';
    }
    return '${duration.inMinutes} min restantes';
  }
}

 END FILE: modules/features/auth/presentation/pages/email_verification_page.dart 

--- FILE: modules/features/auth/presentation/pages/forgot_password_page.dart ---
// lib/modules/features/auth/presentation/pages/forgot_password_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/layout/app_logo.dart';
import '../blocs/password_reset_cubit.dart';

import '../widgets/recovery/finder_form.dart';
import '../widgets/recovery/method_selector_card.dart';
import '../widgets/recovery/phone_confirm_card.dart';
import '../widgets/recovery/phone_otp_card.dart';
import '../widgets/recovery/password_change_card.dart';
import '../widgets/recovery/email_link_card.dart';

class ForgotPasswordPage extends StatefulWidget {
  const ForgotPasswordPage({super.key});

  @override
  State<ForgotPasswordPage> createState() => _ForgotPasswordPageState();
}

class _ForgotPasswordPageState extends State<ForgotPasswordPage> {
  bool _handleBackInside(PasswordResetState s, PasswordResetCubit c) {
    // Si aÃºn no hicimos lookup, dejamos que la ruta haga pop
    if (!s.lookupDone) return false;

    // Si estamos en el selector de mÃ©todos, volvemos al buscador
    if (s.selectedChannel == null) {
      c.resetToFinder();
      return true;
    }

    // Si estamos en correo, volvemos al selector
    if (s.selectedChannel == 'email') {
      c.backToChannels();
      return true;
    }

    // Si estamos en telÃ©fono:
    if (s.selectedChannel == 'phone') {
      // Si ya pasamos a "nueva contraseÃ±a", regresamos al paso OTP
      if (s.awaitingNewPassword) {
        c.cancelNewPassword();
        return true;
      }
      // Si estÃ¡ pidiendo confirmar telÃ©fono, regresamos al selector
      if (s.needsPhoneEntry) {
        c.backToChannels();
        return true;
      }
      // Si estÃ¡ en OTP, regresamos al selector
      c.backToChannels();
      return true;
    }

    return false;
  }

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<PasswordResetCubit, PasswordResetState>(
      listenWhen: (p, c) => p.error != c.error || p.info != c.info,
      listener: (context, state) {
        if (state.error != null) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text(state.error!)));
        }
        if (state.info != null && state.info!.startsWith('Â¡Listo!')) {
          Navigator.of(context).pop(); // de vuelta al login
        }
      },
      builder: (context, state) {
        final cubit = context.read<PasswordResetCubit>();

        return PopScope(
          canPop: false, // manejamos atrÃ¡s manualmente
          onPopInvokedWithResult: (didPop, _) async {
            // Siempre intentamos retroceder dentro del flujo primero:
            final consumed = _handleBackInside(state, cubit);
            if (!consumed) {
              // No hay mÃ¡s "pasos" atrÃ¡s: cerramos la pÃ¡gina
              Navigator.of(context).pop();
            }
          },
          child: Scaffold(
            body: Stack(
              children: [
                Container(
                  decoration: const BoxDecoration(
                    gradient: LinearGradient(
                      colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                    ),
                  ),
                  child: SafeArea(
                    child: Column(
                      children: [
                        const SizedBox(height: 16),
                        const AppLogo(size: 64),
                        const SizedBox(height: 8),
                        const Text(
                          'Recuperar acceso',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 24,
                            fontWeight: FontWeight.w800,
                          ),
                        ),
                        const SizedBox(height: 4),
                        const Text(
                          'Encuentra tu cuenta y elige cÃ³mo recuperarla.',
                          style: TextStyle(color: Colors.white70),
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: SingleChildScrollView(
                            padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
                            child: _buildBody(context, state, cubit),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                Positioned(
                  top: 16,
                  left: 8,
                  child: SafeArea(
                    child: IconButton(
                      icon: const Icon(Icons.arrow_back, color: Colors.white),
                      onPressed: () {
                        final consumed = _handleBackInside(state, cubit);
                        if (!consumed) Navigator.of(context).pop();
                      },
                    ),
                  ),
                ),
                if (state.loading)
                  Container(
                    color: Colors.black.withValues(alpha: .26),
                    child: const Center(child: CircularProgressIndicator()),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildBody(
    BuildContext context,
    PasswordResetState state,
    PasswordResetCubit cubit,
  ) {
    // 0) Buscar
    if (!state.lookupDone) {
      return FinderForm(
        mode: state.finderMode,
        onModeChanged: cubit.setFinderMode,
        onSubmit: cubit.findAccount,
      );
    }

    // 1) Elegir mÃ©todo
    if (state.selectedChannel == null) {
      final hasPhone =
          (state.channels.contains('phone') ||
              state.channels.contains('sms')) &&
          ((state.phoneE164 != null && state.phoneE164!.isNotEmpty) ||
              (state.maskedPhone != null));
      final hasEmail = state.channels.contains('email');

      return MethodSelectorCard(
        hasPhone: hasPhone,
        hasEmail: hasEmail,
        maskedPhone: state.maskedPhone,
        maskedEmail: state.maskedEmail,
        onPickPhone: () => cubit.selectChannel('phone'),
        onPickEmail: () => cubit.selectChannel('email'),
        onContinue: cubit.startSelectedChannel,
        onBackToFinder: cubit.resetToFinder,
      );
    }

    // 2) Correo
    if (state.selectedChannel == 'email') {
      return EmailLinkCard(
        maskedEmail: state.maskedEmail,
        onChangeMethod: cubit.backToChannels,
        onContinue: () => Navigator.of(context).pop(),
      );
    }

    // 3) TelÃ©fono
    if (state.selectedChannel == 'phone' && state.needsPhoneEntry) {
      return PhoneConfirmCard(
        maskedPhone: state.maskedPhone,
        onSubmit: cubit.requestOtpForPhone,
        onChangeMethod: cubit.backToChannels,
      );
    }

    if (state.selectedChannel == 'phone') {
      // Sin pestaÃ±as: alternamos widget por estado
      final awaiting = state.awaitingNewPassword;
      return Container(
        decoration: BoxDecoration(
          color: Colors.white.withValues(alpha: .92),
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: .15),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: AnimatedSwitcher(
          duration: const Duration(milliseconds: 250),
          transitionBuilder:
              (child, anim) => FadeTransition(opacity: anim, child: child),
          child:
              awaiting
                  ? PasswordChangeCard(
                    key: const ValueKey('password-change'),
                    onSubmit: cubit.confirmWithCachedOtp,
                    enabled: true,
                  )
                  : Padding(
                    key: const ValueKey('otp-verify'),
                    padding: const EdgeInsets.only(top: 8.0),
                    child: PhoneOtpCard(
                      maskedPhone: state.maskedPhone ?? 'tu telÃ©fono',
                      codeSent: state.codeSent,
                      onResend: cubit.requestOtp,
                      onVerify: cubit.verifyOtpRemotely,
                      onChangeMethod: cubit.backToChannels,
                    ),
                  ),
        ),
      );
    }

    return const SizedBox.shrink();
  }
}

- END FILE: modules/features/auth/presentation/pages/forgot_password_page.dart -

-------- FILE: modules/features/auth/presentation/pages/login_page.dart --------
// lib/modules/features/auth/presentation/pages/login_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_routes.dart';
import '../../../../core/config/app_theme.dart';
import '../../../../core/services/storage/verification_grace_storage.dart';
import '../../../../core/services/storage/session_storage.dart';
import '../../../../core/utils/navigation/back_navigator.dart';
import '../../../../core/widgets/layout/app_back_button.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../../../core/widgets/layout/app_logo.dart';
import '../../../../core/widgets/inputs/password_field.dart';
import '../../domain/role_utils.dart';

import '../../auth_routes.dart';
import '../blocs/login_bloc.dart';
import '../blocs/login_cubit.dart';
import 'email_verification_page.dart';

class LoginPage extends StatelessWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider(create: (_) => LoginCubit()),
        BlocProvider.value(value: context.read<LoginBloc>()),
      ],
      child: const _LoginContent(),
    );
  }
}

class _LoginContent extends StatefulWidget {
  const _LoginContent();

  @override
  State<_LoginContent> createState() => _LoginContentState();
}

class _LoginContentState extends State<_LoginContent> {
  final _userController = TextEditingController();
  final _passwordController = TextEditingController();
  final _userFocus = FocusNode();
  final _passwordFocus = FocusNode();

  @override
  void dispose() {
    _userController.dispose();
    _passwordController.dispose();
    _userFocus.dispose();
    _passwordFocus.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final loginCubit = context.read<LoginCubit>();
    final loginBloc = context.read<LoginBloc>();

    void submitIfValid() {
      final form = loginCubit.formKey.currentState;
      if (form != null && form.validate()) {
        loginBloc.add(
          LoginSubmittedEvent(
            // IMPORTANTE: usar 'identifier' (correo o cÃ©dula)
            identifier: _userController.text.trim(),
            password: _passwordController.text.trim(),
          ),
        );
      }
    }

    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, result) async {
        if (didPop) return;
        await handleBack(
          context,
          popToRoute: AuthRoutes.welcome,
          useMaybePop: false,
          forceToRoute: true,
        );
      },
      child: Scaffold(
        resizeToAvoidBottomInset: true,
        body: Stack(
          children: [
            Container(
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                ),
              ),
              child: SafeArea(
                child: Column(
                  children: [
                    const SizedBox(height: 40),
                    const AppLogo(size: 120),
                    Expanded(
                      child: SingleChildScrollView(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 32,
                          vertical: 20,
                        ),
                        child: Form(
                          key: loginCubit.formKey,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.stretch,
                            children: [
                              const SizedBox(height: 16),
                              const Center(
                                child: Text(
                                  'Iniciar sesiÃ³n',
                                  textAlign: TextAlign.center,
                                  style: TextStyle(
                                    color: AppTheme.white,
                                    fontWeight: FontWeight.bold,
                                    fontSize: 28,
                                  ),
                                ),
                              ),
                              const SizedBox(height: 32),

                              // Usuario (correo o cÃ©dula)
                              TextFormField(
                                controller: _userController,
                                focusNode: _userFocus,
                                textInputAction: TextInputAction.next,
                                decoration: InputDecoration(
                                  labelText: 'Usuario',
                                  hintText: 'Correo o nÃºmero de documento',
                                  filled: true,
                                  isDense: true,
                                  // Si tu SDK no tiene withValues, usa withOpacity(0.30)
                                  fillColor: Colors.white.withValues(alpha: .30),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  contentPadding: const EdgeInsets.symmetric(
                                    vertical: 16,
                                    horizontal: 12,
                                  ),
                                ),
                                style: const TextStyle(color: AppTheme.white),
                                onChanged: (_) => loginCubit.onFieldChanged(
                                  _userController,
                                  _passwordController,
                                ),
                                validator: loginCubit.validateUser,
                                autofillHints: const [
                                  AutofillHints.username,
                                  AutofillHints.email,
                                ],
                                onFieldSubmitted: (_) =>
                                    _passwordFocus.requestFocus(),
                              ),
                              const SizedBox(height: 16),

                              // ContraseÃ±a
                              PasswordField(
                                controller: _passwordController,
                                focusNode: _passwordFocus,
                                labelText: 'ContraseÃ±a',
                                validator: loginCubit.validatePassword,
                                onChanged: (_) => loginCubit.onFieldChanged(
                                  _userController,
                                  _passwordController,
                                ),
                                textInputAction: TextInputAction.done,
                                onSubmitted: submitIfValid,
                              ),

                              const SizedBox(height: 12),

                              // Olvidaste tu contraseÃ±a
                              Center(
                                child: TextButton(
                                  onPressed: () {
                                    Navigator.pushNamed(
                                      context,
                                      AuthRoutes.forgotPassword,
                                    );
                                  },
                                  child: const Text(
                                    'Â¿Olvidaste tu contraseÃ±a?',
                                    textAlign: TextAlign.center,
                                    style: TextStyle(color: AppTheme.white),
                                  ),
                                ),
                              ),

                              const SizedBox(height: 20),

                              BlocBuilder<LoginCubit, bool>(
                                builder: (context, isFormValid) {
                                  return BlocConsumer<LoginBloc, LoginBlocState>(
                                    listener: (context, state) async {
                                      if (state is LoginFailure) {
                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(content: Text(state.error)),
                                        );
                                      }
                                      if (state is LoginSuccess) {
                                        FocusScope.of(context).unfocus();
                                        final user = state.user;
                                        final sessionStorage =
                                            context.read<SessionStorage>();
                                        final graceStorage =
                                            context.read<VerificationGraceStorage>();
                                        await sessionStorage.storeRole(
                                          user.uid,
                                          user.role,
                                        );
                                        if (!user.isVerified) {
                                          if (user.graceDeadline != null) {
                                            await graceStorage.saveDeadline(
                                              user.uid,
                                              user.graceDeadline!,
                                            );
                                          } else {
                                            await graceStorage.clearDeadline(user.uid);
                                          }
                                          if (user.graceUsed) {
                                            await graceStorage.markGraceUsed(user.uid);
                                          } else {
                                            await graceStorage.clearGraceUsage(user.uid);
                                          }
                                        }
                                        if (!context.mounted) return;
                                        final targetRoute =
                                            user.isVerified
                                                ? (isAdminRole(user.role)
                                                    ? AppRoutes.admin
                                                    : AppRoutes.home)
                                                : AuthRoutes.emailVerification;
                                        Navigator.pushNamedAndRemoveUntil(
                                          context,
                                          targetRoute,
                                          (route) => false,
                                          arguments:
                                              user.isVerified
                                                  ? null
                                                  : EmailVerificationPageArguments(
                                                      user: user,
                                                    ),
                                        );
                                      }
                                    },
                                    builder: (context, state) {
                                      final busy = state is LoginLoading;
                                      return PrimaryButton(
                                        text: busy ? 'Ingresando...' : 'Iniciar sesiÃ³n',
                                        onPressed: (isFormValid && !busy)
                                            ? submitIfValid
                                            : null,
                                      );
                                    },
                                  );
                                },
                              ),

                              const SizedBox(height: 32),
                              const Center(
                                child: Text(
                                  'Tu informaciÃ³n estÃ¡ protegida.',
                                  textAlign: TextAlign.center,
                                  style: TextStyle(
                                    color: Colors.white70,
                                    fontSize: 12,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // Back flotante
            const Positioned(
              top: 16,
              left: 16,
              child: SafeArea(
                child: AppBackButton(
                  popToRoute: AuthRoutes.welcome,
                  forceToRoute: true,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

------ END FILE: modules/features/auth/presentation/pages/login_page.dart ------

------- FILE: modules/features/auth/presentation/pages/register_page.dart ------
// lib/modules/features/auth/presentation/pages/register_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/config/app_theme.dart';
import '../../../../core/utils/navigation/back_navigator.dart';
import '../../../../core/widgets/layout/app_back_button.dart';
import '../../auth_routes.dart';
import '../blocs/register_bloc.dart';
import '../blocs/register_cubit.dart';
import '../../../../core/widgets/feedback/step_indicator.dart';
import '../widgets/forms/register_form_step1.dart';
import '../widgets/forms/register_form_step2.dart';
import '../widgets/common/success_dialog.dart';

class RegisterPage extends StatelessWidget {
  final String role;
  const RegisterPage({super.key, required this.role});

  String getRoleLabel() {
    if (role == 'client') return 'Cliente';
    if (role == 'entrepreneur' || role == 'emprendedora') return 'Emprendedora';
    return role;
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider(create: (_) => RegisterCubit(role: role)),
        BlocProvider.value(value: context.read<RegisterBloc>()),
      ],
      child: BlocListener<RegisterBloc, RegisterBlocState>(
        listener: (context, state) {
          if (state is RegisterSuccess) {
            showDialog(
              context: context,
              builder: (_) => SuccessDialog(role: role),
            );
          } else if (state is RegisterFailure) {
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(SnackBar(content: Text(state.error)));
          }
        },
        child: BlocBuilder<RegisterCubit, RegisterCubitState>(
          builder: (context, cubitState) {
            final cubit = context.read<RegisterCubit>();

            return PopScope(
              canPop: false, // control total
              onPopInvokedWithResult: (didPop, result) async {
                if (didPop) return; // â evita recursiÃ³n
                // intercept de pasos
                if (cubit.state.step == 2) {
                  cubit.goToStep1();
                  return;
                }
                await handleBack(
                  context,
                  popToRoute: AuthRoutes.roleSelection,
                  useMaybePop: false,
                  //forceToRoute: false,
                );
              },

              child: Scaffold(
                resizeToAvoidBottomInset: true,
                body: Container(
                  decoration: const BoxDecoration(
                    gradient: LinearGradient(
                      colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                    ),
                  ),
                  child: SafeArea(
                    child: Column(
                      children: [
                        const SizedBox(height: 8),
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 24),
                          child: Row(
                            children: [
                              AppBackButton(
                                popToRoute: AuthRoutes.roleSelection,
                                intercept: () {
                                  final cubit = context.read<RegisterCubit>();
                                  if (cubit.state.step == 2) {
                                    cubit.goToStep1();
                                    return true;
                                  }
                                  return false;
                                },
                              ),
                            ],
                          ),
                        ),
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 24),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'RegistrÃ¡ndote como: ${getRoleLabel()}',
                                style: const TextStyle(
                                  color: AppTheme.white,
                                  fontWeight: FontWeight.bold,
                                  fontSize: 16,
                                ),
                              ),
                              const SizedBox(height: 8),
                              Text(
                                cubitState.step == 1
                                    ? 'Paso 1: Crear tu cuenta'
                                    : 'Paso 2: Completar tu perfil',
                                style: const TextStyle(
                                  color: AppTheme.white,
                                  fontWeight: FontWeight.bold,
                                  fontSize: 20,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                cubitState.step == 1
                                    ? 'Solo pediremos lo necesario para crear tu cuenta.'
                                    : 'Completa tu perfil para disfrutar mejor la plataforma.',
                                style: const TextStyle(
                                  color: Colors.white70,
                                  fontSize: 14,
                                ),
                              ),
                              const SizedBox(height: 16),
                              StepIndicator(
                                currentStep: cubitState.step,
                                totalSteps: 2,
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 8),
                        Expanded(
                          child: LayoutBuilder(
                            builder: (context, constraints) {
                              return SingleChildScrollView( 
                                padding: EdgeInsets.only(
                                  left: 24,
                                  right: 24,
                                  bottom:
                                      MediaQuery.of(context).viewInsets.bottom +
                                      20,
                                ),
                                child: ConstrainedBox(
                                  constraints: BoxConstraints(
                                    minHeight: constraints.maxHeight,
                                  ),
                                  child: IntrinsicHeight(
                                    child:
                                        cubitState.step == 1
                                            ? RegisterFormStep1(role: role)
                                            : RegisterFormStep2(role: role),
                                  ),
                                ),
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

----- END FILE: modules/features/auth/presentation/pages/register_page.dart ----

---- FILE: modules/features/auth/presentation/pages/role_selection_page.dart ---
// lib/modules/features/auth/presentation/pages/role_selection_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/config/app_routes.dart';
import '../../auth_routes.dart';
import '../../../../core/widgets/layout/app_back_button.dart';
import '../../../../core/widgets/layout/app_logo.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../blocs/role_selection_cubit.dart';
import '../widgets/common/role_button.dart';

class RoleSelectionPage extends StatelessWidget {
  const RoleSelectionPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocListener<RoleSelectionCubit, RoleSelectionState>(
      listener: (context, state) {
        if (state.error != null) {
          ScaffoldMessenger.of(context,
          ).showSnackBar(SnackBar(content: Text(state.error!)));
        }
        if (state.continueToRegister && state.selectedRole != UserRole.admin) {
          Navigator.pushNamed(
            context,
            AppRoutes.register,
            arguments: state.selectedRole.name,
          );
        } else if (state.continueToRegister &&
            state.selectedRole == UserRole.admin) {
          Navigator.pushNamed(context, AppRoutes.accessRequest);
        }
      },
      child: Scaffold(
        extendBody: true,
        body: Stack(
          children: [
            Container(
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                ),
              ),
              child: SafeArea(
                child: LayoutBuilder(
                  builder: (context, constraints) {
                    return SingleChildScrollView(
                      physics: const ClampingScrollPhysics(),
                      child: ConstrainedBox(
                        constraints: BoxConstraints(
                          minHeight: constraints.maxHeight,
                        ),
                        child: IntrinsicHeight(
                          child: Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 32.0,
                              vertical: 24,
                            ),
                            child: Column(
                              children: [
                                const SizedBox(height: 40),
                                const AppLogo(size: 119),
                                const SizedBox(height: 24),
                                const Text(
                                  'Â¿CÃ³mo deseas unirte a la plataforma?',
                                  style: TextStyle(
                                    color: AppTheme.white,
                                    fontSize: 22,
                                    fontWeight: FontWeight.bold,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 40),
                                BlocBuilder<
                                  RoleSelectionCubit,
                                  RoleSelectionState
                                >(
                                  builder: (context, state) {
                                    return Column(
                                      children: [
                                        RoleButton(
                                          icon: Icons.storefront,
                                          title: 'Soy emprendedora',
                                          subtitle:
                                              '(Quiero vender y comprar productos)',
                                          selected:
                                              state.selectedRole ==
                                              UserRole.entrepreneur,
                                          color: AppTheme.blue,
                                          onTap: () {
                                            context
                                                .read<RoleSelectionCubit>()
                                                .selectRole(
                                                  UserRole.entrepreneur,
                                                );
                                          },
                                        ),
                                        const SizedBox(height: 20),
                                        RoleButton(
                                          icon: Icons.shopping_bag,
                                          title: 'Soy cliente',
                                          subtitle:
                                              '(Quiero comprar productos al detalle)',
                                          selected:
                                              state.selectedRole ==
                                              UserRole.client,
                                          color: AppTheme.purpleDark,
                                          onTap: () {
                                            context
                                                .read<RoleSelectionCubit>()
                                                .selectRole(UserRole.client);
                                          },
                                        ),
                                      ],
                                    );
                                  },
                                ),
                                const SizedBox(height: 30),
                                TextButton(
                                  onPressed: () {
                                    context
                                        .read<RoleSelectionCubit>()
                                        .selectRole(UserRole.admin);
                                    context
                                        .read<RoleSelectionCubit>()
                                        .continueToRegister();
                                  },
                                  child: const Text(
                                    'Â¿Eres parte del equipo?',
                                    style: TextStyle(color: AppTheme.white),
                                  ),
                                ),
                                const Spacer(),
                                BlocBuilder<
                                  RoleSelectionCubit,
                                  RoleSelectionState
                                >(
                                  builder: (context, state) {
                                    final isEnabled =
                                        state.selectedRole != UserRole.none;
                                    return PrimaryButton(
                                      text: 'Continuar',
                                      onPressed:
                                          isEnabled
                                              ? () {
                                                context
                                                    .read<RoleSelectionCubit>()
                                                    .continueToRegister();
                                              }
                                              : null,
                                    );
                                  },
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
            // â BotÃ³n de volver atrÃ¡s flotante sin AppBar
            Positioned(
              top: 16,
              left: 16,
              child: const SafeArea(
                child: AppBackButton(
                  popToRoute: AuthRoutes.welcome,
                  forceToRoute: true,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

-- END FILE: modules/features/auth/presentation/pages/role_selection_page.dart -

------- FILE: modules/features/auth/presentation/pages/welcome_page.dart -------
// modules/features/auth/presentation/pages/welcome_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/config/app_routes.dart';
import '../../../../core/widgets/settings_dialog.dart';
import '../../../../core/widgets/layout/app_logo.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../blocs/welcome_cubit.dart';

class WelcomePage extends StatefulWidget {
  const WelcomePage({super.key});

  @override
  State<WelcomePage> createState() => _WelcomePageState();
}

class _WelcomePageState extends State<WelcomePage> {
  @override
  Widget build(BuildContext context) {
    return BlocListener<WelcomeCubit, WelcomeState>(
      listener: (context, state) {
        // Siempre soltamos el foco justo antes de navegar.
        FocusScope.of(context).unfocus();

        if (state is ContinueAsGuest) {
          context.read<WelcomeCubit>().reset();
          Navigator.pushNamedAndRemoveUntil(
            context,
            AppRoutes.home,
            (_) => false,
          );
        } else if (state is GoToRegister) {
          context.read<WelcomeCubit>().reset();
          Navigator.pushReplacementNamed(context, AppRoutes.roleSelection);
        } else if (state is GoToLogin) {
          context.read<WelcomeCubit>().reset();
          Navigator.pushReplacementNamed(context, AppRoutes.login);
        }
      },

      child: MediaQuery.removeViewInsets(
        context: context,
        removeBottom: true,
        child: Scaffold(
          resizeToAvoidBottomInset: false,
          body: Stack(
            children: [
              Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  ),
                ),
                width: double.infinity,
                child: SafeArea(
                  bottom: false,
                  child: LayoutBuilder(
                    builder: (context, constraints) {
                      return SingleChildScrollView(
                        padding: const EdgeInsets.symmetric(horizontal: 32),
                        physics: const ClampingScrollPhysics(),
                        child: ConstrainedBox(
                          constraints: BoxConstraints(
                            minHeight: constraints.maxHeight,
                          ),
                          child: Center(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const SizedBox(height: 16),
                                const AppLogo(size: 180),
                                const SizedBox(height: 20),
                                const Text(
                                  'Gestiona tu emprendimiento',
                                  textAlign: TextAlign.center,
                                  style: TextStyle(
                                    color: AppTheme.white,
                                    fontSize: 28,
                                    fontWeight: FontWeight.w800,
                                    height: 1.15,
                                  ),
                                ),
                                const SizedBox(height: 8),
                                const Text(
                                  'Pedidos y control de forma fÃ¡cil y rÃ¡pida.',
                                  style: TextStyle(
                                    color: AppTheme.white,
                                    fontSize: 16,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 40),
                                PrimaryButton(
                                  text: 'Registrarse',
                                  variant: PrimaryButtonVariant.modern,
                                  onPressed:
                                      () =>
                                          context
                                              .read<WelcomeCubit>()
                                              .goToRegister(),
                                ),
                                const SizedBox(height: 16),
                                SizedBox(
                                  width: double.infinity,
                                  child: ElevatedButton(
                                    onPressed:
                                        () =>
                                            context
                                                .read<WelcomeCubit>()
                                                .goToLogin(),
                                    style: ElevatedButton.styleFrom(
                                      backgroundColor: AppTheme.white.withAlpha(
                                        (0.3 * 255).round(),
                                      ),
                                      foregroundColor: AppTheme.white,
                                      padding: const EdgeInsets.symmetric(
                                        vertical: 16,
                                      ),
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(32),
                                      ),
                                      textStyle: const TextStyle(
                                        fontWeight: FontWeight.bold,
                                      ),
                                    ),
                                    child: const Text('Iniciar sesiÃ³n'),
                                  ),
                                ),
                                const SizedBox(height: 16),
                                TextButton(
                                  onPressed:
                                      () =>
                                          context
                                              .read<WelcomeCubit>()
                                              .continueAsGuest(),
                                  child: const Text(
                                    'Continuar como visitante',
                                    style: TextStyle(
                                      color: AppTheme.white,
                                      fontSize: 16,
                                    ),
                                  ),
                                ),
                                const SizedBox(height: 16),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),
              const Positioned(top: 40, right: 20, child: SettingsButton()),
            ],
          ),
        ),
      ),
    );
  }
}

----- END FILE: modules/features/auth/presentation/pages/welcome_page.dart -----

Dentro de /widgets:

----- FILE: modules/features/auth/presentation/widgets/attachment_tile.dart ----
import 'package:flutter/material.dart';
import '../../domain/entities/access_request.dart';

class AttachmentTile extends StatelessWidget {
  final AttachmentEntity attachment;
  final VoidCallback onRemove;

  const AttachmentTile({
    super.key,
    required this.attachment,
    required this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    final isImage = attachment.contentType.startsWith('image/');
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(horizontal: 8),
      leading: CircleAvatar(
        backgroundColor: Colors.grey.shade200,
        backgroundImage: isImage ? NetworkImage(attachment.url) : null,
        child: isImage ? null : const Icon(Icons.insert_drive_file),
      ),
      title: Text(attachment.fileName, maxLines: 1, overflow: TextOverflow.ellipsis),
      subtitle: Text('${attachment.contentType} â¢ ${(attachment.size/1024).toStringAsFixed(0)} KB'),
      trailing: IconButton(icon: const Icon(Icons.close), onPressed: onRemove),
    );
  }
}

--- END FILE: modules/features/auth/presentation/widgets/attachment_tile.dart --

 FILE: modules/features/auth/presentation/widgets/email_verification_reminder_banner.dart 
import 'package:flutter/material.dart';

import '../../../../core/config/app_theme.dart';

class EmailVerificationReminderBanner extends StatelessWidget {
  final String contactLabel;
  final VoidCallback onVerify;
  final VoidCallback onDismiss;

  const EmailVerificationReminderBanner({
    super.key,
    required this.contactLabel,
    required this.onVerify,
    required this.onDismiss,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      elevation: 12,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        decoration: BoxDecoration(
          color: AppTheme.white,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Row(
          children: [
            const Icon(Icons.mark_email_unread_outlined, color: AppTheme.purpleMedium),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text(
                    'Verifica tu cuenta',
                    style: TextStyle(
                      fontWeight: FontWeight.w700,
                      color: AppTheme.purpleDark,
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'AÃºn falta confirmar $contactLabel. Hazlo para mantener el acceso.',
                    style: const TextStyle(fontSize: 13, color: Colors.black87),
                  ),
                  const SizedBox(height: 8),
                  TextButton(
                    onPressed: onVerify,
                    style: TextButton.styleFrom(
                      padding: EdgeInsets.zero,
                      foregroundColor: AppTheme.blue,
                    ),
                    child: const Text('Ir a verificar'),
                  ),
                ],
              ),
            ),
            IconButton(
              onPressed: onDismiss,
              icon: const Icon(Icons.close),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/email_verification_reminder_banner.dart 

Dentro de /access_request:

 FILE: modules/features/auth/presentation/widgets/access_request/invite_gate.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../../core/config/app_theme.dart';
import '../../blocs/access_request_cubit.dart';

class InviteGate extends StatefulWidget {
  const InviteGate({super.key});

  @override
  State<InviteGate> createState() => _InviteGateState();
}

class _InviteGateState extends State<InviteGate> {
  final _ctrl = TextEditingController();
  final _formKey = GlobalKey<FormState>();

  @override
  void dispose() {
    _ctrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final state = context.watch<AccessRequestCubit>().state;

    return Center(
      child: Card(
        margin: const EdgeInsets.all(24),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text('CÃ³digo de invitaciÃ³n',
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                const SizedBox(height: 12),
                TextFormField(
                  controller: _ctrl,
                  decoration: const InputDecoration(
                    labelText: 'Ingresa tu cÃ³digo',
                    border: OutlineInputBorder(),
                  ),
                  validator: (v) => (v == null || v.trim().length < 8)
                      ? 'CÃ³digo invÃ¡lido'
                      : null,
                ),
                const SizedBox(height: 8),
                if (state.error != null && !state.loading)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 4),
                    child: Text(
                      state.error!.replaceFirst('Exception: ', ''),
                      style: TextStyle(color: Theme.of(context).colorScheme.error),
                    ),
                  ),
                const SizedBox(height: 8),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.blue,
                      foregroundColor: AppTheme.white,
                    ),
                    onPressed: state.loading
                        ? null
                        : () {
                            if (!(_formKey.currentState?.validate() ?? false)) return;
                            context.read<AccessRequestCubit>().verifyInviteCode(_ctrl.text);
                          },
                    child: const Text('Verificar'),
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Este cÃ³digo te lo entrega el superadministrador.',
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/access_request/invite_gate.dart 

 FILE: modules/features/auth/presentation/widgets/access_request/status_card.dart 
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../blocs/access_request_cubit.dart';

class AccessStatusCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;

  const AccessStatusCard({
    super.key,
    required this.title,
    required this.subtitle,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Card(
        margin: const EdgeInsets.all(24),
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 48, color: AppTheme.purpleDark),
              const SizedBox(height: 12),
              Text(title, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Text(subtitle, textAlign: TextAlign.center),
              const SizedBox(height: 12),
              TextButton.icon(
                onPressed: () => context.read<AccessRequestCubit>().load(),
                icon: const Icon(Icons.refresh),
                label: const Text('Actualizar estado'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/access_request/status_card.dart 

Dentro de /admin_wizard:

 FILE: modules/features/auth/presentation/widgets/admin_wizard/admin_wizard.dart 
// lib/modules/features/auth/presentation/widgets/admin_wizard/admin_wizard.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../../core/config/app_theme.dart';
import '../../../../../core/widgets/feedback/step_indicator.dart';
import '../../../../../core/config/app_routes.dart';
import '../../blocs/access_request_cubit.dart';
import 'steps/admin_step_credentials.dart';
import 'steps/admin_step_security.dart';
import 'steps/admin_step_profile.dart';

/// Activa/desactiva el paso de MFA sin tocar la UI.
const bool kMfaStepEnabled = false;

class AdminWizard extends StatefulWidget {
  const AdminWizard({super.key});

  @override
  State<AdminWizard> createState() => _AdminWizardState();
}

class _AdminWizardState extends State<AdminWizard> {
  final PageController _page = PageController();
  int _step = 1;

  // Controladores compartidos entre pasos
  final emailCtrl = TextEditingController();
  final passCtrl = TextEditingController();
  final nameCtrl = TextEditingController();
  final phoneCtrl = TextEditingController();
  final docCtrl = TextEditingController();
  String docType = 'CÃ©dula';
  final addressCtrl = TextEditingController();

  bool _canNext = false;

  int get _totalSteps => kMfaStepEnabled ? 3 : 2;

  void _goto(int step) {
    setState(() => _step = step);
    _page.animateToPage(
      step - 1,
      duration: const Duration(milliseconds: 180),
      curve: Curves.easeOut,
    );
  }

  void _onValidityChanged(bool ok) {
    if (mounted) setState(() => _canNext = ok);
  }

  Future<void> _submit() async {
    await context.read<AccessRequestCubit>().createAccount(
          name: nameCtrl.text,
          idNumber: docCtrl.text,
          phone: phoneCtrl.text,
          email: emailCtrl.text.trim().isEmpty ? null : emailCtrl.text.trim(),
          address: addressCtrl.text,
          password: passCtrl.text,
        );
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Cuenta creada. Â¡Bienvenida/o!')),
    );
    Navigator.pushNamedAndRemoveUntil(
      context,
      AppRoutes.home,
      (_) => false,
    );
  }

  @override
  void dispose() {
    _page.dispose();
    emailCtrl.dispose();
    passCtrl.dispose();
    nameCtrl.dispose();
    phoneCtrl.dispose();
    docCtrl.dispose();
    addressCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final ime = MediaQuery.of(context).viewInsets.bottom;   // teclado + barra de voz
    final sysBottom = MediaQuery.of(context).padding.bottom; // barra gestual

    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
      ),
      child: SafeArea(
        bottom: false, // evitamos doble padding abajo
        child: Column(
          children: [
            // --- Encabezado (no se mueve con el teclado) ---
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Crear cuenta administrativa',
                    style: TextStyle(
                      color: AppTheme.white,
                      fontSize: 20,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  const SizedBox(height: 8),
                  StepIndicator(currentStep: _step, totalSteps: _totalSteps),
                  const SizedBox(height: 4),
                  Text(
                    _step == 1
                        ? 'Paso 1: Credenciales'
                        : (kMfaStepEnabled && _step == 2)
                            ? 'Paso 2: Seguridad'
                            : 'Paso $_totalSteps: Perfil',
                    style: const TextStyle(color: Colors.white70),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 8),

            // --- Contenido desplazable (se ajusta al IME) ---
            Expanded(
              child: LayoutBuilder(
                builder: (context, c) {
                  // Altura del PageView: adaptable al alto disponible
                  final pageHeight =
                      (c.maxHeight * 0.60).clamp(320.0, 480.0);

                  return SingleChildScrollView(
                    padding: EdgeInsets.fromLTRB(16, 12, 16, ime + 12),
                    keyboardDismissBehavior:
                        ScrollViewKeyboardDismissBehavior.onDrag,
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.white.withAlpha((0.92 * 255).round()),
                        borderRadius: BorderRadius.circular(16),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withAlpha(25),
                            blurRadius: 12,
                            offset: const Offset(0, 6),
                          ),
                        ],
                      ),
                      child: SizedBox(
                        height: pageHeight,
                        child: PageView(
                          controller: _page,
                          physics: const NeverScrollableScrollPhysics(),
                          children: [
                            AdminStepCredentials(
                              emailCtrl: emailCtrl,
                              passCtrl: passCtrl,
                              onValidityChanged: _onValidityChanged,
                            ),
                            if (kMfaStepEnabled)
                              AdminStepSecurity(
                                phoneCtrl: phoneCtrl,
                                onValidityChanged: _onValidityChanged,
                              ),
                            AdminStepProfile(
                              nameCtrl: nameCtrl,
                              phoneCtrl: phoneCtrl,
                              docCtrl: docCtrl,
                              onDocTypeChanged: (t) =>
                                  setState(() => docType = t ?? 'CÃ©dula'),
                              docType: docType,
                              addressCtrl: addressCtrl,
                              onValidityChanged: _onValidityChanged,
                            ),
                          ],
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),

            // --- Barra de acciones que flota sobre el teclado ---
            AnimatedContainer(
              duration: const Duration(milliseconds: 160),
              curve: Curves.easeOut,
              padding: EdgeInsets.fromLTRB(
                16,
                0,
                16,
                (ime > 0 ? ime : sysBottom) + 12,
              ),
              child: Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: _step == 1
                          ? () => Navigator.of(context).maybePop()
                          : () => _goto(_step - 1),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: AppTheme.white,
                        side: const BorderSide(color: AppTheme.white),
                        padding: const EdgeInsets.symmetric(vertical: 14),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      child: Text(_step == 1 ? 'Cancelar' : 'AtrÃ¡s'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: !_canNext
                          ? null
                          : () async {
                              final lastStep = _totalSteps;
                              if (_step < lastStep) {
                                _goto(_step + 1);
                              } else {
                                await _submit();
                              }
                            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: AppTheme.blue,
                        foregroundColor: AppTheme.white,
                        padding: const EdgeInsets.symmetric(vertical: 14),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      child: Text(_step < _totalSteps ? 'Siguiente' : 'Finalizar'),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/admin_wizard/admin_wizard.dart 

Dentro de /steps:

 FILE: modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_credentials.dart 
// lib/modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_credentials.dart
import 'package:flutter/material.dart';

class AdminStepCredentials extends StatefulWidget {
  final TextEditingController emailCtrl;
  final TextEditingController passCtrl;
  final ValueChanged<bool> onValidityChanged;

  const AdminStepCredentials({
    super.key,
    required this.emailCtrl,
    required this.passCtrl,
    required this.onValidityChanged,
  });

  @override
  State<AdminStepCredentials> createState() => _AdminStepCredentialsState();
}

class _AdminStepCredentialsState extends State<AdminStepCredentials> {
  final _form = GlobalKey<FormState>();

  bool _validate() {
    final ok = _form.currentState?.validate() ?? false;
    widget.onValidityChanged(ok);
    return ok;
  }

  @override
  void initState() {
    super.initState();
    // Emite estado inicial
    WidgetsBinding.instance.addPostFrameCallback((_) => _validate());
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _form,
        onChanged: () => _validate(),
        child: Column(
          children: [
            TextFormField(
              controller: widget.emailCtrl,
              keyboardType: TextInputType.emailAddress,
              decoration: const InputDecoration(
                labelText: 'Correo real (obligatorio)',
                hintText: 'nombre@empresa.com',
                border: OutlineInputBorder(),
              ),
              validator: (v) {
                final s = (v ?? '').trim();
                final rg = RegExp(r"^[\w\.\-]+@([\w\-]+\.)+[\w]{2,}$");
                if (!rg.hasMatch(s)) return 'Correo no vÃ¡lido';
                return null;
              },
            ),
            const SizedBox(height: 12),
            TextFormField(
              controller: widget.passCtrl,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'ContraseÃ±a',
                border: OutlineInputBorder(),
              ),
              validator: (v) {
                final s = (v ?? '').trim();
                if (s.length < 6) return 'MÃ­nimo 6 caracteres';
                return null;
              },
            ),
            const SizedBox(height: 8),
            const Text(
              'Usaremos tu correo para verificar la cuenta. Luego podrÃ¡s habilitar 2FA.',
              style: TextStyle(fontSize: 12, color: Colors.black54),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_credentials.dart 

 FILE: modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_profile.dart 
// lib/modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_profile.dart
import 'package:flutter/material.dart';
import '../../../widgets/common/register_field.dart';

class AdminStepProfile extends StatefulWidget {
  final TextEditingController nameCtrl;
  final TextEditingController phoneCtrl;
  final TextEditingController docCtrl;
  final String docType;
  final ValueChanged<String?> onDocTypeChanged;
  final TextEditingController addressCtrl;
  final ValueChanged<bool> onValidityChanged;

  const AdminStepProfile({
    super.key,
    required this.nameCtrl,
    required this.phoneCtrl,
    required this.docCtrl,
    required this.docType,
    required this.onDocTypeChanged,
    required this.addressCtrl,
    required this.onValidityChanged,
  });

  @override
  State<AdminStepProfile> createState() => _AdminStepProfileState();
}

class _AdminStepProfileState extends State<AdminStepProfile> {
  final _form = GlobalKey<FormState>();

  bool _validate() {
    final ok = _form.currentState?.validate() ?? false;
    widget.onValidityChanged(ok);
    return ok;
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _validate());
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _form,
        onChanged: () => _validate(),
        child: Column(
          children: [
            TextFormField(
              controller: widget.nameCtrl,
              decoration: const InputDecoration(
                labelText: 'Nombre completo',
                border: OutlineInputBorder(),
              ),
              validator: (v) => (v == null || v.trim().isEmpty) ? 'Obligatorio' : null,
            ),
            const SizedBox(height: 12),
            TextFormField(
              controller: widget.phoneCtrl,
              keyboardType: TextInputType.phone,
              decoration: const InputDecoration(
                labelText: 'TelÃ©fono (recomendado)',
                border: OutlineInputBorder(),
              ),
              // opcional pero valida si se llena
              validator: (v) {
                final s = (v ?? '').trim();
                if (s.isEmpty) return null;
                if (s.length < 9) return 'TelÃ©fono no vÃ¡lido';
                return null;
              },
            ),
            const SizedBox(height: 12),
            // Documento OPCIONAL
            RegisterField(
              controller: widget.docCtrl,
              label: 'Documento (opcional)',
              isDocumentField: true,
              selectedDocumentType: widget.docType,
              onDocumentTypeChanged: widget.onDocTypeChanged,
              onChanged: (_) => _validate(),
            ),
            const SizedBox(height: 12),
            TextFormField(
              controller: widget.addressCtrl,
              decoration: const InputDecoration(
                labelText: 'DirecciÃ³n (opcional)',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'Puedes completar o editar esta informaciÃ³n en tu perfil cuando quieras.',
              style: TextStyle(fontSize: 12, color: Colors.black54),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_profile.dart 

 FILE: modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_security.dart 
// lib/modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_security.dart
import 'package:flutter/material.dart';

class AdminStepSecurity extends StatefulWidget {
  final TextEditingController phoneCtrl;
  final ValueChanged<bool> onValidityChanged;

  const AdminStepSecurity({
    super.key,
    required this.phoneCtrl,
    required this.onValidityChanged,
  });

  @override
  State<AdminStepSecurity> createState() => _AdminStepSecurityState();
}

class _AdminStepSecurityState extends State<AdminStepSecurity> {
  final _form = GlobalKey<FormState>();
  bool _useSms = true; // ejemplo: SMS o TOTP

  bool _validate() {
    // Si usas SMS, pide telÃ©fono; si TOTP, no
    final ok = !_useSms || (_form.currentState?.validate() ?? false);
    widget.onValidityChanged(ok);
    return ok;
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _validate());
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _form,
        onChanged: () => _validate(),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Seguridad y 2FA', style: TextStyle(fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            SwitchListTile(
              value: _useSms,
              title: const Text('Usar SMS para 2FA'),
              subtitle: const Text('Si lo desactivas, luego podrÃ¡s configurar TOTP (Google Authenticator).'),
              onChanged: (v) {
                setState(() => _useSms = v);
                _validate();
              },
            ),
            if (_useSms) ...[
              const SizedBox(height: 8),
              TextFormField(
                controller: widget.phoneCtrl,
                keyboardType: TextInputType.phone,
                decoration: const InputDecoration(
                  labelText: 'TelÃ©fono (para 2FA por SMS)',
                  border: OutlineInputBorder(),
                ),
                validator: (v) {
                  final s = (v ?? '').trim();
                  if (s.length < 9) return 'TelÃ©fono no vÃ¡lido';
                  return null;
                },
              ),
            ],
            const SizedBox(height: 8),
            const Text(
              'Este paso es opcional por ahora; cuando se active la 2FA obligatoria, el asistente te lo pedirÃ¡ aquÃ­.',
              style: TextStyle(fontSize: 12, color: Colors.black54),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/admin_wizard/steps/admin_step_security.dart 

Dentro de /common:

-- FILE: modules/features/auth/presentation/widgets/common/auth_form_card.dart -
import 'package:flutter/material.dart';

class AuthFormCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets padding;
  const AuthFormCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(16),
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white.withAlpha((0.92 * 255).round()),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha(25),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Padding(padding: padding, child: child),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/common/auth_form_card.dart 

-- FILE: modules/features/auth/presentation/widgets/common/document_field.dart -
// lib/modules/features/auth/presentation/widgets/common/document_field.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:ec_validations/ec_validations.dart';

class DocumentField extends StatefulWidget {
  final TextEditingController controller;
  final String? selectedType;
  final ValueChanged<String?> onTypeChanged;
  final ValueChanged<String>? onChanged;

  const DocumentField({
    super.key,
    required this.controller,
    required this.selectedType,
    required this.onTypeChanged,
    this.onChanged,
  });

  @override
  State<DocumentField> createState() => _DocumentFieldState();
}

class _DocumentFieldState extends State<DocumentField> {
  final _fieldKey = GlobalKey<FormFieldState>();

  String? getError(String? value) {
    final trimmed = value?.trim() ?? '';
    if (trimmed.isEmpty) return 'Este campo es obligatorio';

    if (widget.selectedType == 'CÃ©dula') {
      final result = DniValidator.isValid(trimmed);
      return result.isValid ? null : result.errorMessage;
    }
    if (widget.selectedType == 'RUC') {
      final result = RucValidator.validateRuc(trimmed);
      return result.isValid ? null : result.errorMessage;
    }
    if (widget.selectedType == 'Pasaporte') {
      return trimmed.length >= 5 ? null : 'Pasaporte invÃ¡lido';
    }
    return null;
  }

  int? getMaxLength() {
    switch (widget.selectedType) {
      case 'CÃ©dula':
        return 10;
      case 'RUC':
        return 13;
      case 'Pasaporte':
        return 20;
      default:
        return null;
    }
  }

  void _handleTypeChanged(String? newType) {
    widget.controller.clear();
    widget.onTypeChanged(newType);
    _fieldKey.currentState?.reset();
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: TextFormField(
        key: _fieldKey,
        controller: widget.controller,
        keyboardType: widget.selectedType != 'Pasaporte'
            ? TextInputType.number
            : TextInputType.text,
        inputFormatters: widget.selectedType != 'Pasaporte'
            ? [FilteringTextInputFormatter.digitsOnly]
            : [],
        maxLength: getMaxLength(),
        autovalidateMode: AutovalidateMode.onUserInteraction,
        onChanged: (val) {
          widget.onChanged?.call(val);
          _fieldKey.currentState?.validate();
        },
        validator: getError,
        decoration: InputDecoration(
          labelText: 'Documento de Identidad',
          filled: true,
          fillColor: Colors.white.withAlpha((0.3 * 255).round()),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
          counterText: '',
          helperText: ' ', // espacio reservado siempre
          helperStyle: const TextStyle(height: 1.2, fontSize: 12),
          errorStyle: TextStyle(
            height: 1.2,
            fontSize: 12,
            color: Theme.of(context).colorScheme.error,
          ),
          prefixIcon: Padding(
            padding: const EdgeInsets.only(left: 12, right: 4),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: widget.selectedType,
                isDense: true,
                items: const [
                  DropdownMenuItem(value: 'CÃ©dula', child: Text('CÃ©dula')),
                  DropdownMenuItem(value: 'RUC', child: Text('RUC')),
                  DropdownMenuItem(value: 'Pasaporte', child: Text('Pasaporte')),
                ],
                onChanged: _handleTypeChanged,
                icon: const Icon(Icons.arrow_drop_down),
              ),
            ),
          ),
          prefixIconConstraints: const BoxConstraints(minWidth: 100),
          contentPadding: const EdgeInsets.symmetric(vertical: 20, horizontal: 12),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/common/document_field.dart 

-- FILE: modules/features/auth/presentation/widgets/common/register_field.dart -
// lib/modules/features/auth/presentation/widgets/common/register_field.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// Campo de documento ya existente
import 'document_field.dart';

// Reutilizamos el mismo PasswordField del login (con ojito + long-press)
import 'package:flutter_application_emprendedoras/modules/core/widgets/inputs/password_field.dart';

class RegisterField extends StatefulWidget {
  final TextEditingController controller;
  final String label;

  /// Si es true, se muestra el campo de contraseÃ±a con âojitoâ
  final bool isPassword;

  /// Enfocar automÃ¡ticamente
  final bool autofocus;

  /// Si el campo es opcional (solo afecta validaciÃ³n de este widget)
  final bool isOptional;

  /// Fuerza teclado numÃ©rico + dÃ­gitos
  final bool isNumber;

  /// Notifica cambios al padre (Ãºtil para habilitar botones)
  final ValueChanged<String>? onChanged;

  /// ---- Documento de identidad ----
  final bool isDocumentField;
  final String selectedDocumentType;
  final ValueChanged<String?>? onDocumentTypeChanged;

  const RegisterField({
    super.key,
    required this.controller,
    required this.label,
    this.isPassword = false,
    this.autofocus = false,
    this.isOptional = false,
    this.isNumber = false,
    this.onChanged,
    this.isDocumentField = false,
    this.selectedDocumentType = 'CÃ©dula',
    this.onDocumentTypeChanged,
  });

  @override
  State<RegisterField> createState() => _RegisterFieldState();
}

class _RegisterFieldState extends State<RegisterField> {
  final _fieldKey = GlobalKey<FormFieldState>();
  FocusNode? _focusNode;

  @override
  void initState() {
    super.initState();
    if (!widget.isDocumentField && !widget.isPassword) {
      _focusNode = FocusNode();
      _focusNode?.addListener(_handleFocusChange);
    }
  }

  @override
  void dispose() {
    _focusNode?.removeListener(_handleFocusChange);
    _focusNode?.dispose();
    super.dispose();
  }

  void _handleFocusChange() {
    if (_focusNode?.hasFocus == false) {
      try {
        _fieldKey.currentState?.validate();
      } catch (_) {
        // no-op
      }
    }
  }

  // ---------- Validaciones simples y locales ----------
  String? _validate(String? value) {
    final trimmed = value?.trim() ?? '';
    if (!widget.isOptional && trimmed.isEmpty) {
      return 'Este campo es obligatorio';
    }

    final lower = widget.label.toLowerCase();

    // Email
    if (lower.contains('correo') && trimmed.isNotEmpty) {
      final emailRegex =
          RegExp(r"^[\w\.\-]+@([\w\-]+\.)+[\w]{2,}$", caseSensitive: false);
      if (!emailRegex.hasMatch(trimmed)) {
        return 'Correo no vÃ¡lido';
      }
    }

    // TelÃ©fono
    if (lower.contains('telÃ©fono') && trimmed.isNotEmpty && trimmed.length < 9) {
      return 'TelÃ©fono no vÃ¡lido';
    }

    // Password
    if (widget.isPassword && trimmed.isNotEmpty && trimmed.length < 6) {
      return 'ContraseÃ±a invÃ¡lida';
    }

    return null;
  }

  int? _maxLength() {
    final lower = widget.label.toLowerCase();
    if (lower.contains('telÃ©fono')) return 10;
    if (lower.contains('correo')) return 320;
    if (widget.isPassword) return 64;
    return null;
  }

  @override
  Widget build(BuildContext context) {
    // 1) Campo de Documento (con dropdown integrado)
    if (widget.isDocumentField) {
      return DocumentField(
        controller: widget.controller,
        selectedType: widget.selectedDocumentType,
        onTypeChanged: widget.onDocumentTypeChanged ?? (_) {},
        onChanged: (s) {
          widget.onChanged?.call(s);
          _fieldKey.currentState?.validate();
        },
      );
    }

    // 2) Campo de ContraseÃ±a: usar el mismo componente del login
    if (widget.isPassword) {
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 4),
        child: PasswordField(
          controller: widget.controller,
          labelText: widget.label,
          validator: _validate,
          onChanged: (s) {
            widget.onChanged?.call(s);
            // PasswordField ya re-oculta al tipear; no necesitamos forzar validate aquÃ­
          },
          textInputAction: TextInputAction.next,
        ),
      );
    }

    // 3) Texto normal (nombre, correo, telÃ©fono, direcciÃ³n, etc.)
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: TextFormField(
        key: _fieldKey,
        focusNode: _focusNode,
        controller: widget.controller,
        autofocus: widget.autofocus,
        keyboardType:
            widget.isNumber ? TextInputType.number : TextInputType.text,
        inputFormatters:
            widget.isNumber ? [FilteringTextInputFormatter.digitsOnly] : [],
        maxLength: _maxLength(),
        autovalidateMode: AutovalidateMode.disabled, // valida al perder foco
        onChanged: (s) {
          widget.onChanged?.call(s);
          // validamos âsoftâ solo si ya perdiÃ³ foco; aquÃ­ no molestamos
        },
        validator: _validate,
        decoration: InputDecoration(
          labelText: widget.label + (widget.isOptional ? ' (opcional)' : ''),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
          filled: true,
          isDense: true,
          // Mismo look que âUsuarioâ en login: blanco con ~30% de opacidad.
          // Si tu SDK no tiene withValues, usa withOpacity(0.30).
          fillColor: Colors.white.withAlpha((0.30 * 255).round()),
          counterText: '',
          contentPadding:
              const EdgeInsets.symmetric(vertical: 16, horizontal: 12),
        ),
        textInputAction: TextInputAction.next,
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/common/register_field.dart 

--- FILE: modules/features/auth/presentation/widgets/common/role_button.dart ---
// features/auth/presentation/widgets/role_button.dart
import 'package:flutter/material.dart';

class RoleButton extends StatelessWidget {
  final IconData icon;
  final String title;
  final String subtitle;
  final bool selected;
  final VoidCallback onTap;
  final Color color;

  const RoleButton({
    super.key,
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.onTap,
    this.selected = false,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent, // O usa selected ? color : algo
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(32),
        child: Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 24),
          decoration: BoxDecoration(
            color: selected ? color : Colors.white.withAlpha((0.2 * 255).round()),
            borderRadius: BorderRadius.circular(32),
          ),
          child: Row(
            children: [
              Icon(icon, color: Colors.white, size: 36),
              const SizedBox(width: 20),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      subtitle,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


- END FILE: modules/features/auth/presentation/widgets/common/role_button.dart -

-- FILE: modules/features/auth/presentation/widgets/common/success_dialog.dart -
import 'package:flutter/material.dart';
import '../../../../../core/config/app_routes.dart';

class SuccessDialog extends StatelessWidget {
  final String role;

  const SuccessDialog({super.key, required this.role});

  @override
  Widget build(BuildContext context) {
    final isClient = role == 'client' || role == 'cliente';
    final title = isClient ? 'Â¡Bienvenido/a!' : 'Â¡Registro enviado!';
    final message =
        isClient
            ? 'Tu cuenta estÃ¡ lista. Empieza a explorar nuestros productos.'
            : 'Tu solicitud como Emprendedora estÃ¡ pendiente de aprobaciÃ³n. Mientras tanto, puedes realizar pedidos como Cliente.';
    final buttonText = isClient ? 'Ir al catÃ¡logo' : 'Ver catÃ¡logo';

    return AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        TextButton(
          child: Text(buttonText),
          onPressed: () {
            Navigator.of(
              context,
              rootNavigator: true,
            ).pushNamedAndRemoveUntil(AppRoutes.home, (route) => false);
          },
        ),
      ],
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/common/success_dialog.dart 

Dentro de /forms:

 FILE: modules/features/auth/presentation/widgets/forms/access_request_form.dart 
import 'dart:typed_data';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:mime/mime.dart';

import '../../../../../core/config/app_theme.dart';
import '../../../domain/entities/access_request.dart';
import '../../blocs/access_request_cubit.dart';
import '../attachment_tile.dart';

class AccessRequestForm extends StatefulWidget {
  const AccessRequestForm({super.key});

  @override
  State<AccessRequestForm> createState() => _AccessRequestFormState();
}

class _AccessRequestFormState extends State<AccessRequestForm> {
  final _formKey = GlobalKey<FormState>();
  final _nameCtrl = TextEditingController();
  final _idCtrl = TextEditingController();
  final _positionCtrl = TextEditingController();
  final _motiveCtrl = TextEditingController();

  final List<AttachmentEntity> _attachments = [];
  bool _submitting = false;

  @override
  void dispose() {
    _nameCtrl.dispose();
    _idCtrl.dispose();
    _positionCtrl.dispose();
    _motiveCtrl.dispose();
    super.dispose();
  }

  Future<void> _pickAndUpload() async {
    final cubit = context.read<AccessRequestCubit>();
    try {
      final res = await FilePicker.platform.pickFiles(
        withData: true, // nos da bytes
        allowMultiple: false,
        type: FileType.custom,
        allowedExtensions: ['jpg','jpeg','png','pdf'], // client-side guard
      );
      if (res == null || res.files.isEmpty) return;

      final f = res.files.first;
      final Uint8List? bytes = f.bytes;
      if (bytes == null) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No se pudo leer el archivo')),
        );
        return;
      }

      final name = f.name;
      final guessed = lookupMimeType(name, headerBytes: bytes);
      final contentType = guessed ??
        (name.toLowerCase().endsWith('.pdf') ? 'application/pdf' : 'application/octet-stream');

      // -> subcarpeta por usuario/solicitud
      final att = await cubit.uploadAttachment(
        bytes: bytes,
        fileName: name,
        contentType: contentType,
      );
      if (!mounted) return;
      setState(() => _attachments.add(att));
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error subiendo archivo: $e')),
      );
    }
  }

  Future<void> _submit() async {
    if (!(_formKey.currentState?.validate() ?? false)) return;
    if (_submitting) return;
    setState(() => _submitting = true);

    try {
      await context.read<AccessRequestCubit>().submit(
        name: _nameCtrl.text,
        idNumber: _idCtrl.text,
        position: _positionCtrl.text,
        motive: _motiveCtrl.text,
        attachments: _attachments,
      );
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Solicitud enviada')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('No se pudo enviar: $e')),
      );
    } finally {
      if (mounted) setState(() => _submitting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
      ),
      child: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Form(
                key: _formKey,
                child: Column(
                  children: [
                    const Text('Solicitud de acceso administrativo',
                        style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                    const SizedBox(height: 16),
                    _TextField(
                      controller: _nameCtrl,
                      label: 'Nombre completo',
                      validator: (v) => (v==null || v.trim().isEmpty) ? 'Obligatorio' : null,
                    ),
                    _TextField(
                      controller: _idCtrl,
                      label: 'CÃ©dula/RUC/Pasaporte',
                      validator: (v) => (v==null || v.trim().isEmpty) ? 'Obligatorio' : null,
                    ),
                    _TextField(
                      controller: _positionCtrl,
                      label: 'Cargo (ej. administradora regional)',
                      validator: (v) => (v==null || v.trim().isEmpty) ? 'Obligatorio' : null,
                    ),
                    _TextField(
                      controller: _motiveCtrl,
                      label: 'Motivo',
                      maxLines: 3,
                      validator: (v) => (v==null || v.trim().length < 10) ? 'Describe al menos 10 caracteres' : null,
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        ElevatedButton.icon(
                          onPressed: _attachments.length >= 5 ? null : _pickAndUpload,
                          icon: const Icon(Icons.attach_file),
                          label: const Text('Adjuntar (jpg/png/pdf)'),
                        ),
                        const SizedBox(width: 8),
                        Text('${_attachments.length}/5'),
                        const Spacer(),
                        if (_submitting) const CircularProgressIndicator.adaptive(),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Column(
                      children: _attachments.map((a) => AttachmentTile(
                        attachment: a,
                        onRemove: () => setState(() => _attachments.remove(a)),
                      )).toList(),
                    ),
                    const SizedBox(height: 12),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: _submitting ? null : _submit,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppTheme.blue,
                          foregroundColor: AppTheme.white,
                          padding: const EdgeInsets.symmetric(vertical: 14),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                        child: const Text('Enviar solicitud', style: TextStyle(fontWeight: FontWeight.bold)),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _TextField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String? Function(String?)? validator;
  final int maxLines;

  const _TextField({
    required this.controller,
    required this.label,
    this.validator,
    this.maxLines = 1,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: TextFormField(
        controller: controller,
        validator: validator,
        maxLines: maxLines,
        decoration: InputDecoration(
          labelText: label,
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/forms/access_request_form.dart 

 FILE: modules/features/auth/presentation/widgets/forms/admin_account_form.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../../core/config/app_theme.dart';
import '../../../../../core/config/app_routes.dart';
import '../../blocs/access_request_cubit.dart';
import '../common/register_field.dart';

class AdminAccountForm extends StatefulWidget {
  const AdminAccountForm({super.key});

  @override
  State<AdminAccountForm> createState() => _AdminAccountFormState();
}

class _AdminAccountFormState extends State<AdminAccountForm> {
  final _formKey = GlobalKey<FormState>();

  final _docCtrl = TextEditingController();
  String _docType = 'CÃ©dula';
  final _phoneCtrl = TextEditingController();
  final _emailCtrl = TextEditingController();
  final _passwordCtrl = TextEditingController();

  final _nameCtrl = TextEditingController();
  final _addressCtrl = TextEditingController();

  bool _submitting = false;

  @override
  void dispose() {
    _docCtrl.dispose();
    _phoneCtrl.dispose();
    _emailCtrl.dispose();
    _passwordCtrl.dispose();
    _nameCtrl.dispose();
    _addressCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!(_formKey.currentState?.validate() ?? false)) return;
    if (_submitting) return;
    setState(() => _submitting = true);

    try {
      await context.read<AccessRequestCubit>().createAccount(
        name: _nameCtrl.text,
        idNumber: _docCtrl.text,
        phone: _phoneCtrl.text,
        email: _emailCtrl.text.isEmpty ? null : _emailCtrl.text,
        address: _addressCtrl.text,
        password: _passwordCtrl.text,
      );
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Cuenta creada. Â¡Bienvenida/o!')),
      );
      Navigator.pushNamedAndRemoveUntil(
        context,
        AppRoutes.home,
        (_) => false,
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.toString().replaceFirst('Exception: ', ''))),
      );
    } finally {
      if (mounted) setState(() => _submitting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [AppTheme.pinkGradient, AppTheme.purpleMedium],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
      ),
      child: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Form(
                key: _formKey,
                child: Column(
                  children: [
                    const Text(
                      'Crear cuenta administrativa',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 16),

                    RegisterField(
                      controller: _emailCtrl,
                      label: 'Correo real (obligatorio)',
                      onChanged: (_) => _formKey.currentState?.validate(),
                    ),
                    RegisterField(
                      controller: _passwordCtrl,
                      label: 'ContraseÃ±a',
                      isPassword: true,
                      onChanged: (_) => _formKey.currentState?.validate(),
                    ),
                    const SizedBox(height: 8),

                    RegisterField(
                      controller: _nameCtrl,
                      label: 'Nombre completo',
                      onChanged: (_) => _formKey.currentState?.validate(),
                    ),
                    RegisterField(
                      controller: _phoneCtrl,
                      label: 'TelÃ©fono (recomendado)',
                      isNumber: true,
                      isOptional: true,
                      onChanged: (_) => _formKey.currentState?.validate(),
                    ),

                    // Documento opcional (selector + input)
                    RegisterField(
                      controller: _docCtrl,
                      label: 'Documento',
                      isDocumentField: true,
                      selectedDocumentType: _docType,
                      onDocumentTypeChanged: (t) {
                        setState(() => _docType = t ?? 'CÃ©dula');
                        _formKey.currentState?.validate();
                      },
                      onChanged: (_) => _formKey.currentState?.validate(),
                    ),

                    RegisterField(
                      controller: _addressCtrl,
                      label: 'DirecciÃ³n (opcional)',
                      isOptional: true,
                      onChanged: (_) => _formKey.currentState?.validate(),
                    ),

                    const SizedBox(height: 12),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: _submitting ? null : _submit,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppTheme.blue,
                          foregroundColor: AppTheme.white,
                          padding: const EdgeInsets.symmetric(vertical: 14),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                        ),
                        child:
                            _submitting
                                ? const SizedBox(
                                  height: 20,
                                  width: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                  ),
                                )
                                : const Text(
                                  'Finalizar',
                                  style: TextStyle(fontWeight: FontWeight.bold),
                                ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/forms/admin_account_form.dart 

 FILE: modules/features/auth/presentation/widgets/forms/register_form_step1.dart 
// lib/modules/features/auth/presentation/widgets/forms/register_form_step1.dart

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../blocs/register_cubit.dart';
import '../common/register_field.dart';

class RegisterFormStep1 extends StatelessWidget {
  final String role;

  const RegisterFormStep1({super.key, required this.role});

  @override
  Widget build(BuildContext context) {
    final cubit = context.watch<RegisterCubit>();

    return Form(
      key: cubit.formKeyStep1,
      autovalidateMode: AutovalidateMode.onUserInteraction,
      child: Column(
        children: [
          if (role == 'emprendedora' || role == 'entrepreneur') ...[
            RegisterField(
              controller: cubit.cedulaController,
              label: 'Documento de Identidad',
              isDocumentField: true,
              selectedDocumentType: cubit.state.selectedDocumentType,
              onDocumentTypeChanged: cubit.onDocumentTypeChanged,
              onChanged: (_) => cubit.onFieldChanged(),
              autofocus: true,
            ),
            RegisterField(
              controller: cubit.phoneController,
              label: 'TelÃ©fono',
              isNumber: true,
              onChanged: (_) => cubit.onFieldChanged(),
            ),
            RegisterField(
              controller: cubit.emailController,
              label: 'Correo',
              isOptional: true,
              onChanged: (_) => cubit.onFieldChanged(),
            ),
          ],
          if (role == 'cliente' || role == 'client') ...[
            RegisterField(
              controller: cubit.emailController,
              label: 'Correo electrÃ³nico',
              onChanged: (_) => cubit.onFieldChanged(),
              autofocus: true,
            ),
          ],
          RegisterField(
            controller: cubit.passwordController,
            label: 'ContraseÃ±a',
            isPassword: true,
            onChanged: (_) => cubit.onFieldChanged(),
          ),
          const SizedBox(height: 16),
          BlocBuilder<RegisterCubit, RegisterCubitState>(
            builder: (context, state) {
              return PrimaryButton(
                text: 'Continuar',
                onPressed: state.isStep1Valid
                    ? () {
                        final isValid =
                            cubit.formKeyStep1.currentState?.validate() ?? false;
                        if (isValid) cubit.goToStep2();
                      }
                    : null,
              );
            },
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/forms/register_form_step1.dart 

 FILE: modules/features/auth/presentation/widgets/forms/register_form_step2.dart 
// lib/modules/features/auth/presentation/widgets/forms/register_form_step2.dart

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../blocs/register_cubit.dart';
import '../../blocs/register_bloc.dart';
import '../../../../../features/auth/domain/entities/user_entity.dart';
import '../common/register_field.dart';
import '../../../../../core/widgets/inputs/accept_privacy_checkbox.dart';

class RegisterFormStep2 extends StatelessWidget {
  final String role;

  const RegisterFormStep2({super.key, required this.role});

  @override
  Widget build(BuildContext context) {
    final cubit = context.watch<RegisterCubit>();
    final bloc = context.read<RegisterBloc>();

    void submit() async {
      if (!(cubit.formKeyStep2.currentState?.validate() ?? false) ||
          !cubit.acceptedPrivacy) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Debes llenar todos los campos y aceptar la PolÃ­tica.'),
          ),
        );
        return;
      }

      final user = UserEntity(
        uid: '',
        name: cubit.nameController.text,
        lastName: '',
        phone: cubit.phoneController.text,
        cedula: cubit.cedulaController.text,
        email: cubit.emailController.text,
        address: cubit.addressController.text,
      );

      bloc.add(
        SubmitRegisterEvent(
          user: user,
          password: cubit.passwordController.text,
          role: role,
        ),
      );
    }

    return Form(
      key: cubit.formKeyStep2,
      child: Column(
        children: [
          RegisterField(
            controller: cubit.nameController,
            label: 'Nombre completo',
            onChanged: (_) => cubit.onFieldChangedStep2(),
          ),
          if (role == 'entrepreneur' || role == 'emprendedora') ...[
            RegisterField(
              controller: cubit.addressController,
              label: 'DirecciÃ³n',
              onChanged: (_) => cubit.onFieldChangedStep2(),
            ),
            RegisterField(
              controller: cubit.businessNameController,
              label: 'Nombre del negocio (opcional)',
            ),
          ],
          if (role == 'cliente' || role == 'client') ...[
            RegisterField(
              controller: cubit.phoneController,
              label: 'TelÃ©fono de contacto',
              onChanged: (_) => cubit.onFieldChangedStep2(),
            ),
          ],
          const SizedBox(height: 8),
          AcceptPrivacyCheckbox(
            accepted: cubit.acceptedPrivacy,
            onChanged: cubit.setAcceptedPrivacy,
          ),
          const SizedBox(height: 16),
          BlocBuilder<RegisterCubit, RegisterCubitState>(
            builder: (context, state) {
              return PrimaryButton(
                text: 'Crear cuenta',
                onPressed: state.isStep2Valid ? submit : null,
              );
            },
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/forms/register_form_step2.dart 

Dentro de /link_phone:

 FILE: modules/features/auth/presentation/widgets/link_phone/link_phone_card.dart 
// lib/modules/features/auth/presentation/widgets/link_phone/link_phone_card.dart
import 'dart:async';
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import '../../../../../core/utils/validation/phone_normalizer.dart';
import '../../../../../core/utils/validation/validators.dart';
import '../../../../../core/widgets/inputs/phone_ec_field.dart';
import '../recovery/otp_code_input.dart';

typedef LinkPhoneStarter = Future<String> Function(String phoneE164);
typedef LinkPhoneConfirmer =
    Future<void> Function({
      required String verificationId,
      required String smsCode,
    });

class LinkPhoneCard extends StatefulWidget {
  final LinkPhoneStarter onStart; // devuelve verificationId
  final LinkPhoneConfirmer onConfirm;

  const LinkPhoneCard({
    super.key,
    required this.onStart,
    required this.onConfirm,
  });

  @override
  State<LinkPhoneCard> createState() => _LinkPhoneCardState();
}

class _LinkPhoneCardState extends State<LinkPhoneCard> {
  final _phone = TextEditingController();
  final _node = FocusNode();
  String? _verificationId;
  bool _loading = false;
  String _code = '';

  static const _cooldown = 45;
  int _left = 0;
  Timer? _t;

  @override
  void dispose() {
    _t?.cancel();
    _phone.dispose();
    _node.dispose();
    super.dispose();
  }

  void _startTimer() {
    _t?.cancel();
    setState(() => _left = _cooldown);
    _t = Timer.periodic(const Duration(seconds: 1), (tm) {
      if (_left <= 1) {
        tm.cancel();
        setState(() => _left = 0);
      } else {
        setState(() => _left -= 1);
      }
    });
  }

  Future<void> _send() async {
    final raw = _phone.text.trim();
    final e164 = PhoneNormalizerEC.toE164(raw);
    if (e164 == null) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('TelÃ©fono invÃ¡lido')));
      return;
    }
    setState(() => _loading = true);
    try {
      final verId = await widget.onStart(e164);
      setState(() => _verificationId = verId);
      _startTimer();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.toString().replaceFirst('Exception: ', ''))),
      );
    } finally {
      setState(() => _loading = false);
    }
  }

  Future<void> _confirm() async {
    final v = _verificationId;
    if (v == null) return;
    if (!RegExp(r'^\d{6}$').hasMatch(_code)) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('CÃ³digo invÃ¡lido')));
      return;
    }
    setState(() => _loading = true);
    try {
      await widget.onConfirm(verificationId: v, smsCode: _code);
      if (!mounted) return;
      Navigator.of(context).pop(true); // listo
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.toString().replaceFirst('Exception: ', ''))),
      );
    } finally {
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final sent = _verificationId != null;

    return AbsorbPointer(
      absorbing: _loading,
      child: Opacity(
        opacity: _loading ? 0.7 : 1,
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white.withValues(alpha: .92),
            borderRadius: BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: .15),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          padding: const EdgeInsets.all(16),
          child: AnimatedSwitcher(
            duration: const Duration(milliseconds: 220),
            child:
                !sent
                    ? Column(
                      key: const ValueKey('step-phone'),
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        const Text(
                          'Enlazar telÃ©fono',
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 6),
                        const Text(
                          'RecibirÃ¡s un cÃ³digo por SMS para confirmar.',
                          textAlign: TextAlign.center,
                          style: TextStyle(color: Colors.black54),
                        ),
                        const SizedBox(height: 14),
                        PhoneEcField(
                          controller: _phone,
                          focusNode: _node,
                          onChanged: (_) {},
                          errorText: AppValidators.ecMobilePhone(_phone.text),
                        ),
                        const SizedBox(height: 12),
                        ElevatedButton(
                          onPressed: _send,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: AppTheme.blue,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 14),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(12),
                            ),
                          ),
                          child: const Text(
                            'Enviar cÃ³digo',
                            style: TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ),
                      ],
                    )
                    : Column(
                      key: const ValueKey('step-otp'),
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        const Text(
                          'Confirma el cÃ³digo',
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 6),
                        const Text(
                          'Ingresa el cÃ³digo de 6 dÃ­gitos que recibiste.',
                          textAlign: TextAlign.center,
                          style: TextStyle(color: Colors.black54),
                        ),
                        const SizedBox(height: 16),
                        Center(
                          child: OtpCodeInput(
                            length: 6,
                            autofocus: true,
                            onChanged: (c) => setState(() => _code = c),
                          ),
                        ),
                        const SizedBox(height: 12),
                        ElevatedButton(
                          onPressed: _confirm,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: AppTheme.blue,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 14),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(12),
                            ),
                          ),
                          child: const Text(
                            'Enlazar',
                            style: TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ),
                        TextButton(
                          onPressed: _left > 0 ? null : _send,
                          child: Text(
                            _left > 0
                                ? 'Reenviar cÃ³digo (${_left}s)'
                                : 'Reenviar cÃ³digo',
                          ),
                        ),
                      ],
                    ),
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/link_phone/link_phone_card.dart 

Dentro de /recovery:

 FILE: modules/features/auth/presentation/widgets/recovery/doc_type_selector.dart 
// lib/modules/features/auth/presentation/widgets/recovery/doc_type_selector.dart
import 'package:flutter/material.dart';
import 'document_type.dart';

class DocTypeSelector extends StatelessWidget {
  final DocumentType value;
  final ValueChanged<DocumentType> onChanged;

  const DocTypeSelector({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return SegmentedButton<DocumentType>(
      segments: const [
        ButtonSegment(value: DocumentType.cedula, label: Text('CÃ©dula')),
        ButtonSegment(value: DocumentType.ruc, label: Text('RUC')),
        ButtonSegment(value: DocumentType.pasaporte, label: Text('Pasaporte')),
      ],
      selected: {value},
      onSelectionChanged: (set) {
        if (set.isEmpty) return;
        onChanged(set.first);
      },
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/doc_type_selector.dart 

- FILE: modules/features/auth/presentation/widgets/recovery/document_type.dart -
// lib/modules/features/auth/presentation/widgets/recovery/document_type.dart
enum DocumentType { cedula, ruc, pasaporte }

 END FILE: modules/features/auth/presentation/widgets/recovery/document_type.dart 

 FILE: modules/features/auth/presentation/widgets/recovery/email_link_card.dart 
// lib/modules/features/auth/presentation/widgets/recovery/email_link_card.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';

class EmailLinkCard extends StatelessWidget {
  final String? maskedEmail;
  final VoidCallback onChangeMethod;
  final VoidCallback onContinue;

  const EmailLinkCard({
    super.key,
    required this.onChangeMethod,
    required this.onContinue,
    this.maskedEmail,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .92),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: .15),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          const Text(
            'Revisa tu correo',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          Text(
            maskedEmail != null
                ? 'Te enviamos un enlace a $maskedEmail'
                : 'Te enviamos un enlace a tu correo registrado.',
            textAlign: TextAlign.center,
            style: const TextStyle(color: Colors.black54),
          ),
          const SizedBox(height: 16),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: onContinue,
              style: ElevatedButton.styleFrom(
                backgroundColor: AppTheme.blue,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text(
                'Ya confirmÃ©',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
            ),
          ),
          const SizedBox(height: 8),
          TextButton(
            onPressed: onChangeMethod,
            child: const Text('Cambiar mÃ©todo'),
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/email_link_card.dart 

-- FILE: modules/features/auth/presentation/widgets/recovery/finder_form.dart --
// lib/modules/features/auth/presentation/widgets/recovery/finder_form.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../blocs/password_reset_cubit.dart';
import '../../../../../core/config/app_theme.dart';
import '../../../../../core/utils/validation/validators.dart';
import '../../../../../core/utils/input/input_formatters.dart';
import 'document_type.dart';
import 'doc_type_selector.dart';

class FinderForm extends StatefulWidget {
  final FinderMode mode;
  final ValueChanged<FinderMode> onModeChanged;
  final ValueChanged<String> onSubmit;

  const FinderForm({
    super.key,
    required this.mode,
    required this.onModeChanged,
    required this.onSubmit,
  });

  @override
  State<FinderForm> createState() => _FinderFormState();
}

class _FinderFormState extends State<FinderForm> {
  final _form = GlobalKey<FormState>();
  final _ctrl = TextEditingController();
  bool _valid = false;

  // Nuevo: tipo de documento explÃ­cito cuando mode == cedula (documento)
  DocumentType _docType = DocumentType.cedula;

  @override
  void dispose() {
    _ctrl.dispose();
    super.dispose();
  }

  String? _validate(String? v) {
    if (widget.mode == FinderMode.cedula) {
      switch (_docType) {
        case DocumentType.cedula:
          return AppValidators.ecCedula(v);
        case DocumentType.ruc:
          return AppValidators.ecRuc(v);
        case DocumentType.pasaporte:
          return AppValidators.passport(v);
      }
    } else {
      return AppValidators.email(v);
    }
  }

  void _onChanged(String _) {
    final err = _validate(_ctrl.text);
    final ok = err == null;
    if (ok != _valid) {
      setState(() => _valid = ok);
    }
  }

  List<TextInputFormatter> _formatters() {
    if (widget.mode == FinderMode.email) return const [];
    switch (_docType) {
      case DocumentType.cedula:
      case DocumentType.ruc:
        return [FilteringTextInputFormatter.digitsOnly];
      case DocumentType.pasaporte:
        return [
          FilteringTextInputFormatter.allow(RegExp(r'[a-zA-Z0-9]')),
          const UpperCaseTextFormatter(),
        ];
    }
  }

  TextInputType _keyboard() {
    if (widget.mode == FinderMode.email) {
      return TextInputType.emailAddress;
    }
    switch (_docType) {
      case DocumentType.cedula:
      case DocumentType.ruc:
        return TextInputType.number;
      case DocumentType.pasaporte:
        return TextInputType.text;
    }
  }

  int _maxLength() {
    if (widget.mode == FinderMode.email) return 320;
    switch (_docType) {
      case DocumentType.cedula:
        return 10;
      case DocumentType.ruc:
        return 13;
      case DocumentType.pasaporte:
        return 12;
    }
  }

  String _label() {
    if (widget.mode == FinderMode.email) return 'Correo electrÃ³nico';
    switch (_docType) {
      case DocumentType.cedula:
        return 'CÃ©dula';
      case DocumentType.ruc:
        return 'RUC';
      case DocumentType.pasaporte:
        return 'Pasaporte';
    }
  }

  String _hint() {
    if (widget.mode == FinderMode.email) return 'nombre@dominio.com';
    switch (_docType) {
      case DocumentType.cedula:
        return '10 dÃ­gitos (ej. 0102030405)';
      case DocumentType.ruc:
        return '13 dÃ­gitos (ej. 1790012345001)';
      case DocumentType.pasaporte:
        return '6â12 caracteres AâZ / 0â9 (ej. G1234567)';
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDoc = widget.mode == FinderMode.cedula;
    final hasText = _ctrl.text.trim().isNotEmpty;
    final err = _validate(_ctrl.text);
    final showIcon = hasText;

    final suffix =
        showIcon
            ? Icon(
              err == null ? Icons.check_circle : Icons.error_outline,
              color: err == null ? Colors.green : Colors.orange,
            )
            : null;

    return Container(
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .92),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: .15),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // Selector principal: Documento vs Correo
          Row(
            children: [
              ChoiceChip(
                selected: isDoc,
                label: const Text('Documento'),
                onSelected: (v) {
                  if (!v) {
                    return;
                  }
                  _ctrl.clear();
                  setState(() {
                    _valid = false;
                    _docType = DocumentType.cedula;
                  });
                  widget.onModeChanged(FinderMode.cedula);
                },
              ),
              const SizedBox(width: 8),
              ChoiceChip(
                selected: !isDoc,
                label: const Text('Correo'),
                onSelected: (v) {
                  if (!v) {
                    return;
                  }
                  _ctrl.clear();
                  setState(() => _valid = false);
                  widget.onModeChanged(FinderMode.email);
                },
              ),
            ],
          ),

          const SizedBox(height: 12),

          // Sub-selector del tipo de documento
          if (isDoc) ...[
            Align(
              alignment: Alignment.centerLeft,
              child: Text(
                'Tipo de documento',
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ),
            const SizedBox(height: 6),
            DocTypeSelector(
              value: _docType,
              onChanged: (t) {
                _ctrl.clear();
                setState(() {
                  _docType = t;
                  _valid = false;
                });
              },
            ),
            const SizedBox(height: 12),
          ],

          Form(
            key: _form,
            child: TextFormField(
              controller: _ctrl,
              onChanged: _onChanged,
              autovalidateMode: AutovalidateMode.onUserInteraction,
              keyboardType: _keyboard(),
              inputFormatters: _formatters(),
              maxLength: _maxLength(),
              decoration: InputDecoration(
                labelText: _label(),
                hintText: _hint(),
                counterText: '',
                filled: true,
                fillColor: Colors.white,
                suffixIcon: suffix,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              validator: _validate,
            ),
          ),
          const SizedBox(height: 12),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: AppTheme.blue,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              onPressed:
                  _valid
                      ? () {
                        if (!(_form.currentState?.validate() ?? false)) {
                          return;
                        }
                        // Normalizo: para pasaporte mandamos en mayÃºsculas
                        final text =
                            _docType == DocumentType.pasaporte
                                ? _ctrl.text.trim().toUpperCase()
                                : _ctrl.text.trim();
                        widget.onSubmit(text);
                      }
                      : null,
              child: const Text(
                'Buscar cuenta',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
            ),
          ),
          const SizedBox(height: 6),
          Text(
            isDoc
                ? 'Usa el tipo correcto: CÃ©dula (10 dÃ­gitos), RUC (13 dÃ­gitos) o Pasaporte (AâZ/0â9, 6â12).'
                : 'Si tu cuenta tiene correo real, usa esta opciÃ³n.',
            style: const TextStyle(fontSize: 12, color: Colors.black87),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/finder_form.dart 

 FILE: modules/features/auth/presentation/widgets/recovery/method_selector_card.dart 
// lib/modules/features/auth/presentation/widgets/recovery/method_selector_card.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';

class MethodSelectorCard extends StatefulWidget {
  final bool hasPhone;
  final bool hasEmail;
  final String? maskedPhone;
  final String? maskedEmail;
  final VoidCallback onPickPhone;
  final VoidCallback onPickEmail;
  final VoidCallback onContinue;
  final VoidCallback onBackToFinder;

  const MethodSelectorCard({
    super.key,
    required this.hasPhone,
    required this.hasEmail,
    required this.onPickPhone,
    required this.onPickEmail,
    required this.onContinue,
    required this.onBackToFinder,
    this.maskedPhone,
    this.maskedEmail,
  });

  @override
  State<MethodSelectorCard> createState() => _MethodSelectorCardState();
}

class _MethodSelectorCardState extends State<MethodSelectorCard> {
  String? _selected; // 'phone' | 'email'

  @override
  void initState() {
    super.initState();
    // Preseleccionar si solo hay una opciÃ³n
    if (widget.hasPhone && !widget.hasEmail) {
      _selected = 'phone';
    } else if (widget.hasEmail && !widget.hasPhone) {
      _selected = 'email';
    }
  }

  @override
  Widget build(BuildContext context) {
    final noOptions = !widget.hasPhone && !widget.hasEmail;

    return Container(
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .92),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: .15),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          const Text(
            'Elige cÃ³mo recuperar tu cuenta',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
          ),
          const SizedBox(height: 12),

          if (noOptions) ...[
            const Text(
              'No encontramos mÃ©todos para recuperar tu cuenta. '
              'Vuelve e intenta con otro dato.',
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            OutlinedButton(
              onPressed: widget.onBackToFinder,
              child: const Text('Volver a buscar'),
            ),
          ] else ...[
            SegmentedButton<String>(
              segments: [
                if (widget.hasPhone)
                  const ButtonSegment<String>(
                    value: 'phone',
                    label: Text('SMS'),
                    icon: Icon(Icons.sms),
                  ),
                if (widget.hasEmail)
                  const ButtonSegment<String>(
                    value: 'email',
                    label: Text('Correo'),
                    icon: Icon(Icons.mail),
                  ),
              ],
              // ð§ Fix de crash: permitir selecciÃ³n vacÃ­a
              emptySelectionAllowed: true,
              selected: _selected == null ? <String>{} : {_selected!},
              onSelectionChanged: (set) {
                setState(() => _selected = set.isEmpty ? null : set.first);
              },
            ),
            const SizedBox(height: 12),
            if (_selected == 'phone')
              Text(
                widget.maskedPhone != null
                    ? 'Enviaremos un cÃ³digo a ${widget.maskedPhone}'
                    : 'Enviaremos un cÃ³digo por SMS a tu nÃºmero.',
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.black54),
              ),
            if (_selected == 'email')
              Text(
                widget.maskedEmail != null
                    ? 'Enviaremos un enlace a ${widget.maskedEmail}'
                    : 'Enviaremos un enlace a tu correo.',
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.black54),
              ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: widget.onBackToFinder,
                    child: const Text('Cambiar bÃºsqueda'),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: ElevatedButton(
                    onPressed:
                        _selected == null
                            ? null
                            : () {
                              if (_selected == 'phone') {
                                widget.onPickPhone();
                              } else {
                                widget.onPickEmail();
                              }
                              widget.onContinue();
                            },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.blue,
                      foregroundColor: Colors.white,
                    ),
                    child: const Text('Continuar'),
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/method_selector_card.dart 

- FILE: modules/features/auth/presentation/widgets/recovery/otp_code_input.dart 
// lib/modules/features/auth/presentation/widgets/recovery/otp_code_input.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../../../../core/config/app_theme.dart';

/// OTP/PIN visual con UX mejorada:
/// - Solo un TextField oculto captura la entrada.
/// - Los cuadros son "tontos": no tienen foco individual.
/// - Entrada LâR estricta; el cursor siempre queda al final.
/// - Borrado/backspace funciona en cualquier estado.
/// - onCompleted se dispara al llegar a [length].
class OtpCodeInput extends StatefulWidget {
  final int length;
  final ValueChanged<String>? onChanged;
  final ValueChanged<String>? onCompleted;
  final bool autofocus;
  final double boxSize;
  final double gap;
  final TextStyle? textStyle;

  const OtpCodeInput({
    super.key,
    this.length = 6,
    this.onChanged,
    this.onCompleted,
    this.autofocus = false,
    this.boxSize = 44,
    this.gap = 10,
    this.textStyle,
  });

  @override
  State<OtpCodeInput> createState() => _OtpCodeInputState();
}

class _OtpCodeInputState extends State<OtpCodeInput> {
  late final TextEditingController _ctrl;
  late final FocusNode _fieldFocus; // foco real (oculto)
  late final FocusNode _tapFocus; // foco contenedor (para accesibilidad)

  String get _text => _ctrl.text;

  @override
  void initState() {
    super.initState();
    _ctrl = TextEditingController();
    _fieldFocus = FocusNode();
    _tapFocus = FocusNode(debugLabel: 'otp_container');

    _ctrl.addListener(_handleInternalChange);

    // Autofocus (abre teclado)
    if (widget.autofocus) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) _requestKeyboard();
      });
    }
  }

  @override
  void dispose() {
    _ctrl.removeListener(_handleInternalChange);
    _ctrl.dispose();
    _fieldFocus.dispose();
    _tapFocus.dispose();
    super.dispose();
  }

  void _requestKeyboard() {
    if (!_fieldFocus.hasFocus) {
      FocusScope.of(context).requestFocus(_fieldFocus);
    }
  }

  // Normaliza: solo dÃ­gitos, mÃ¡ximo length, cursor al final (LâR)
  void _handleInternalChange() {
    final raw = _ctrl.text;
    final digits = raw.replaceAll(RegExp(r'\D'), '');
    final normalized =
        digits.length <= widget.length
            ? digits
            : digits.substring(0, widget.length);

    if (normalized != raw) {
      // Reestablece texto + mueve el cursor al final SIN loops infinitos
      _ctrl.value = TextEditingValue(
        text: normalized,
        selection: TextSelection.collapsed(offset: normalized.length),
      );
      return; // El otro listener se dispararÃ¡ con el valor normalizado
    }

    // Notificar cambios
    widget.onChanged?.call(normalized);
    if (normalized.length == widget.length) {
      widget.onCompleted?.call(normalized);
    }

    // Asegurar cursor al final (si el usuario intentÃ³ moverlo)
    if (_ctrl.selection.baseOffset != normalized.length ||
        _ctrl.selection.extentOffset != normalized.length) {
      _ctrl.selection = TextSelection.collapsed(offset: normalized.length);
    }
    setState(() {}); // Redibuja cuadros
  }

  // Render de un cuadro (pasivo, sin foco)
  Widget _buildBox(int i) {
    final char = i < _text.length ? _text[i] : '';
    final isCurrent = _text.length == i && _text.length < widget.length;
    final isFilled = char.isNotEmpty;

    return Container(
      width: widget.boxSize,
      height: widget.boxSize,
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(10),
        border: Border.all(
          width: 1.5,
          color:
              isCurrent
                  ? Theme.of(context).colorScheme.primary
                  : Colors.black.withValues(alpha: .18),
        ),
        boxShadow: [
          if (isCurrent)
            BoxShadow(
              blurRadius: 8,
              spreadRadius: 0,
              offset: const Offset(0, 2),
              color: Theme.of(
                context,
              ).colorScheme.primary.withValues(alpha: .15),
            ),
        ],
      ),
      child: AnimatedSwitcher(
        duration: const Duration(milliseconds: 120),
        transitionBuilder: (c, a) => FadeTransition(opacity: a, child: c),
        child:
            isFilled
                ? Text(
                  char,
                  key: ValueKey('f-$i$char'),
                  style:
                      widget.textStyle ??
                      const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                        letterSpacing: 0.0,
                      ),
                )
                : AnimatedOpacity(
                  key: ValueKey('e-$i'),
                  opacity: isCurrent ? 1 : 0,
                  duration: const Duration(milliseconds: 200),
                  child: Container(
                    width: 2,
                    height: widget.boxSize * .48,
                    // âcaretâ simple
                    color: Theme.of(
                      context,
                    ).colorScheme.primary.withValues(alpha: .9),
                  ),
                ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final boxes = List.generate(widget.length, (i) => _buildBox(i));

    return Focus(
      focusNode: _tapFocus,
      canRequestFocus: true,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: _requestKeyboard, // tocar cualquier lado â abre teclado
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Fila visual (pasiva)
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                for (int i = 0; i < boxes.length; i++) ...[
                  if (i > 0) SizedBox(width: widget.gap),
                  boxes[i],
                ],
              ],
            ),

            // Campo real (oculto) que captura todo
            Offstage(
              offstage: false, // oculto pero en el Ã¡rbol para foco/teclado
              child: SizedBox(
                height: 0,
                width: 0,
                child: TextField(
                  controller: _ctrl,
                  focusNode: _fieldFocus,
                  autofocus: false,
                  keyboardType: TextInputType.number,
                  // Acepta pegar; filtramos/limitamos en _handleInternalChange
                  inputFormatters: [
                    FilteringTextInputFormatter.allow(RegExp(r'\d')),
                  ],
                  // Oculto/mini: sin decoraciÃ³n ni estilos
                  decoration: const InputDecoration(
                    isCollapsed: true,
                    border: InputBorder.none,
                    contentPadding: EdgeInsets.zero,
                  ),
                  // Evitar selecciÃ³n/cambio de cursor manual
                  enableInteractiveSelection: false,
                  showCursor: false,
                  // Al presionar âDone/Enterâ, mantener el foco si no estÃ¡ completo
                  textInputAction: TextInputAction.done,
                  onEditingComplete: () {
                    if (_text.length < widget.length) {
                      _requestKeyboard();
                    }
                  },
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/otp_code_input.dart 

 FILE: modules/features/auth/presentation/widgets/recovery/password_change_card.dart 
// lib/modules/features/auth/presentation/widgets/recovery/password_change_card.dart
import 'package:flutter/material.dart';
import '../../../../../core/widgets/inputs/password_field.dart';

/// Card de cambio de contraseÃ±a para flujos de recuperaciÃ³n.
/// - Firma compatible: `enabled`, `newCtrl`, `confirmCtrl`, `onSubmit`
/// - Usa PasswordField (ojito + long-press)
class PasswordChangeCard extends StatelessWidget {
  const PasswordChangeCard({
    super.key,
    this.enabled = true,
    this.newCtrl,
    this.confirmCtrl,
    required this.onSubmit,
  });

  final bool enabled;
  final TextEditingController? newCtrl;
  final TextEditingController? confirmCtrl;
  final Future<void> Function(String newPassword) onSubmit;

  @override
  Widget build(BuildContext context) {
    final newC = newCtrl ?? TextEditingController();
    final confirmC = confirmCtrl ?? TextEditingController();
    final formKey = GlobalKey<FormState>();

    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              PasswordField(
                controller: newC,
                labelText: 'Nueva contraseÃ±a',
                enabled: enabled,
                validator: (v) {
                  final t = v?.trim() ?? '';
                  if (t.length < 6) return 'MÃ­nimo 6 caracteres';
                  return null;
                },
              ),
              const SizedBox(height: 12),
              PasswordField(
                controller: confirmC,
                labelText: 'Confirmar contraseÃ±a',
                enabled: enabled,
                validator: (v) {
                  if ((v ?? '').trim() != newC.text.trim()) {
                    return 'No coinciden';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: enabled
                    ? () async {
                        final form = formKey.currentState;
                        if (form != null && form.validate()) {
                          await onSubmit(newC.text.trim());
                        }
                      }
                    : null,
                child: const Text('Cambiar contraseÃ±a'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/password_change_card.dart 

 FILE: modules/features/auth/presentation/widgets/recovery/phone_confirm_card.dart 
// lib/modules/features/auth/presentation/widgets/recovery/phone_confirm_card.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import '../../../../../core/utils/validation/validators.dart';

class PhoneConfirmCard extends StatefulWidget {
  final String? maskedPhone;
  final ValueChanged<String> onSubmit;
  final VoidCallback onChangeMethod;

  const PhoneConfirmCard({
    super.key,
    required this.onSubmit,
    required this.onChangeMethod,
    this.maskedPhone,
  });

  @override
  State<PhoneConfirmCard> createState() => _PhoneConfirmCardState();
}

class _PhoneConfirmCardState extends State<PhoneConfirmCard> {
  final _form = GlobalKey<FormState>();
  final _phone = TextEditingController();
  bool _valid = false;

  @override
  void dispose() {
    _phone.dispose();
    super.dispose();
  }

  void _onChanged(String _) {
    final ok = AppValidators.ecMobilePhone(_phone.text) == null;
    if (ok != _valid) {
      setState(() => _valid = ok);
    }
  }

  @override
  Widget build(BuildContext context) {
    final help =
        widget.maskedPhone == null
            ? 'Admite 9xxxxxxxx, 09xxxxxxxx, +5939xxxxxxxx o 5939xxxxxxxx.'
            : 'Ingresa el nÃºmero que termina como ${widget.maskedPhone}.';

    return Container(
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .92),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: .15),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _form,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Confirma tu telÃ©fono',
              textAlign: TextAlign.center,
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 6),
            Text(
              help,
              textAlign: TextAlign.center,
              style: const TextStyle(color: Colors.black54),
            ),
            const SizedBox(height: 14),
            TextFormField(
              controller: _phone,
              onChanged: _onChanged,
              keyboardType: TextInputType.phone,
              decoration: InputDecoration(
                labelText: 'TelÃ©fono mÃ³vil',
                hintText: '09xxxxxxxx, +5939xxxxxxxx, 5939xxxxxxxx',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              validator: AppValidators.ecMobilePhone,
            ),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed:
                    _valid
                        ? () {
                          if (!(_form.currentState?.validate() ?? false)) {
                            return;
                          }
                          widget.onSubmit(_phone.text.trim());
                        }
                        : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppTheme.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: const Text(
                  'Enviar SMS',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
              ),
            ),
            const SizedBox(height: 6),
            TextButton(
              onPressed: widget.onChangeMethod,
              child: const Text('Cambiar mÃ©todo'),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/phone_confirm_card.dart 

- FILE: modules/features/auth/presentation/widgets/recovery/phone_otp_card.dart 
// lib/modules/features/auth/presentation/widgets/recovery/phone_otp_card.dart
import 'dart:async';
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import 'otp_code_input.dart';

class PhoneOtpCard extends StatefulWidget {
  final String maskedPhone;
  final bool codeSent;
  final VoidCallback onResend;
  final ValueChanged<String> onVerify;
  final VoidCallback onChangeMethod;

  const PhoneOtpCard({
    super.key,
    required this.maskedPhone,
    required this.codeSent,
    required this.onResend,
    required this.onVerify,
    required this.onChangeMethod,
  });

  @override
  State<PhoneOtpCard> createState() => _PhoneOtpCardState();
}

class _PhoneOtpCardState extends State<PhoneOtpCard> {
  String _code = '';

  // Cooldown para "Reenviar cÃ³digo"
  static const int _cooldownSeconds = 45;
  int _remaining = 0;
  Timer? _timer;

  @override
  void initState() {
    super.initState();
    if (widget.codeSent) _startCooldown();
  }

  @override
  void didUpdateWidget(covariant PhoneOtpCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!oldWidget.codeSent && widget.codeSent) {
      _startCooldown();
    }
  }

  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }

  void _startCooldown() {
    _timer?.cancel();
    setState(() => _remaining = _cooldownSeconds);
    _timer = Timer.periodic(const Duration(seconds: 1), (t) {
      if (!mounted) return;
      if (_remaining <= 1) {
        t.cancel();
        setState(() => _remaining = 0);
      } else {
        setState(() => _remaining -= 1);
      }
    });
  }

  void _resend() {
    if (_remaining > 0) return;
    widget.onResend();
  }

  void _verify() {
    final c = _code.trim();
    if (c.length != 6) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('El cÃ³digo debe tener 6 dÃ­gitos.')),
      );
      return;
    }
    widget.onVerify(c);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 0, vertical: 0),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .92),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: .15),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          const Text(
            'VerificaciÃ³n por SMS',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 6),
          Text(
            'Enviamos un cÃ³digo a ${widget.maskedPhone}.',
            textAlign: TextAlign.center,
            style: const TextStyle(color: Colors.black54),
          ),
          const SizedBox(height: 16),
          Center(
            child: OtpCodeInput(
              length: 6,
              autofocus: true,
              onChanged: (v) => setState(() => _code = v),
            ),
          ),
          const SizedBox(height: 12),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: _verify,
              style: ElevatedButton.styleFrom(
                backgroundColor: AppTheme.blue,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text(
                'Confirmar cÃ³digo',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
            ),
          ),
          const SizedBox(height: 6),
          TextButton(
            onPressed: _remaining > 0 ? null : _resend,
            child: Text(
              _remaining > 0
                  ? 'Reenviar cÃ³digo (${_remaining}s)'
                  : 'Reenviar cÃ³digo',
            ),
          ),
          TextButton(
            onPressed: widget.onChangeMethod,
            child: const Text('Cambiar mÃ©todo'),
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/phone_otp_card.dart 

 FILE: modules/features/auth/presentation/widgets/recovery/recovery_method_tile.dart 
// lib/modules/features/auth/presentation/widgets/recovery/recovery_method_tile.dart
import 'package:flutter/material.dart';

class RecoveryMethodTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final String subtitle;
  final String actionText;
  final VoidCallback? onPressed;

  const RecoveryMethodTile({
    super.key,
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.actionText,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, c) {
        final compact = c.maxWidth < 420;
        final tile = Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            CircleAvatar(
              radius: 26,
              backgroundColor: Theme.of(
                context,
              ).colorScheme.primary.withValues(alpha: .08),
              child: Icon(
                icon,
                size: 28,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: const TextStyle(
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(subtitle, style: const TextStyle(color: Colors.black54)),
                  if (compact) const SizedBox(height: 12),
                ],
              ),
            ),
            if (!compact)
              FilledButton(onPressed: onPressed, child: Text(actionText)),
          ],
        );

        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            tile,
            if (compact)
              FilledButton(onPressed: onPressed, child: Text(actionText)),
          ],
        );
      },
    );
  }
}

 END FILE: modules/features/auth/presentation/widgets/recovery/recovery_method_tile.dart 

Dentro de /cart:

----------------- FILE: modules/features/cart/cart_routes.dart -----------------
import 'package:flutter/material.dart';
import 'presentation/pages/cart_page.dart';

class CartRoutes {
  static const String base = '/cart';
  static const String cart = '$base/main';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case cart:
        return MaterialPageRoute(builder: (_) => const CartPage());
      default:
        return MaterialPageRoute(
          builder: (_) => const Scaffold(body: Center(child: Text('Ruta Carrito no definida'))),
        );
    }
  }
}

--------------- END FILE: modules/features/cart/cart_routes.dart ---------------

Dentro de /data:

Dentro de /repositories:

- FILE: modules/features/cart/data/repositories/in_memory_cart_repository.dart -
import 'dart:async';
import '../../domain/entities/cart_item.dart';
import '../../domain/repositories/cart_repository.dart';

class InMemoryCartRepository implements CartRepository {
  final List<CartItem> _items = <CartItem>[];
  final StreamController<List<CartItem>> _ctrl =
      StreamController<List<CartItem>>.broadcast();

  @override
  Stream<List<CartItem>> watch() => _ctrl.stream;

  @override
  List<CartItem> snapshot() => List<CartItem>.unmodifiable(_items);

  void _emit() {
    if (!_ctrl.isClosed) _ctrl.add(snapshot());
  }

  @override
  void addOrIncrease(CartItem item) {
    final i = _items.indexWhere((e) =>
        e.productId == item.productId && e.presentationId == item.presentationId);
    if (i >= 0) {
      final current = _items[i];
      _items[i] = current.copyWith(qty: current.qty + item.qty);
    } else {
      _items.add(item);
    }
    _emit();
  }

  @override
  void decrease(String productId, String presentationId) {
    final i = _items.indexWhere(
        (e) => e.productId == productId && e.presentationId == presentationId);
    if (i < 0) return;
    final cur = _items[i];
    final nextQty = cur.qty - 1;
    if (nextQty <= 0) {
      _items.removeAt(i);
    } else {
      _items[i] = cur.copyWith(qty: nextQty);
    }
    _emit();
  }

  @override
  void remove(String productId, String presentationId) {
    _items.removeWhere(
        (e) => e.productId == productId && e.presentationId == presentationId);
    _emit();
  }

  @override
  void clear() {
    _items.clear();
    _emit();
  }

  void dispose() => _ctrl.close();
}

 END FILE: modules/features/cart/data/repositories/in_memory_cart_repository.dart 

Dentro de /domain:

Dentro de /entities:

---------- FILE: modules/features/cart/domain/entities/cart_item.dart ----------
class CartItem {
  final String productId;
  final String productName;
  final String presentationId;
  final String presentationName;
  final double unitPrice;
  final int minQty;
  final int qty;
  final String? imageUrl;

  const CartItem({
    required this.productId,
    required this.productName,
    required this.presentationId,
    required this.presentationName,
    required this.unitPrice,
    required this.minQty,
    required this.qty,
    this.imageUrl,
  });

  CartItem copyWith({int? qty}) => CartItem(
        productId: productId,
        productName: productName,
        presentationId: presentationId,
        presentationName: presentationName,
        unitPrice: unitPrice,
        minQty: minQty,
        qty: qty ?? this.qty,
        imageUrl: imageUrl,
      );

  double get subtotal => unitPrice * qty;
}

-------- END FILE: modules/features/cart/domain/entities/cart_item.dart --------

Dentro de /repositories:

----- FILE: modules/features/cart/domain/repositories/cart_repository.dart -----
import '../entities/cart_item.dart';

abstract class CartRepository {
  Stream<List<CartItem>> watch();
  List<CartItem> snapshot();
  void addOrIncrease(CartItem item); // si existe la misma presentaciÃ³n, suma qty
  void decrease(String productId, String presentationId); // resta o elimina
  void remove(String productId, String presentationId);
  void clear();
}

--- END FILE: modules/features/cart/domain/repositories/cart_repository.dart ---

Dentro de /presentation:

Dentro de /blocs:

-------- FILE: modules/features/cart/presentation/blocs/cart_cubit.dart --------
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/cart_item.dart';
import '../../domain/repositories/cart_repository.dart';

sealed class CartState {}
class CartEmpty extends CartState {}
class CartLoaded extends CartState {
  final List<CartItem> items;
  final double total;
  final int count;
  CartLoaded(this.items)
      : total = items.fold(0, (p, e) => p + e.subtotal),
        count = items.fold(0, (p, e) => p + e.qty);
}

class CartCubit extends Cubit<CartState> {
  final CartRepository repo;
  CartCubit(this.repo) : super(CartEmpty()) {
    repo.watch().listen(_onItems, onError: (_) {});
    _onItems(repo.snapshot());
  }

  void _onItems(List<CartItem> items) {
    emit(items.isEmpty ? CartEmpty() : CartLoaded(items));
  }

  void add(CartItem item) => repo.addOrIncrease(item);
  void inc(String pid, String presId) =>
      repo.addOrIncrease(_find(pid, presId)?.copyWith(qty: 1) ??
          CartItem(productId: pid, productName: '', presentationId: presId, presentationName: '', unitPrice: 0, minQty: 1, qty: 1));
  void dec(String pid, String presId) => repo.decrease(pid, presId);
  void remove(String pid, String presId) => repo.remove(pid, presId);
  void clear() => repo.clear();

  CartItem? _find(String pid, String presId) {
    final st = state;
    if (st is! CartLoaded) return null;
    try {
      return st.items
          .firstWhere((e) => e.productId == pid && e.presentationId == presId);
    } catch (_) {
      return null;
    }
  }
}

------ END FILE: modules/features/cart/presentation/blocs/cart_cubit.dart ------

Dentro de /pages:

--------- FILE: modules/features/cart/presentation/pages/cart_page.dart --------
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/config/app_theme.dart';
import '../../domain/entities/cart_item.dart';
import '../blocs/cart_cubit.dart';
import '../widgets/cart_item_tile.dart';
import '../widgets/cart_summary.dart';

class CartPage extends StatelessWidget {
  const CartPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tu carrito'),
        actions: [
          BlocBuilder<CartCubit, CartState>(
            builder: (_, st) {
              final disabled = st is CartEmpty;
              return IconButton(
                tooltip: 'Vaciar carrito',
                onPressed: disabled ? null : () => context.read<CartCubit>().clear(),
                icon: const Icon(Icons.delete_outline),
              );
            },
          ),
        ],
      ),
      body: BlocBuilder<CartCubit, CartState>(
        builder: (_, st) {
          if (st is CartEmpty) {
            return const _EmptyView();
          }
          if (st is! CartLoaded) return const SizedBox.shrink();

          return Column(
            children: [
              Expanded(
                child: ListView.separated(
                  padding: const EdgeInsets.all(12),
                  itemCount: st.items.length,
                  separatorBuilder: (_, i) => const SizedBox(height: 8),
                  itemBuilder: (_, i) {
                    final CartItem it = st.items[i];
                    return CartItemTile(item: it);
                  },
                ),
              ),
              CartSummary(total: st.total, onCheckout: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Ir a pagar (conÃ©ctalo a tu flujo de pedido)'),
                    backgroundColor: AppTheme.purpleDark,
                    behavior: SnackBarBehavior.floating,
                  ),
                );
              }),
            ],
          );
        },
      ),
    );
  }
}

class _EmptyView extends StatelessWidget {
  const _EmptyView();

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.shopping_bag_outlined, size: 64),
            const SizedBox(height: 12),
            const Text(
              'AÃºn no tienes productos.\nExplora el catÃ¡logo y agrega lo que te guste.',
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            FilledButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Explorar productos'),
            ),
          ],
        ),
      ),
    );
  }
}

------- END FILE: modules/features/cart/presentation/pages/cart_page.dart ------

Dentro de /widgets:

---- FILE: modules/features/cart/presentation/widgets/cart_icon_button.dart ----
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../blocs/cart_cubit.dart';
import '../../cart_routes.dart';

class CartIconButton extends StatelessWidget {
  final Color? color;
  const CartIconButton({super.key, this.color});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CartCubit, CartState>(
      builder: (_, st) {
        int count = 0;
        if (st is CartLoaded) count = st.count;

        final icon = Stack(
          clipBehavior: Clip.none,
          children: [
            Icon(Icons.shopping_cart_outlined, color: color),
            if (count > 0)
              Positioned(
                right: -4,
                top: -4,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.red,
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Text(
                    '$count',
                    style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
          ],
        );

        return IconButton(
          tooltip: 'Carrito',
          onPressed: () => Navigator.pushNamed(context, CartRoutes.cart),
          icon: icon,
        );
      },
    );
  }
}

-- END FILE: modules/features/cart/presentation/widgets/cart_icon_button.dart --

----- FILE: modules/features/cart/presentation/widgets/cart_item_tile.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/cart_item.dart';
import '../blocs/cart_cubit.dart';

class CartItemTile extends StatelessWidget {
  final CartItem item;
  const CartItemTile({super.key, required this.item});

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.grey.shade50,
      borderRadius: BorderRadius.circular(12),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Container(
              width: 64,
              height: 64,
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
              ),
              alignment: Alignment.center,
              child: const Icon(Icons.fastfood_rounded),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                '${item.productName}\n${item.presentationName}',
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
            ),
            const SizedBox(width: 8),
            Text('\$${item.unitPrice.toStringAsFixed(2)}'),
            const SizedBox(width: 8),
            _QtyStepper(item: item),
          ],
        ),
      ),
    );
  }
}

class _QtyStepper extends StatelessWidget {
  final CartItem item;
  const _QtyStepper({required this.item});

  @override
  Widget build(BuildContext context) {
    final cubit = context.read<CartCubit>();
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          visualDensity: VisualDensity.compact,
          onPressed: () => cubit.dec(item.productId, item.presentationId),
          icon: const Icon(Icons.remove_circle_outline),
        ),
        Text('${item.qty}', style: const TextStyle(fontWeight: FontWeight.bold)),
        IconButton(
          visualDensity: VisualDensity.compact,
          onPressed: () => cubit.inc(item.productId, item.presentationId),
          icon: const Icon(Icons.add_circle_outline),
        ),
      ],
    );
  }
}

--- END FILE: modules/features/cart/presentation/widgets/cart_item_tile.dart ---

------ FILE: modules/features/cart/presentation/widgets/cart_summary.dart ------
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';

class CartSummary extends StatelessWidget {
  final double total;
  final VoidCallback onCheckout;
  const CartSummary({super.key, required this.total, required this.onCheckout});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      top: false,
      child: Container(
        padding: const EdgeInsets.fromLTRB(16, 10, 16, 12),
        decoration: BoxDecoration(
          color: AppTheme.white,
          boxShadow: const [BoxShadow(blurRadius: 10, color: Color(0x11000000))],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                'Subtotal  \$${total.toStringAsFixed(2)}',
                style: const TextStyle(fontWeight: FontWeight.w800, fontSize: 16),
              ),
            ),
            FilledButton(
              onPressed: onCheckout,
              child: const Text('Ir a pagar'),
            ),
          ],
        ),
      ),
    );
  }
}

---- END FILE: modules/features/cart/presentation/widgets/cart_summary.dart ----

Dentro de /catalog:

-------------- FILE: modules/features/catalog/catalog_routes.dart --------------
// modules/features/catalog/catalog_routes.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

import 'domain/entities/category.dart';
import 'presentation/pages/product_detail_page.dart';
import 'presentation/pages/catalog_home_page.dart';
import 'presentation/pages/vitrinas_page.dart';

// DS/Repo/UC (alias para evitar ambigÃ¼edades futuras)
import 'data/datasources/sections_remote_datasource.dart' as sections_ds;
import 'data/datasources/categories_remote_datasource.dart' as cats_ds;
import 'data/datasources/catalog_remote_datasource.dart' as catalog_ds;

import 'data/repositories/sections_repository_impl.dart';
import 'data/repositories/categories_repository_impl.dart';
import 'data/repositories/catalog_settings_repository_impl.dart';
import 'data/repositories/catalog_repository_impl.dart';

import 'domain/usecases/get_home_sections.dart';
import 'domain/usecases/get_categories.dart';
import 'domain/usecases/get_primary_categories_limit.dart';
import 'domain/usecases/get_products_with_presentations.dart';
import 'domain/usecases/add_presentation.dart';
import 'domain/usecases/get_products_by_category.dart';

import 'presentation/blocs/home_catalog_cubit.dart';
import 'presentation/blocs/catalog_cubit.dart';
import 'presentation/blocs/category_cubit.dart';
import 'presentation/pages/category_page.dart';

import '../../core/services/storage/cloudinary_storage_service.dart';
import '../../core/services/storage/firebase_storage_service.dart';
import '../../core/config/storage_flags.dart';

class CatalogRoutes {
  static const String base = '/catalog';
  static const String home = '$base/home';
  static const String productDetail = '$base/detail';
  static const String category = '$base/category';
  static const String vitrinas = '$base/vitrinas';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      // ========= HOME =========
      case home: {
        final fs = FirebaseFirestore.instance;

        final sectionsDs   = sections_ds.SectionsRemoteDataSource(fs);
        final categoriesDs = cats_ds.CategoriesRemoteDataSource(fs);

        final sectionsRepo   = SectionsRepositoryImpl(sectionsDs, fs);
        final categoriesRepo = CategoriesRepositoryImpl(categoriesDs);
        final settingsRepo   = CatalogSettingsRepositoryImpl(fs);

        final getHomeSections = GetHomeSections(sectionsRepo);
        final getCategories   = GetCategories(categoriesRepo);
        final getPrimaryLimit = GetPrimaryCategoriesLimit(settingsRepo);

        return MaterialPageRoute(
          builder: (_) => BlocProvider<HomeCatalogCubit>(
            create: (_) => HomeCatalogCubit(
              getHomeSections,
              getCategories,
              getPrimaryLimit,
            )..load(),
            child: const CatalogHomePage(),
          ),
        );
      }

      // ========= DETALLE =========
      case productDetail: {
        final args = settings.arguments as Map<String, dynamic>? ?? {};
        final String productId = args['productId'] as String;

        final ds   = catalog_ds.CatalogRemoteDataSource(FirebaseFirestore.instance);
        final repo = CatalogRepositoryImpl(ds);
        final getProducts = GetProductsWithPresentations(repo);
        final addPres     = AddPresentation(repo);

        final primary  = CloudinaryStorageService();
        final fallback = FirebaseStorageService();

        return MaterialPageRoute(
          builder: (_) => BlocProvider<CatalogCubit>(
            create: (_) => CatalogCubit(
              getProducts: getProducts,
              addPresentation: addPres,
              primaryStorage: primary,
              fallbackStorage: StorageFlags.enableFirebaseFallback ? fallback : null,
            )..loadProduct(productId),
            child: ProductDetailPage(productId: productId),
          ),
        );
      }

      // ========= LISTA POR CATEGORÃA =========
      case category: {
        final args = settings.arguments as Map<String, dynamic>? ?? {};
        final id   = (args['categoryId'] as String?) ?? 'empanadas';
        final name = (args['name'] as String?) ?? 'CategorÃ­a';

        final ds   = catalog_ds.CatalogRemoteDataSource(FirebaseFirestore.instance);
        final repo = CatalogRepositoryImpl(ds);
        final getByCat = GetProductsByCategory(repo);

        return MaterialPageRoute(
          builder: (_) => BlocProvider<CategoryCubit>(
            create: (_) => CategoryCubit(getByCat, categoryId: id),
            child: CategoryPage(category: Category(id: id, name: name)),
          ),
        );
      }

      // ========= VITRINAS =========
      case vitrinas:
        return MaterialPageRoute(builder: (_) => const VitrinasPage());

      // ========= DEFAULT =========
      default:
        return MaterialPageRoute(
          builder: (_) => const Scaffold(
            body: Center(child: Text('Ruta de CatÃ¡logo no definida')),
          ),
        );
    }
  }
}

------------ END FILE: modules/features/catalog/catalog_routes.dart ------------

Dentro de /data:

Dentro de /datasources:

 FILE: modules/features/catalog/data/datasources/catalog_remote_datasource.dart 
// modules/features/catalog/data/datasources/catalog_remote_datasource.dart
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../../../core/config/collections.dart';
import '../models/public_product_model.dart';
import '../mappers/product_mini_mapper.dart';
import '../../domain/entities/product_mini.dart';

/// DataSource REAL del catÃ¡logo oficial:
/// - Lee producto
/// - Lee/escribe presentaciones
/// - Lista productos del catÃ¡logo
/// - Lista por categorÃ­a/subcategorÃ­a (para CategoryPage)
class CatalogRemoteDataSource {
  final FirebaseFirestore firestore;
  CatalogRemoteDataSource(this.firestore);

  CollectionReference<Map<String, dynamic>> get _productsCol =>
      firestore.collection(Col.products);

  PublicProductModel _productDocToModel(
    DocumentSnapshot<Map<String, dynamic>> doc,
  ) {
    final data = doc.data() ?? {};
    return PublicProductModel.fromMap({
      'id': doc.id,
      ...data,
    });
  }

  Future<PublicProductModel?> getProduct(String productId) async {
    final doc = await _productsCol.doc(productId).get();
    if (!doc.exists) return null;
    return _productDocToModel(doc);
  }

  Future<List<Map<String, dynamic>>> getPresentations(String productId) async {
    final snap = await _productsCol.doc(productId).collection(Col.presentations).orderBy('order').get();

    return snap.docs.map((d) {
      final m = d.data();
      return {
        'id': d.id,
        'name': (m['name'] ?? '').toString(),
        'unitPrice': (m['unitPrice'] ?? 0),
        'minQty': (m['minQty'] ?? 1),
        'imageUrl': (m['imageUrl'] ?? '').toString(),
        'order': (m['order'] ?? 0),
      };
    }).toList();
  }

  Future<void> addOrUpdatePresentation({
    required String productId,
    required String? presentationId,
    required Map<String, dynamic> data,
  }) async {
    final col = _productsCol.doc(productId).collection(Col.presentations);

    if (presentationId == null || presentationId.isEmpty) {
      await col.add(data);
    } else {
      await col.doc(presentationId).set(data, SetOptions(merge: true));
    }
  }

  Future<List<PublicProductModel>> getCatalogProducts({
    int limit = 50,
  }) async {
    final query = _productsCol
        .where('isActive', isEqualTo: true)
        .orderBy('popularity', descending: true)
        .limit(limit);

    final snap = await query.get();
    return snap.docs.map(_productDocToModel).toList();
  }

  /// NavegaciÃ³n por categorÃ­a/subcategorÃ­a para la CategoryPage
  Future<List<ProductMini>> getProductsByCategory({
    required String categoryId,
    String? subcategory,
    int limit = 24,
  }) async {
    Query<Map<String, dynamic>> q =
        _productsCol.where('isActive', isEqualTo: true).where('categoryId', isEqualTo: categoryId);

    // Si manejas subcategorÃ­a en Firestore, mantenla en 'subCategory'
    final sub = (subcategory ?? '').trim();
    if (sub.isNotEmpty && sub.toLowerCase() != 'todo') {
      q = q.where('subCategory', isEqualTo: sub);
    }

    q = q.orderBy('popularity', descending: true).limit(limit);
    final snap = await q.get();

    return snap.docs.map(mapDocToProductMini).toList();
  }
  Future<({List<PublicProductModel> items, String? lastDocumentId, bool hasMore})> getAdminProducts({
    String? categoryId,
    String? status,
    String? searchQuery,
    int limit = 20,
    String? startAfterId,
  }) async {
    // Para el panel de admin ordenamos por nombre, evitando depender
    // de que todos los documentos tengan updatedAt poblado.
    Query<Map<String, dynamic>> query =
        _productsCol.orderBy('name', descending: false);

    if (categoryId != null && categoryId.isNotEmpty) {
      query = query.where('categoryId', isEqualTo: categoryId);
    }

    if (status != null && status.isNotEmpty) {
      switch (status) {
        case 'published':
          query = query.where('isActive', isEqualTo: true);
          break;
        case 'hidden':
          query = query.where('isVisible', isEqualTo: false);
          break;
        case 'draft':
          query = query.where('isActive', isEqualTo: false);
          break;
      }
    }

    if (startAfterId != null && startAfterId.isNotEmpty) {
      final startDoc = await _productsCol.doc(startAfterId).get();
      if (startDoc.exists) {
        query = query.startAfterDocument(startDoc);
      }
    }

    final snap = await query.limit(limit).get();
    final lowerSearch = searchQuery?.trim().toLowerCase();
    final items = snap.docs
        .map(_productDocToModel)
        .where(
          (map) =>
              lowerSearch == null ||
              lowerSearch.isEmpty ||
              map.name.toLowerCase().contains(lowerSearch) ||
              (map.sku ?? '').toLowerCase().contains(lowerSearch),
        )
        .toList();

    return (
      items: items,
      lastDocumentId: snap.docs.isEmpty ? null : snap.docs.last.id,
      hasMore: snap.docs.length == limit,
    );
  }

  Future<String> createProduct(Map<String, dynamic> data) async {
    final payload = {
      ...data,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
    };
    final doc = await _productsCol.add(payload);
    return doc.id;
  }

  Future<void> updateProduct(String productId, Map<String, dynamic> data) async {
    await _productsCol.doc(productId).set(
      {
        ...data,
        'updatedAt': FieldValue.serverTimestamp(),
      },
      SetOptions(merge: true),
    );
  }

  Future<void> toggleProductVisibility(String productId, bool visible) async {
    await _productsCol.doc(productId).set(
      {
        'isVisible': visible,
        'isActive': visible,
        'updatedAt': FieldValue.serverTimestamp(),
      },
      SetOptions(merge: true),
    );
  }
}

 END FILE: modules/features/catalog/data/datasources/catalog_remote_datasource.dart 

 FILE: modules/features/catalog/data/datasources/categories_remote_datasource.dart 
// modules/features/catalog/data/datasources/categories_remote_datasource.dart
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../../../core/config/collections.dart';
import '../models/category_model.dart';

class CategoriesRemoteDataSource {
  final FirebaseFirestore firestore;
  CategoriesRemoteDataSource(this.firestore);

  CollectionReference<CategoryModel> get _ref => firestore
      .collection(Col.categories)
      .withConverter<CategoryModel>(
        fromFirestore:
            (snap, _) => CategoryModel.fromFirestore(snap.id, snap.data()),
        toFirestore: (category, _) => category.toMap(),
      );

  Query<CategoryModel> _baseQuery({bool onlyVisible = false}) {
    Query<CategoryModel> query = _ref.orderBy('position');
    if (onlyVisible) query = query.where('visible', isEqualTo: true);
    return query;
  }

  Future<List<CategoryModel>> fetchOnce({bool onlyVisible = false}) async {
    final snapshot = await _baseQuery(onlyVisible: onlyVisible).get();
    return snapshot.docs.map((doc) => doc.data()).toList();
  }

  Stream<List<CategoryModel>> watchAll({bool onlyVisible = false}) {
    return _baseQuery(onlyVisible: onlyVisible)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  Future<void> create(CategoryModel model) async {
    final last =
        await _ref.orderBy('position', descending: true).limit(1).get();
    final nextPos =
        last.docs.isEmpty ? 1 : (last.docs.first.data().position + 1);
    final doc = _ref.doc();
    await doc.set(
      model.copyWith(id: doc.id, position: nextPos),
      SetOptions(merge: true),
    );
  }

  Future<void> update(CategoryModel model) {
    return _ref.doc(model.id).set(model, SetOptions(merge: true));
  }

  Future<void> delete(String id) => _ref.doc(id).delete();

  Future<void> reorder(List<CategoryModel> ordered) async {
    final batch = firestore.batch();
    for (var i = 0; i < ordered.length; i++) {
      final doc = firestore.collection(Col.categories).doc(ordered[i].id);
      final pos = ordered[i].position > 0 ? ordered[i].position : (i + 1);
      batch.update(doc, {'position': pos});
    }
    await batch.commit();
  }
}

 END FILE: modules/features/catalog/data/datasources/categories_remote_datasource.dart 

 FILE: modules/features/catalog/data/datasources/products_remote_datasource.dart 
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../../../core/config/collections.dart';
import '../models/admin_product_model.dart';

abstract class ProductsRemoteDataSource {
  Stream<List<AdminProductModel>> watchAll();
  Stream<List<AdminProductModel>> watchByCategory(String categoryId);
  Future<AdminProductModel> getById(String id);
  Future<String> create(AdminProductModel model);
  Future<void> update(AdminProductModel model);
  Future<void> delete(String id);
}

class ProductsRemoteDataSourceImpl implements ProductsRemoteDataSource {
  final FirebaseFirestore firestore;
  ProductsRemoteDataSourceImpl(this.firestore);

  CollectionReference<Map<String, dynamic>> get _collection =>
      firestore.collection(Col.products);

  @override
  Stream<List<AdminProductModel>> watchAll() {
    return _collection.snapshots().map(
          (snapshot) => snapshot.docs
              .map((doc) => AdminProductModel.fromJson(doc.data(), doc.id))
              .toList(),
        );
  }

  @override
  Stream<List<AdminProductModel>> watchByCategory(String categoryId) {
    return _collection
        .where('categoryId', isEqualTo: categoryId)
        .snapshots()
        .map(
          (snapshot) => snapshot.docs
              .map((doc) => AdminProductModel.fromJson(doc.data(), doc.id))
              .toList(),
        );
  }

  @override
  Future<AdminProductModel> getById(String id) async {
    try {
      final doc = await _collection.doc(id).get();
      if (!doc.exists) {
        throw Exception('Producto no encontrado');
      }
      return AdminProductModel.fromJson(doc.data() ?? <String, dynamic>{}, doc.id);
    } catch (e) {
      throw Exception('No se pudo obtener el producto: $e');
    }
  }

  @override
  Future<String> create(AdminProductModel model) async {
    try {
      final now = FieldValue.serverTimestamp();
      final data = {
        ...model.toJson(),
        'isActive': model.isVisible,
        'createdAt': now,
        'updatedAt': now,
      };
      if (model.id.isNotEmpty) {
        await _collection.doc(model.id).set(data, SetOptions(merge: true));
        return model.id;
      }
      final doc = await _collection.add(data);
      return doc.id;
    } catch (e) {
      throw Exception('No se pudo crear el producto: $e');
    }
  }

  @override
  Future<void> update(AdminProductModel model) async {
    if (model.id.isEmpty) {
      throw Exception('Producto sin id para actualizar');
    }
    try {
      final data = {
        ...model.toJson(),
        'isActive': model.isVisible,
        'updatedAt': FieldValue.serverTimestamp(),
      };
      await _collection.doc(model.id).set(data, SetOptions(merge: true));
    } catch (e) {
      throw Exception('No se pudo actualizar el producto: $e');
    }
  }

  @override
  Future<void> delete(String id) async {
    try {
      await _collection.doc(id).delete();
    } catch (e) {
      throw Exception('No se pudo eliminar el producto: $e');
    }
  }
}

 END FILE: modules/features/catalog/data/datasources/products_remote_datasource.dart 

 FILE: modules/features/catalog/data/datasources/sections_remote_datasource.dart 
// modules/features/catalog/data/datasources/sections_remote_datasource.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../../core/config/collections.dart';
import '../mappers/product_mini_mapper.dart';
import '../../domain/entities/product_mini.dart';

class SectionsRemoteDataSource {
  final FirebaseFirestore firestore;
  SectionsRemoteDataSource(this.firestore);

  Future<List<ProductMini>> fetchFeatured({int limit = 10}) async {
    try {
      final snap =
          await firestore
              .collection(Col.products)
              .where('isActive', isEqualTo: true)
              .orderBy('popularity', descending: true)
              .limit(limit)
              .get();

      return snap.docs.map((d) {
        return mapDocToProductMini(d);
      }).toList();
    } catch (_) {
      return const [];
    }
  }
}

 END FILE: modules/features/catalog/data/datasources/sections_remote_datasource.dart 

Dentro de /mappers:

----- FILE: modules/features/catalog/data/mappers/product_mini_mapper.dart -----
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../domain/entities/product_mini.dart';

ProductMini mapDocToProductMini(DocumentSnapshot<Map<String, dynamic>> doc) {
  final data = doc.data() ?? {};
  final price = data['basePrice'];
  return ProductMini(
    id: doc.id,
    name: (data['name'] ?? '').toString(),
    imageUrl: (data['imageUrl'] ?? '').toString().isEmpty
        ? null
        : (data['imageUrl'] as String),
    priceFrom: price is num ? price.toDouble() : null,
  );
}

--- END FILE: modules/features/catalog/data/mappers/product_mini_mapper.dart ---

Dentro de /models:

------ FILE: modules/features/catalog/data/models/admin_product_model.dart -----
import '../../domain/entities/admin_product.dart';

class AdminProductModel {
  final String id;
  final String categoryId;
  final String name;
  final double basePrice;
  final UnitType unitType;
  final int? unitsPerPack;
  final bool isVisible;
  final String? description;
  final List<String> variants;
  final String? imageUrl;

  const AdminProductModel({
    required this.id,
    required this.categoryId,
    required this.name,
    required this.basePrice,
    required this.unitType,
    this.unitsPerPack,
    this.isVisible = true,
    this.description,
    this.variants = const [],
    this.imageUrl,
  });

  factory AdminProductModel.fromJson(Map<String, dynamic> json, String id) {
    double toDouble(dynamic value) {
      if (value is num) return value.toDouble();
      if (value is String) return double.tryParse(value) ?? 0;
      return 0;
    }

    int? toInt(dynamic value) {
      if (value == null) return null;
      if (value is num) return value.toInt();
      if (value is String) return int.tryParse(value);
      return null;
    }

    List<String> toVariants(dynamic value) {
      if (value is List) {
        return value.map((item) {
          if (item is Map && item['name'] != null) {
            return item['name'].toString();
          }
          return item.toString();
        }).where((v) => v.isNotEmpty).toList();
      }
      return const [];
    }

    final unitTypeStr = (json['unitType'] ?? '').toString();
    return AdminProductModel(
      id: id,
      categoryId: (json['categoryId'] ?? '').toString(),
      name: (json['name'] ?? '').toString(),
      basePrice: toDouble(json['basePrice']),
      unitType: _unitTypeFromString(unitTypeStr),
      unitsPerPack: toInt(json['unitsPerPack']),
      isVisible: (json['isVisible'] ?? true) == true,
      description: (json['description'] ?? '').toString().isEmpty
          ? null
          : (json['description'] as String),
      variants: toVariants(json['variants']),
      imageUrl: (json['imageUrl'] ?? '').toString().isEmpty
          ? null
          : (json['imageUrl'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    final variantsJson = variants
        .map((v) => {'name': v})
        .where((item) => (item['name'] as String).isNotEmpty)
        .toList();
    return {
      'categoryId': categoryId,
      'name': name,
      'basePrice': basePrice,
      'unitType': _unitTypeToString(unitType),
      'unitsPerPack': unitsPerPack,
      'isVisible': isVisible,
      'description': description,
      'variants': variantsJson.isEmpty ? null : variantsJson,
      'imageUrl': imageUrl,
    }..removeWhere((_, value) => value == null);
  }

  AdminProduct toEntity() {
    return AdminProduct(
      id: id,
      categoryId: categoryId,
      name: name,
      basePrice: basePrice,
      unitType: unitType,
      unitsPerPack: unitsPerPack,
      isVisible: isVisible,
      description: description,
      variants: variants,
      imageUrl: imageUrl,
    );
  }

  factory AdminProductModel.fromEntity(AdminProduct entity) {
    return AdminProductModel(
      id: entity.id,
      categoryId: entity.categoryId,
      name: entity.name,
      basePrice: entity.basePrice,
      unitType: entity.unitType,
      unitsPerPack: entity.unitsPerPack,
      isVisible: entity.isVisible,
      description: entity.description,
      variants: entity.variants,
      imageUrl: entity.imageUrl,
    );
  }

  static UnitType _unitTypeFromString(String value) {
    switch (value) {
      case 'tray':
        return UnitType.tray;
      case 'combo':
        return UnitType.combo;
      case 'bottle':
        return UnitType.bottle;
      case 'unit':
      default:
        return UnitType.unit;
    }
  }

  static String _unitTypeToString(UnitType unitType) {
    switch (unitType) {
      case UnitType.tray:
        return 'tray';
      case UnitType.unit:
        return 'unit';
      case UnitType.combo:
        return 'combo';
      case UnitType.bottle:
        return 'bottle';
    }
  }
}

---- END FILE: modules/features/catalog/data/models/admin_product_model.dart ---

-------- FILE: modules/features/catalog/data/models/category_model.dart --------
// modules/features/catalog/data/models/category_model.dart
import '../../../../core/entities/image_crop_data.dart';
import '../../domain/entities/category.dart';

class CategoryModel extends Category {
  const CategoryModel({
    required super.id,
    required super.name,
    super.imageUrl,
    super.imageOriginalUrl,
    super.imageOriginalId,
    super.cropData,
    super.labelColor = 'neutral',
    super.visible = true,
    super.description,
    super.position = 0,
    super.productsCount = 0,
    super.iconKey,
  });

  factory CategoryModel.fromFirestore(String id, Map<String, dynamic>? data) {
    data ??= const {};
    final position = (data['position'] ?? data['order'] ?? 0) as num;
    return CategoryModel(
      id: id,
      name: (data['name'] ?? '').toString(),
      imageUrl: (data['imageUrl'] as String?)?.trim(),
      imageOriginalUrl: (data['imageOriginalUrl'] as String?)?.trim(),
      imageOriginalId: (data['imageOriginalId'] as String?)?.trim(),
      cropData: ImageCropData.fromMap(data['crop'] as Map<String, dynamic>?),
      labelColor: (data['labelColor'] ?? 'neutral').toString(),
      visible: (data['visible'] ?? true) as bool,
      description: (data['description'] as String?)?.trim(),
      position: position.toInt(),
      productsCount: ((data['productsCount'] ?? 0) as num).toInt(),
      iconKey: (data['icon'] ?? data['iconKey'])?.toString(),
    );
  }

  @override
  CategoryModel copyWith({
    String? id,
    String? name,
    String? imageUrl,
    String? imageOriginalUrl,
    String? imageOriginalId,
    ImageCropData? cropData,
    String? labelColor,
    bool? visible,
    String? description,
    int? position,
    int? productsCount,
    String? iconKey,
  }) {
    final base = super.copyWith(
      id: id,
      name: name,
      imageUrl: imageUrl,
      imageOriginalUrl: imageOriginalUrl,
      imageOriginalId: imageOriginalId,
      cropData: cropData,
      labelColor: labelColor,
      visible: visible,
      description: description,
      position: position,
      productsCount: productsCount,
      iconKey: iconKey,
    );
    return CategoryModel(
      id: base.id,
      name: base.name,
      imageUrl: base.imageUrl,
      imageOriginalUrl: base.imageOriginalUrl,
      imageOriginalId: base.imageOriginalId,
      cropData: base.cropData,
      labelColor: base.labelColor,
      visible: base.visible,
      description: base.description,
      position: base.position,
      productsCount: base.productsCount,
      iconKey: base.iconKey,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'imageUrl': imageUrl,
      'imageOriginalUrl': imageOriginalUrl,
      'imageOriginalId': imageOriginalId,
      'crop': cropData?.toMap(),
      'labelColor': labelColor,
      'visible': visible,
      'description': description,
      'position': position,
      'productsCount': productsCount,
      'icon': iconKey,
    };
  }
}

------ END FILE: modules/features/catalog/data/models/category_model.dart ------

------ FILE: modules/features/catalog/data/models/presentation_model.dart ------
import '../../domain/entities/presentation.dart';

class PresentationModel extends Presentation {
  const PresentationModel({
    required super.id,
    required super.name,
    required super.unitPrice,
    required super.minQty,
    super.imageUrl,
    super.order = 0,
  });

  factory PresentationModel.fromMap(Map<String, dynamic> map) => PresentationModel(
        id: (map['id'] as String),
        name: (map['name'] ?? '').toString(),
        unitPrice: (map['unitPrice'] ?? 0) is num ? (map['unitPrice'] as num).toDouble() : 0,
        minQty: (map['minQty'] ?? 1) is num ? (map['minQty'] as num).toInt() : 1,
        imageUrl: (map['imageUrl'] ?? '').toString().isEmpty ? null : (map['imageUrl'] as String),
        order: (map['order'] ?? 0) is num ? (map['order'] as num).toInt() : 0,
      );
}

---- END FILE: modules/features/catalog/data/models/presentation_model.dart ----

----- FILE: modules/features/catalog/data/models/public_product_model.dart -----
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../domain/entities/public_product.dart';

class PublicProductModel extends PublicProduct {
  const PublicProductModel({
    required super.id,
    required super.name,
    required super.categoryId,
    required super.basePrice,
    super.isVisible = true,
    super.description,
    super.sku,
    super.imageUrl,
    super.galleryImages = const [],
    super.cost,
    super.compareAtPrice,
    super.isActive = true,
    super.stock = 0,
    super.minStock = 0,
    super.tags = const [],
    super.popularity = 0,
    super.updatedAt,
    super.updatedBy,
  });

  factory PublicProductModel.fromMap(Map<String, dynamic> map) {
    List<String> stringList(dynamic value) {
      if (value is List) {
        return value.map((e) => e.toString()).toList();
      }
      return const [];
    }

    final gallery = stringList(map['gallery'] ?? map['images']);
    final tags = stringList(map['tags']);
    DateTime? parseDate(dynamic value) {
      if (value == null) return null;
      if (value is DateTime) return value;
      if (value is Timestamp) return value.toDate();
      if (value is int) return DateTime.fromMillisecondsSinceEpoch(value);
      if (value is String) return DateTime.tryParse(value);
      return null;
    }

    double toDouble(dynamic value) {
      if (value is num) return value.toDouble();
      if (value is String) return double.tryParse(value) ?? 0;
      return 0;
    }

    return PublicProductModel(
      id: map['id'] as String,
      name: (map['name'] ?? '').toString(),
      description: (map['description'] ?? '').toString().isEmpty
          ? null
          : (map['description'] as String),
      categoryId: (map['categoryId'] ?? '').toString(),
      sku: (map['sku'] ?? '').toString().isEmpty ? null : (map['sku'] as String),
      imageUrl: (map['imageUrl'] ?? '').toString().isEmpty
          ? null
          : (map['imageUrl'] as String),
      galleryImages: gallery,
      basePrice: toDouble(map['basePrice']),
      cost: toDouble(map['cost']),
      compareAtPrice: toDouble(map['compareAtPrice']),
      isActive: (map['isActive'] ?? true) == true,
      isVisible: (map['isVisible'] ?? map['isActive'] ?? true) == true,
      stock: (map['stock'] ?? 0) is num ? (map['stock'] as num).round() : 0,
      minStock:
          (map['minStock'] ?? 0) is num ? (map['minStock'] as num).round() : 0,
      tags: tags,
      popularity: (map['popularity'] ?? 0) is num ? (map['popularity'] as num) : 0,
      updatedAt: parseDate(map['updatedAt']),
      updatedBy: (map['updatedBy'] ?? '').toString().isEmpty
          ? null
          : (map['updatedBy'] as String),
    );
  }

  factory PublicProductModel.fromEntity(PublicProduct product) => PublicProductModel(
        id: product.id,
        name: product.name,
        description: product.description,
        categoryId: product.categoryId,
        sku: product.sku,
        imageUrl: product.imageUrl,
        galleryImages: product.galleryImages,
        basePrice: product.basePrice,
        cost: product.cost,
        compareAtPrice: product.compareAtPrice,
        isActive: product.isActive,
        isVisible: product.isVisible,
        stock: product.stock,
        minStock: product.minStock,
        tags: product.tags,
        popularity: product.popularity,
        updatedAt: product.updatedAt,
        updatedBy: product.updatedBy,
      );

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'description': description,
      'categoryId': categoryId,
      'sku': sku,
      'imageUrl': imageUrl,
      'gallery': galleryImages,
      'basePrice': basePrice,
      'cost': cost,
      'compareAtPrice': compareAtPrice,
      'isActive': isActive,
      'isVisible': isVisible,
      'stock': stock,
      'minStock': minStock,
      'tags': tags,
      'popularity': popularity,
      'updatedBy': updatedBy,
    }..removeWhere((_, value) => value == null);
  }
}

--- END FILE: modules/features/catalog/data/models/public_product_model.dart ---

Dentro de /repositories:

- FILE: modules/features/catalog/data/repositories/catalog_repository_impl.dart 
// modules/features/catalog/data/repositories/catalog_repository_impl.dart
import '../../domain/entities/admin_product_page.dart';
import '../../domain/entities/public_product.dart';
import '../../domain/entities/product_mini.dart';
import '../../domain/entities/presentation.dart';
import '../../domain/repositories/catalog_repository.dart';
import '../datasources/catalog_remote_datasource.dart';
import '../models/public_product_model.dart';
import '../models/presentation_model.dart';

class CatalogRepositoryImpl implements CatalogRepository {
  final CatalogRemoteDataSource remote;
  CatalogRepositoryImpl(this.remote);

  @override
  Future<PublicProduct?> getProduct(String productId) async {
    return remote.getProduct(productId);
  }

  @override
  Future<List<Presentation>> getPresentations(String productId) async {
    final list = await remote.getPresentations(productId);
    return list.map(PresentationModel.fromMap).toList();
  }

  @override
  Future<void> addOrUpdatePresentation({
    required String productId,
    required String? presentationId,
    required Presentation data,
  }) {
    return remote.addOrUpdatePresentation(
      productId: productId,
      presentationId: presentationId,
      data: {
        'name': data.name,
        'unitPrice': data.unitPrice,
        'minQty': data.minQty,
        'imageUrl': data.imageUrl,
        'order': data.order,
      },
    );
  }

  @override
  Future<List<PublicProduct>> getCatalogProducts({int limit = 50}) async {
    final list = await remote.getCatalogProducts(limit: limit);
    return list;
  }

  @override
  Future<List<ProductMini>> getProductsByCategory({
    required String categoryId,
    String? subcategory,
    int limit = 24,
  }) async {
    return remote.getProductsByCategory(
      categoryId: categoryId,
      subcategory: subcategory,
      limit: limit,
    );
  }

  Map<String, dynamic> _productToFirestore(PublicProduct product) {
    final model = PublicProductModel.fromEntity(product);
    final map = model.toMap();
    map['isActive'] = product.isActive;
    map['isVisible'] = product.isVisible;
    return map;
  }

  @override
  Future<AdminProductPage> getAdminProducts({
    String? categoryId,
    String? status,
    String? searchQuery,
    int limit = 20,
    String? startAfterId,
  }) async {
    final result = await remote.getAdminProducts(
      categoryId: categoryId,
      status: status,
      searchQuery: searchQuery,
      limit: limit,
      startAfterId: startAfterId,
    );
    return AdminProductPage(
      products: result.items,
      nextCursor: result.lastDocumentId,
      hasMore: result.hasMore,
    );
  }

  @override
  Future<PublicProduct> createProduct(PublicProduct product) async {
    final data = _productToFirestore(product);
    final newId = await remote.createProduct(data);
    return product.copyWith(id: newId);
  }

  @override
  Future<void> updateProduct(PublicProduct product) {
    final data = _productToFirestore(product);
    return remote.updateProduct(product.id, data);
  }

  @override
  Future<void> toggleProductVisibility(String productId, bool visible) {
    return remote.toggleProductVisibility(productId, visible);
  }
}

 END FILE: modules/features/catalog/data/repositories/catalog_repository_impl.dart 

 FILE: modules/features/catalog/data/repositories/catalog_settings_repository_impl.dart 
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../domain/repositories/catalog_settings_repository.dart';
import '../../../../core/services/functions/functions_client.dart';

class CatalogSettingsRepositoryImpl implements CatalogSettingsRepository {
  CatalogSettingsRepositoryImpl(
    this._firestore, {
    FunctionsClient? functionsClient,
  }) : _functions = functionsClient ?? FunctionsClient();

  final FirebaseFirestore _firestore;
  final FunctionsClient _functions;
  static const int _defaultPrimaryLimit = 6;
  static const int _minLimit = 1;
  static const int _maxLimit = 24;

  DocumentReference<Map<String, dynamic>> get _doc =>
      _firestore.collection('config').doc('catalog_settings');

  @override
  Future<int> getPrimaryCategoriesLimit() async {
    try {
      final snapshot = await _doc.get();
      if (snapshot.exists) {
        final data = snapshot.data();
        final value = data?['primaryCategoriesLimit'];
        if (value is int && value > 0) {
          return value;
        }
      }
    } catch (_) {
      // Si Firestore directo falla (permisos), se intenta por Cloud Function
      try {
        return await _fetchViaFunction();
      } catch (_) {
        // Ignora y devuelve default
      }
    }
    return _defaultPrimaryLimit;
  }

  @override
  Future<void> setPrimaryCategoriesLimit(int limit) async {
    final sanitized = limit.clamp(_minLimit, _maxLimit).toInt();
    try {
      await _doc.set(
        {'primaryCategoriesLimit': sanitized},
        SetOptions(merge: true),
      );
      return;
    } catch (_) {
      // Intento alternativo por Cloud Function en caso de permisos
      await _setViaFunction(sanitized);
    }
  }

  Future<int> _fetchViaFunction() async {
    final res =
        await _functions.call('getCatalogSettings') as Map<String, dynamic>? ??
        const {};
    final value = res['primaryCategoriesLimit'];
    if (value is int && value > 0) {
      return value;
    }
    return _defaultPrimaryLimit;
  }

  Future<void> _setViaFunction(int sanitized) {
    return _functions.call(
      'setCatalogSettings',
      data: {'primaryCategoriesLimit': sanitized},
    );
  }
}

 END FILE: modules/features/catalog/data/repositories/catalog_settings_repository_impl.dart 

 FILE: modules/features/catalog/data/repositories/categories_repository_impl.dart 
// modules/features/catalog/data/repositories/categories_repository_impl.dart
import '../../domain/entities/category.dart';
import '../../domain/repositories/categories_repository.dart';
import '../datasources/categories_remote_datasource.dart';
import '../models/category_model.dart';

class CategoriesRepositoryImpl implements CategoriesRepository {
  final CategoriesRemoteDataSource remote;
  CategoriesRepositoryImpl(this.remote);

  @override
  Future<List<Category>> getCategories({bool onlyVisible = false}) async {
    final list = await remote.fetchOnce(onlyVisible: onlyVisible);
    return list;
  }

  @override
  Stream<List<Category>> watchAll({bool onlyVisible = false}) =>
      remote.watchAll(onlyVisible: onlyVisible);

  @override
  Future<void> create(Category category) =>
      remote.create(_mapToModel(category));

  @override
  Future<void> update(Category category) =>
      remote.update(_mapToModel(category));

  @override
  Future<void> delete(String id) => remote.delete(id);

  @override
  Future<void> reorder(List<Category> ordered) =>
      remote.reorder(ordered.map(_mapToModel).toList());

  CategoryModel _mapToModel(Category category) {
    return CategoryModel(
      id: category.id,
      name: category.name,
      imageUrl: category.imageUrl,
      imageOriginalUrl: category.imageOriginalUrl,
      imageOriginalId: category.imageOriginalId,
      cropData: category.cropData,
      labelColor: category.labelColor,
      visible: category.visible,
      description: category.description,
      position: category.position,
      productsCount: category.productsCount,
      iconKey: category.iconKey,
    );
  }
}

 END FILE: modules/features/catalog/data/repositories/categories_repository_impl.dart 

 FILE: modules/features/catalog/data/repositories/products_repository_impl.dart 
import '../../domain/entities/admin_product.dart';
import '../../domain/repositories/products_repository.dart';
import '../datasources/products_remote_datasource.dart';
import '../models/admin_product_model.dart';

class ProductsRepositoryImpl implements ProductsRepository {
  final ProductsRemoteDataSource remote;
  ProductsRepositoryImpl(this.remote);

  @override
  Stream<List<AdminProduct>> watchAllProducts() {
    return remote.watchAll().map(
          (models) => models.map((model) => model.toEntity()).toList(),
        );
  }

  @override
  Stream<List<AdminProduct>> watchProductsByCategory(String categoryId) {
    return remote.watchByCategory(categoryId).map(
          (models) => models.map((model) => model.toEntity()).toList(),
        );
  }

  @override
  Future<AdminProduct> getProductById(String id) async {
    final model = await remote.getById(id);
    return model.toEntity();
  }

  @override
  Future<void> createProduct(AdminProduct product) {
    final model = AdminProductModel.fromEntity(product);
    return remote.create(model);
  }

  @override
  Future<void> updateProduct(AdminProduct product) {
    final model = AdminProductModel.fromEntity(product);
    return remote.update(model);
  }

  @override
  Future<void> deleteProduct(String id) => remote.delete(id);
}

 END FILE: modules/features/catalog/data/repositories/products_repository_impl.dart 

 FILE: modules/features/catalog/data/repositories/sections_repository_impl.dart 
// modules/features/catalog/data/repositories/sections_repository_impl.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/section.dart';
import '../../domain/entities/product_mini.dart';
import '../../domain/repositories/sections_repository.dart';
import '../../domain/value_objects/catalog_mode.dart';
import '../datasources/sections_remote_datasource.dart';

class SectionsRepositoryImpl implements SectionsRepository {
  final SectionsRemoteDataSource remote;
  final FirebaseFirestore firestore;
  SectionsRepositoryImpl(this.remote, this.firestore);

  @override
  Future<HomeSections> getHomeSections({required CatalogMode mode}) async {
    // Base editorial simple (mientras no haya mÃ©tricas reales)
    final featured = await remote.fetchFeatured(limit: 12);

    // PENDIENTE: historial del usuario (repeat) y combos reales.
    final repeat = <ProductMini>[];
    final combos = <ProductMini>[];
    final favorites = featured.take(6).toList();
    final combosFrom = 5.0;
    final bestSellers = featured.reversed.take(8).toList();
    final searchSource = featured;

    return HomeSections(
      forYou: featured.isNotEmpty ? featured : favorites,
      repeat: repeat,
      combos: combos,
      combosFrom: combosFrom,
      favorites: favorites,
      bestSellers: bestSellers,
      footerBanner: null,
      searchSource: searchSource,
    );
  }
}

 END FILE: modules/features/catalog/data/repositories/sections_repository_impl.dart 

Dentro de /domain:

Dentro de /entities:

------- FILE: modules/features/catalog/domain/entities/admin_product.dart ------
import 'package:flutter/foundation.dart';

import 'base_product.dart';

enum UnitType { tray, unit, combo, bottle }

class AdminProduct extends BaseProduct {
  final UnitType unitType;
  final int? unitsPerPack;
  final String? description;
  final List<String> variants;
  final String? imageUrl;

  const AdminProduct({
    required super.id,
    required super.name,
    required super.categoryId,
    required super.basePrice,
    super.isVisible = true,
    required this.unitType,
    this.unitsPerPack,
    this.description,
    this.variants = const [],
    this.imageUrl,
  });

  factory AdminProduct.empty() => const AdminProduct(
        id: '',
        categoryId: '',
        name: '',
        basePrice: 0,
        unitType: UnitType.unit,
        isVisible: true,
      );

  AdminProduct copyWith({
    String? id,
    String? categoryId,
    String? name,
    double? basePrice,
    UnitType? unitType,
    int? unitsPerPack,
    bool? isVisible,
    String? description,
    List<String>? variants,
    String? imageUrl,
  }) {
    return AdminProduct(
      id: id ?? this.id,
      categoryId: categoryId ?? this.categoryId,
      name: name ?? this.name,
      basePrice: basePrice ?? this.basePrice,
      unitType: unitType ?? this.unitType,
      unitsPerPack: unitsPerPack ?? this.unitsPerPack,
      isVisible: isVisible ?? this.isVisible,
      description: description ?? this.description,
      variants: variants ?? this.variants,
      imageUrl: imageUrl ?? this.imageUrl,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AdminProduct &&
        other.id == id &&
        other.categoryId == categoryId &&
        other.name == name &&
        other.basePrice == basePrice &&
        other.unitType == unitType &&
        other.unitsPerPack == unitsPerPack &&
        other.isVisible == isVisible &&
        other.description == description &&
        listEquals(other.variants, variants) &&
        other.imageUrl == imageUrl;
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        categoryId,
        name,
        basePrice,
        unitType,
        unitsPerPack,
        isVisible,
        description,
        Object.hashAll(variants),
        imageUrl,
      ]);
}

----- END FILE: modules/features/catalog/domain/entities/admin_product.dart ----

---- FILE: modules/features/catalog/domain/entities/admin_product_page.dart ----
import 'public_product.dart';

class AdminProductPage {
  final List<PublicProduct> products;
  final String? nextCursor;
  final bool hasMore;

  const AdminProductPage({
    required this.products,
    this.nextCursor,
    required this.hasMore,
  });
}

-- END FILE: modules/features/catalog/domain/entities/admin_product_page.dart --

------- FILE: modules/features/catalog/domain/entities/base_product.dart -------
abstract class BaseProduct {
  final String id;
  final String name;
  final String categoryId;
  final double basePrice;
  final bool isVisible;

  const BaseProduct({
    required this.id,
    required this.name,
    required this.categoryId,
    required this.basePrice,
    this.isVisible = true,
  });
}

----- END FILE: modules/features/catalog/domain/entities/base_product.dart -----

--------- FILE: modules/features/catalog/domain/entities/category.dart ---------
// modules/features/catalog/domain/entities/category.dart
import '../../../../core/entities/image_crop_data.dart';

class Category {
  final String id;
  final String name;
  final String? imageUrl;
  final String? imageOriginalUrl;
  final String? imageOriginalId;
  final ImageCropData? cropData;
  final String labelColor;
  final bool visible;
  final String? description;
  final int position;
  final int productsCount;
  final String? iconKey;

  const Category({
    required this.id,
    required this.name,
    this.imageUrl,
    this.imageOriginalUrl,
    this.imageOriginalId,
    this.cropData,
    this.labelColor = 'neutral',
    this.visible = true,
    this.description,
    this.position = 0,
    this.productsCount = 0,
    this.iconKey,
  });

  Category copyWith({
    String? id,
    String? name,
    String? imageUrl,
    String? imageOriginalUrl,
    String? imageOriginalId,
    ImageCropData? cropData,
    String? labelColor,
    bool? visible,
    String? description,
    int? position,
    int? productsCount,
    String? iconKey,
  }) {
    return Category(
      id: id ?? this.id,
      name: name ?? this.name,
      imageUrl: imageUrl ?? this.imageUrl,
      imageOriginalUrl: imageOriginalUrl ?? this.imageOriginalUrl,
      imageOriginalId: imageOriginalId ?? this.imageOriginalId,
      cropData: cropData ?? this.cropData,
      labelColor: labelColor ?? this.labelColor,
      visible: visible ?? this.visible,
      description: description ?? this.description,
      position: position ?? this.position,
      productsCount: productsCount ?? this.productsCount,
      iconKey: iconKey ?? this.iconKey,
    );
  }
}

------- END FILE: modules/features/catalog/domain/entities/category.dart -------

------- FILE: modules/features/catalog/domain/entities/presentation.dart -------
class Presentation {
  final String id; // nuevo => '' al crear
  final String name;
  final double unitPrice;
  final int minQty;
  final String? imageUrl;
  final int order;

  const Presentation({
    required this.id,
    required this.name,
    required this.unitPrice,
    required this.minQty,
    this.imageUrl,
    this.order = 0,
  });

  Presentation copyWith({
    String? id,
    String? name,
    double? unitPrice,
    int? minQty,
    String? imageUrl,
    int? order,
  }) => Presentation(
    id: id ?? this.id,
    name: name ?? this.name,
    unitPrice: unitPrice ?? this.unitPrice,
    minQty: minQty ?? this.minQty,
    imageUrl: imageUrl ?? this.imageUrl,
    order: order ?? this.order,
  );
}

----- END FILE: modules/features/catalog/domain/entities/presentation.dart -----

------- FILE: modules/features/catalog/domain/entities/product_mini.dart -------
// modules/features/catalog/domain/entities/product_mini.dart
class ProductMini {
  final String id;
  final String name;
  final String? imageUrl;
  final double? priceFrom;

  const ProductMini({
    required this.id,
    required this.name,
    this.imageUrl,
    this.priceFrom,
  });
}

----- END FILE: modules/features/catalog/domain/entities/product_mini.dart -----

------ FILE: modules/features/catalog/domain/entities/public_product.dart ------
import 'base_product.dart';

class PublicProduct extends BaseProduct {
  final String? description;
  final String? sku;
  final String? imageUrl;
  final List<String> galleryImages;
  final double? cost;
  final double? compareAtPrice;
  final bool isActive;
  final int stock;
  final int minStock;
  final List<String> tags;
  final num popularity;
  final DateTime? updatedAt;
  final String? updatedBy;

  const PublicProduct({
    required super.id,
    required super.name,
    required super.categoryId,
    required super.basePrice,
    super.isVisible,
    this.description,
    this.sku,
    this.imageUrl,
    this.galleryImages = const [],
    this.cost,
    this.compareAtPrice,
    this.isActive = true,
    this.stock = 0,
    this.minStock = 0,
    this.tags = const [],
    this.popularity = 0,
    this.updatedAt,
    this.updatedBy,
  });

  PublicProduct copyWith({
    String? id,
    String? name,
    String? description,
    String? categoryId,
    String? sku,
    String? imageUrl,
    List<String>? galleryImages,
    double? basePrice,
    double? cost,
    double? compareAtPrice,
    bool? isActive,
    bool? isVisible,
    int? stock,
    int? minStock,
    List<String>? tags,
    num? popularity,
    DateTime? updatedAt,
    String? updatedBy,
  }) {
    return PublicProduct(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      categoryId: categoryId ?? this.categoryId,
      sku: sku ?? this.sku,
      imageUrl: imageUrl ?? this.imageUrl,
      galleryImages: galleryImages ?? this.galleryImages,
      basePrice: basePrice ?? this.basePrice,
      cost: cost ?? this.cost,
      compareAtPrice: compareAtPrice ?? this.compareAtPrice,
      isActive: isActive ?? this.isActive,
      isVisible: isVisible ?? this.isVisible,
      stock: stock ?? this.stock,
      minStock: minStock ?? this.minStock,
      tags: tags ?? this.tags,
      popularity: popularity ?? this.popularity,
      updatedAt: updatedAt ?? this.updatedAt,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }
}

---- END FILE: modules/features/catalog/domain/entities/public_product.dart ----

---------- FILE: modules/features/catalog/domain/entities/section.dart ---------
// modules/features/catalog/domain/entities/section.dart
import 'product_mini.dart';

class FooterBanner {
  final String title;
  final String subtitle;
  final String? imageUrl;
  const FooterBanner({
    required this.title,
    required this.subtitle,
    this.imageUrl,
  });
}

class HomeSections {
  final List<ProductMini> forYou;
  final List<ProductMini> repeat;
  final List<ProductMini> combos;
  final double combosFrom;
  final List<ProductMini> favorites;
  final List<ProductMini> bestSellers;
  final FooterBanner? footerBanner;

  /// Fuente para bÃºsqueda rÃ¡pida (lista plana de productos mÃ­nimos).
  final List<ProductMini> searchSource;

  HomeSections({
    required this.forYou,
    required this.repeat,
    required this.combos,
    required this.combosFrom,
    required this.favorites,
    required this.bestSellers,
    required this.searchSource,
    this.footerBanner,
  });
}

-------- END FILE: modules/features/catalog/domain/entities/section.dart -------

Dentro de /repositories:

-- FILE: modules/features/catalog/domain/repositories/catalog_repository.dart --
// modules/features/catalog/domain/repositories/catalog_repository.dart
import '../entities/admin_product_page.dart';
import '../entities/public_product.dart';
import '../entities/product_mini.dart';
import '../entities/presentation.dart';

abstract class CatalogRepository {
  Future<PublicProduct?> getProduct(String productId);
  Future<List<Presentation>> getPresentations(String productId);

  Future<void> addOrUpdatePresentation({
    required String productId,
    required String? presentationId, // null => add
    required Presentation data,
  });

  Future<List<PublicProduct>> getCatalogProducts({int limit});

  /// Nuevo: listado por categorÃ­a/subcategorÃ­a para la CategoryPage
  Future<List<ProductMini>> getProductsByCategory({
    required String categoryId,
    String? subcategory,
    int limit,
  });

  Future<AdminProductPage> getAdminProducts({
    String? categoryId,
    String? status,
    String? searchQuery,
    int limit,
    String? startAfterId,
  });

  Future<PublicProduct> createProduct(PublicProduct product);
  Future<void> updateProduct(PublicProduct product);
  Future<void> toggleProductVisibility(String productId, bool visible);
}

 END FILE: modules/features/catalog/domain/repositories/catalog_repository.dart 

 FILE: modules/features/catalog/domain/repositories/catalog_settings_repository.dart 
abstract class CatalogSettingsRepository {
  Future<int> getPrimaryCategoriesLimit();
  Future<void> setPrimaryCategoriesLimit(int limit);
}

 END FILE: modules/features/catalog/domain/repositories/catalog_settings_repository.dart 

- FILE: modules/features/catalog/domain/repositories/categories_repository.dart 
// modules/features/catalog/domain/repositories/categories_repository.dart
import '../entities/category.dart';

abstract class CategoriesRepository {
  Future<List<Category>> getCategories({bool onlyVisible = false});
  Stream<List<Category>> watchAll({bool onlyVisible = false});
  Future<void> create(Category category);
  Future<void> update(Category category);
  Future<void> delete(String id);
  Future<void> reorder(List<Category> ordered);
}

 END FILE: modules/features/catalog/domain/repositories/categories_repository.dart 

-- FILE: modules/features/catalog/domain/repositories/products_repository.dart -
import '../entities/admin_product.dart';

abstract class ProductsRepository {
  Stream<List<AdminProduct>> watchAllProducts();
  Stream<List<AdminProduct>> watchProductsByCategory(String categoryId);
  Future<AdminProduct> getProductById(String id);
  Future<void> createProduct(AdminProduct product);
  Future<void> updateProduct(AdminProduct product);
  Future<void> deleteProduct(String id);
}

 END FILE: modules/features/catalog/domain/repositories/products_repository.dart 

-- FILE: modules/features/catalog/domain/repositories/sections_repository.dart -
// modules/features/catalog/domain/repositories/sections_repository.dart
import '../entities/section.dart';
import '../value_objects/catalog_mode.dart';

abstract class SectionsRepository {
  Future<HomeSections> getHomeSections({required CatalogMode mode});
}

 END FILE: modules/features/catalog/domain/repositories/sections_repository.dart 

Dentro de /usecases:

----- FILE: modules/features/catalog/domain/usecases/add_presentation.dart -----
import '../entities/presentation.dart';
import '../repositories/catalog_repository.dart';

class AddPresentation {
  final CatalogRepository repo;
  AddPresentation(this.repo);

  Future<void> call({
    required String productId,
    required Presentation data,
    String? presentationId,
  }) {
    return repo.addOrUpdatePresentation(
      productId: productId,
      presentationId: presentationId,
      data: data,
    );
    // Solo se llama cuando pulsas GUARDAR â evita escribir por cada cambio.
  }
}

--- END FILE: modules/features/catalog/domain/usecases/add_presentation.dart ---

------ FILE: modules/features/catalog/domain/usecases/create_category.dart -----
import '../entities/category.dart';
import '../repositories/categories_repository.dart';

class CreateCategory {
  final CategoriesRepository repository;
  const CreateCategory(this.repository);

  Future<void> call(Category category) => repository.create(category);
}

---- END FILE: modules/features/catalog/domain/usecases/create_category.dart ---

------ FILE: modules/features/catalog/domain/usecases/create_product.dart ------
import '../entities/public_product.dart';
import '../repositories/catalog_repository.dart';

class CreateProduct {
  final CatalogRepository repo;
  CreateProduct(this.repo);

  Future<PublicProduct> call(PublicProduct product) {
    return repo.createProduct(product);
  }
}

---- END FILE: modules/features/catalog/domain/usecases/create_product.dart ----

------ FILE: modules/features/catalog/domain/usecases/delete_category.dart -----
import '../repositories/categories_repository.dart';

class DeleteCategory {
  final CategoriesRepository repository;
  const DeleteCategory(this.repository);

  Future<void> call(String id) => repository.delete(id);
}

---- END FILE: modules/features/catalog/domain/usecases/delete_category.dart ---

---- FILE: modules/features/catalog/domain/usecases/get_admin_products.dart ----
import '../entities/admin_product_page.dart';
import '../repositories/catalog_repository.dart';

class GetAdminProducts {
  final CatalogRepository repo;
  GetAdminProducts(this.repo);

  Future<AdminProductPage> call({
    String? categoryId,
    String? status,
    String? searchQuery,
    int limit = 20,
    String? startAfterId,
  }) {
    return repo.getAdminProducts(
      categoryId: categoryId,
      status: status,
      searchQuery: searchQuery,
      limit: limit,
      startAfterId: startAfterId,
    );
  }
}

-- END FILE: modules/features/catalog/domain/usecases/get_admin_products.dart --

------ FILE: modules/features/catalog/domain/usecases/get_categories.dart ------
// modules/features/catalog/domain/usecases/get_categories.dart
import '../entities/category.dart';
import '../repositories/categories_repository.dart';

class GetCategories {
  final CategoriesRepository repo;
  GetCategories(this.repo);
  Future<List<Category>> call({bool onlyVisible = false}) =>
      repo.getCategories(onlyVisible: onlyVisible);
}

---- END FILE: modules/features/catalog/domain/usecases/get_categories.dart ----

----- FILE: modules/features/catalog/domain/usecases/get_home_sections.dart ----
// modules/features/catalog/domain/usecases/get_home_sections.dart
import '../entities/section.dart';
import '../repositories/sections_repository.dart';
import '../value_objects/catalog_mode.dart';

class GetHomeSections {
  final SectionsRepository repo;
  GetHomeSections(this.repo);

  Future<HomeSections> call({required CatalogMode mode}) {
    return repo.getHomeSections(mode: mode);
  }
}

--- END FILE: modules/features/catalog/domain/usecases/get_home_sections.dart --

 FILE: modules/features/catalog/domain/usecases/get_primary_categories_limit.dart 
import '../repositories/catalog_settings_repository.dart';

class GetPrimaryCategoriesLimit {
  final CatalogSettingsRepository repository;
  const GetPrimaryCategoriesLimit(this.repository);

  Future<int> call() => repository.getPrimaryCategoriesLimit();
}

 END FILE: modules/features/catalog/domain/usecases/get_primary_categories_limit.dart 

-------- FILE: modules/features/catalog/domain/usecases/get_product.dart -------
import '../entities/public_product.dart';
import '../repositories/catalog_repository.dart';

class GetProduct {
  final CatalogRepository repo;
  GetProduct(this.repo);

  Future<PublicProduct?> call(String productId) {
    return repo.getProduct(productId);
  }
}

------ END FILE: modules/features/catalog/domain/usecases/get_product.dart -----

- FILE: modules/features/catalog/domain/usecases/get_products_by_category.dart -
// modules/features/catalog/domain/usecases/get_products_by_category.dart
import '../entities/product_mini.dart';
import '../repositories/catalog_repository.dart';

class GetProductsByCategory {
  final CatalogRepository repo;
  GetProductsByCategory(this.repo);

  Future<List<ProductMini>> call({
    required String categoryId,
    String? subcategory,
    int limit = 24,
  }) {
    return repo.getProductsByCategory(
      categoryId: categoryId,
      subcategory: subcategory,
      limit: limit,
    );
  }
}

 END FILE: modules/features/catalog/domain/usecases/get_products_by_category.dart 

 FILE: modules/features/catalog/domain/usecases/get_products_with_presentations.dart 
import '../entities/public_product.dart';
import '../entities/presentation.dart';
import '../repositories/catalog_repository.dart';

class GetProductsWithPresentations {
  final CatalogRepository repo;
  GetProductsWithPresentations(this.repo);

  Future<({PublicProduct? product, List<Presentation> presentations})> call(String productId) async {
    final p = await repo.getProduct(productId);
    final pres = await repo.getPresentations(productId);
    return (product: p, presentations: pres);
  }
}
 END FILE: modules/features/catalog/domain/usecases/get_products_with_presentations.dart 

---- FILE: modules/features/catalog/domain/usecases/reorder_categories.dart ----
import '../entities/category.dart';
import '../repositories/categories_repository.dart';

class ReorderCategories {
  final CategoriesRepository repository;
  const ReorderCategories(this.repository);

  Future<void> call(List<Category> ordered) => repository.reorder(ordered);
}

-- END FILE: modules/features/catalog/domain/usecases/reorder_categories.dart --

 FILE: modules/features/catalog/domain/usecases/set_primary_categories_limit.dart 
import '../repositories/catalog_settings_repository.dart';

class SetPrimaryCategoriesLimit {
  final CatalogSettingsRepository repository;
  const SetPrimaryCategoriesLimit(this.repository);

  Future<void> call(int limit) => repository.setPrimaryCategoriesLimit(limit);
}

 END FILE: modules/features/catalog/domain/usecases/set_primary_categories_limit.dart 

- FILE: modules/features/catalog/domain/usecases/toggle_product_visibility.dart 
import '../repositories/catalog_repository.dart';

class ToggleProductVisibility {
  final CatalogRepository repo;
  ToggleProductVisibility(this.repo);

  Future<void> call(String productId, bool visible) {
    return repo.toggleProductVisibility(productId, visible);
  }
}

 END FILE: modules/features/catalog/domain/usecases/toggle_product_visibility.dart 

------ FILE: modules/features/catalog/domain/usecases/update_category.dart -----
import '../entities/category.dart';
import '../repositories/categories_repository.dart';

class UpdateCategory {
  final CategoriesRepository repository;
  const UpdateCategory(this.repository);

  Future<void> call(Category category) => repository.update(category);
}

---- END FILE: modules/features/catalog/domain/usecases/update_category.dart ---

------ FILE: modules/features/catalog/domain/usecases/update_product.dart ------
import '../entities/public_product.dart';
import '../repositories/catalog_repository.dart';

class UpdateProduct {
  final CatalogRepository repo;
  UpdateProduct(this.repo);

  Future<void> call(PublicProduct product) {
    return repo.updateProduct(product);
  }
}

---- END FILE: modules/features/catalog/domain/usecases/update_product.dart ----

-- FILE: modules/features/catalog/domain/usecases/watch_categories_stream.dart -
import '../entities/category.dart';
import '../repositories/categories_repository.dart';

class WatchCategoriesStream {
  final CategoriesRepository repository;
  const WatchCategoriesStream(this.repository);

  Stream<List<Category>> call({bool onlyVisible = false}) =>
      repository.watchAll(onlyVisible: onlyVisible);
}

 END FILE: modules/features/catalog/domain/usecases/watch_categories_stream.dart 

Dentro de /admin:

 FILE: modules/features/catalog/domain/usecases/admin/delete_product_usecase.dart 
import '../../repositories/products_repository.dart';

class DeleteProductUseCase {
  final ProductsRepository repository;
  DeleteProductUseCase(this.repository);

  Future<void> call(String id) => repository.deleteProduct(id);
}

 END FILE: modules/features/catalog/domain/usecases/admin/delete_product_usecase.dart 

 FILE: modules/features/catalog/domain/usecases/admin/save_product_usecase.dart 
import '../../entities/admin_product.dart';
import '../../repositories/products_repository.dart';

class SaveProductUseCase {
  final ProductsRepository repository;
  SaveProductUseCase(this.repository);

  Future<void> call(AdminProduct product) {
    final isNew = product.id.isEmpty || product == AdminProduct.empty();
    if (isNew) {
      return repository.createProduct(product);
    }
    return repository.updateProduct(product);
  }
}

 END FILE: modules/features/catalog/domain/usecases/admin/save_product_usecase.dart 

Dentro de /browse:

 FILE: modules/features/catalog/domain/usecases/browse/get_product_usecase.dart 
import '../../entities/admin_product.dart';
import '../../repositories/products_repository.dart';

class GetProductUseCase {
  final ProductsRepository repository;
  GetProductUseCase(this.repository);

  Future<AdminProduct> call(String id) => repository.getProductById(id);
}

 END FILE: modules/features/catalog/domain/usecases/browse/get_product_usecase.dart 

 FILE: modules/features/catalog/domain/usecases/browse/watch_all_products_usecase.dart 
import '../../entities/admin_product.dart';
import '../../repositories/products_repository.dart';

class WatchAllProductsUseCase {
  final ProductsRepository repository;
  WatchAllProductsUseCase(this.repository);

  Stream<List<AdminProduct>> call() => repository.watchAllProducts();
}

 END FILE: modules/features/catalog/domain/usecases/browse/watch_all_products_usecase.dart 

 FILE: modules/features/catalog/domain/usecases/browse/watch_products_by_category_usecase.dart 
import '../../entities/admin_product.dart';
import '../../repositories/products_repository.dart';

class WatchProductsByCategoryUseCase {
  final ProductsRepository repository;
  WatchProductsByCategoryUseCase(this.repository);

  Stream<List<AdminProduct>> call(String categoryId) =>
      repository.watchProductsByCategory(categoryId);
}

 END FILE: modules/features/catalog/domain/usecases/browse/watch_products_by_category_usecase.dart 

Dentro de /value_objects:

----- FILE: modules/features/catalog/domain/value_objects/catalog_mode.dart ----
// modules/features/catalog/domain/value_objects/catalog_mode.dart
enum CatalogMode { oficial, vitrina }

--- END FILE: modules/features/catalog/domain/value_objects/catalog_mode.dart --

Dentro de /presentation:

Dentro de /admin:

Dentro de /blocs:

Dentro de /product_form:

 FILE: modules/features/catalog/presentation/admin/blocs/product_form/product_form_cubit.dart 
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:http/http.dart' as http;

import '../../../../domain/entities/admin_product.dart';
import '../../../../domain/usecases/admin/save_product_usecase.dart';
import '../../../../domain/usecases/browse/get_product_usecase.dart';
import 'product_form_state.dart';
import 'package:flutter_application_emprendedoras/modules/core/config/storage_config.dart';
import 'package:flutter_application_emprendedoras/modules/core/config/storage_flags.dart';
import 'package:flutter_application_emprendedoras/modules/core/services/media/i_image_source.dart';
import 'package:flutter_application_emprendedoras/modules/core/services/media/image_picker_service.dart';
import 'package:flutter_application_emprendedoras/modules/core/services/storage/cloudinary_storage_service.dart';
import 'package:flutter_application_emprendedoras/modules/core/services/storage/firebase_storage_service.dart'
  as fbstore;
import 'package:flutter_application_emprendedoras/modules/core/services/storage/i_file_storage_service.dart';
import 'package:flutter_application_emprendedoras/modules/core/utils/data/image_bytes.dart';
import '../../../../../../core/widgets/media/avatar_cropper_page.dart';
import '../../../../../../core/services/storage/cloudinary_maintenance_api.dart';

class ProductFormCubit extends Cubit<ProductFormState> {
  final SaveProductUseCase _saveProductUseCase;
  final GetProductUseCase? _getProductUseCase;
  final IImagePickerService _imagePicker;
  final IFileStorageService _storage;
  final IFileStorageService? _fallbackStorage;
  final CloudinaryMaintenanceApi _maintenance;
  Uint8List? _pendingOriginalBytes;
  String? _pendingOriginalMime;
  final String _draftId =
      'product-draft-${DateTime.now().millisecondsSinceEpoch}';

  ProductFormCubit({
    required SaveProductUseCase saveProductUseCase,
    GetProductUseCase? getProductUseCase,
    IImagePickerService? imagePicker,
    IFileStorageService? storage,
    IFileStorageService? fallbackStorage,
    CloudinaryMaintenanceApi? maintenance,
  })  : _saveProductUseCase = saveProductUseCase,
        _getProductUseCase = getProductUseCase,
        _imagePicker = imagePicker ?? ImagePickerService(),
        _storage = storage ?? CloudinaryStorageService(),
        _fallbackStorage =
            fallbackStorage ??
            (StorageFlags.enableFirebaseFallback
                ? fbstore.FirebaseStorageService()
                : null),
        _maintenance = maintenance ?? CloudinaryMaintenanceApi(),
        super(const ProductFormState());

  void initForCreate({String? preselectedCategoryId}) {
    emit(
      ProductFormState(
        selectedCategoryId: preselectedCategoryId,
        isVisible: true,
        isEditing: false,
        dirty: false,
      ),
    );
  }

  Future<void> loadById(String id) async {
    final usecase = _getProductUseCase;
    if (usecase == null) return;
    emit(state.copyWith(isSaving: true, resetError: true, resetSuccess: true));
    try {
      final product = await usecase(id);
      initForEdit(product);
    } catch (e) {
      emit(state.copyWith(isSaving: false, errorMessage: e.toString()));
    }
  }

  void initForEdit(AdminProduct product) {
    emit(
      ProductFormState(
        initialProduct: product,
        isEditing: true,
        selectedCategoryId: product.categoryId,
        name: product.name,
        unitType: product.unitType,
        unitsPerPack: product.unitsPerPack,
        basePrice: product.basePrice,
        isVisible: product.isVisible,
        variants: product.variants,
        description: product.description,
        imageUrl: product.imageUrl,
        dirty: false,
      ),
    );
  }

  Future<void> pickImage(
    NavigatorState navigator,
    AppImageSource source,
  ) async {
    try {
      final picked = await _imagePicker.pick(source);
      if (picked == null) return;
      final mime =
          picked.mimeType ??
          ImageBytesHelper.sniffContentType(
            picked.bytes,
            fallbackName: picked.fileName,
          ) ??
          'image/jpeg';
      final validation = _validateImage(picked.bytes, mime);
      if (validation != null) {
        emit(state.copyWith(errorMessage: validation));
        return;
      }
      emit(state.copyWith(processingImage: true, errorMessage: null));
      final result = await _cropImage(navigator, picked.bytes);
      if (result == null) {
        emit(state.copyWith(processingImage: false));
        return;
      }
      _pendingOriginalBytes = picked.bytes;
      _pendingOriginalMime = mime;
      _setLocalImage(bytes: result.previewBytes, mime: 'image/jpeg');
    } catch (_) {
      emit(
        state.copyWith(
          processingImage: false,
          errorMessage:
              'No se pudo abrir la camara o galeria. Intenta nuevamente.',
        ),
      );
    }
  }

  void clearImage() {
    _pendingOriginalBytes = null;
    _pendingOriginalMime = null;
    emit(
      state.copyWith(
        localImageBytes: null,
        localImageMime: null,
        imageUrl: null,
        dirty: true,
        resetSuccess: true,
        resetError: true,
      ),
    );
  }

  void onCategoryChanged(String categoryId) {
    emit(
      state.copyWith(
        selectedCategoryId: categoryId,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void onNameChanged(String value) {
    emit(
      state.copyWith(
        name: value,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void onUnitTypeChanged(UnitType unitType) {
    emit(
      state.copyWith(
        unitType: unitType,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void onUnitsPerPackChanged(String value) {
    final parsed = value.trim().isEmpty ? null : int.tryParse(value.trim());
    emit(
      state.copyWith(
        unitsPerPack: parsed,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void onBasePriceChanged(String value) {
    final parsed = double.tryParse(value.replaceAll(',', '.'));
    emit(
      state.copyWith(
        basePrice: parsed,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void onVisibilityToggled(bool isVisible) {
    emit(
      state.copyWith(
        isVisible: isVisible,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void onDescriptionChanged(String value) {
    emit(
      state.copyWith(
        description: value,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void addVariant() {
    final updated = List<String>.from(state.variants)..add('');
    emit(
      state.copyWith(
        variants: updated,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void updateVariant(int index, String value) {
    if (index < 0 || index >= state.variants.length) return;
    final updated = List<String>.from(state.variants);
    updated[index] = value;
    emit(
      state.copyWith(
        variants: updated,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  void removeVariant(int index) {
    if (index < 0 || index >= state.variants.length) return;
    final updated = List<String>.from(state.variants)..removeAt(index);
    emit(
      state.copyWith(
        variants: updated,
        dirty: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
  }

  Future<void> importImageFromUrl(
    NavigatorState navigator,
    String url,
  ) async {
    final trimmed = url.trim();
    if (trimmed.isEmpty) return;
    Uri? uri;
    try {
      uri = Uri.parse(trimmed);
    } catch (_) {
      emit(state.copyWith(errorMessage: 'URL invalida. Revisa el enlace.'));
      return;
    }
    emit(state.copyWith(processingImage: true, errorMessage: null));
    try {
      final response = await http.get(uri);
      if (response.statusCode < 200 || response.statusCode >= 300) {
        throw Exception('Respuesta ${response.statusCode}');
      }
      final bytes = response.bodyBytes;
      final headerMime = response.headers['content-type']?.split(';').first;
      final mime =
          headerMime ??
          ImageBytesHelper.sniffContentType(bytes, fallbackName: uri.path) ??
          'image/jpeg';
      final validation = _validateImage(bytes, mime);
      if (validation != null) {
        emit(state.copyWith(processingImage: false, errorMessage: validation));
        return;
      }
      final result = await _cropImage(navigator, bytes);
      if (result == null) {
        emit(state.copyWith(processingImage: false));
        return;
      }
      _pendingOriginalBytes = bytes;
      _pendingOriginalMime = mime;
      _setLocalImage(bytes: result.previewBytes, mime: 'image/jpeg');
    } catch (e) {
      emit(
        state.copyWith(
          processingImage: false,
          errorMessage: 'No se pudo descargar la imagen. $e',
        ),
      );
    }
  }

  Future<void> submit() async {
    if (!state.isValid) {
      emit(
        state.copyWith(
          errorMessage: 'Completa los campos obligatorios',
          saveSuccess: false,
        ),
      );
      return;
    }
    emit(
      state.copyWith(
        isSaving: true,
        resetError: true,
        resetSuccess: true,
      ),
    );
    UploadedFile? uploadedOriginal;
    final hasBytes =
        _pendingOriginalBytes != null && _pendingOriginalBytes!.isNotEmpty;
    if (hasBytes) {
      try {
        uploadedOriginal = await _uploadBytes(
          bytes: _pendingOriginalBytes!,
          contentType: _pendingOriginalMime ?? 'image/jpeg',
          baseName: 'product_image',
          publicIdHint: 'product_$_resolvedStorageId',
        );
      } catch (_) {
        emit(
          state.copyWith(
            isSaving: false,
            errorMessage: 'No se pudo subir la imagen. Intenta nuevamente.',
          ),
        );
        return;
      }
    }
    final variants = state.variants
        .map((v) => v.trim())
        .where((v) => v.isNotEmpty)
        .toList();
    final product = AdminProduct(
      id: state.isEditing ? (state.initialProduct?.id ?? '') : '',
      categoryId: state.selectedCategoryId!.trim(),
      name: state.name.trim(),
      basePrice: state.basePrice ?? 0,
      unitType: state.unitType!,
      unitsPerPack: state.unitsPerPack,
      isVisible: state.isVisible,
      description:
          (state.description ?? '').trim().isEmpty
              ? null
              : state.description!.trim(),
      variants: variants,
      imageUrl:
          uploadedOriginal?.url ??
          ((state.imageUrl ?? '').isEmpty ? null : state.imageUrl?.trim()),
    );

    try {
      await _saveProductUseCase(product);
      emit(
        state.copyWith(
          isSaving: false,
          saveSuccess: true,
          dirty: false,
          initialProduct: product,
          isEditing: true,
          localImageBytes: null,
          localImageMime: null,
        ),
      );
      _pendingOriginalBytes = null;
      _pendingOriginalMime = null;
    } catch (e) {
      // If we uploaded an asset but saving the product failed, attempt rollback
      if (uploadedOriginal != null && uploadedOriginal.publicId != null) {
        try {
          await _maintenance.deleteByPublicId(uploadedOriginal.publicId!);
        } catch (_) {
          // best-effort: log and continue to report the original error
        }
      }
      emit(
        state.copyWith(
          isSaving: false,
          errorMessage: e.toString(),
        ),
      );
    }
  }

  String? _validateImage(Uint8List bytes, String mime) {
    if (!mime.startsWith('image/')) {
      return 'Selecciona un archivo de imagen (JPG o PNG).';
    }
    if (bytes.length > StorageConfig.maxFileBytes) {
      final mb = StorageConfig.maxFileBytes ~/ (1024 * 1024);
      return 'La imagen supera el limite de ${mb}MB.';
    }
    return null;
  }

  void _setLocalImage({
    required Uint8List bytes,
    required String mime,
  }) {
    emit(
      state.copyWith(
        processingImage: false,
        localImageBytes: bytes,
        localImageMime: mime,
        imageUrl: null,
        dirty: true,
        saveSuccess: false,
        resetError: true,
      ),
    );
  }

  Future<CropSelectionResult?> _cropImage(
    NavigatorState navigator,
    Uint8List bytes,
  ) {
    return navigator.push<CropSelectionResult>(
      MaterialPageRoute(
        builder: (_) => AvatarCropperPage(originalBytes: bytes),
      ),
    );
  }

  Future<UploadedFile> _uploadBytes({
    required Uint8List bytes,
    required String contentType,
    String baseName = 'product_media',
    String? publicIdHint,
  }) async {
    final folder = '${StorageConfig.folder}/catalog/products/$_resolvedStorageId';
    final fileName = ImageBytesHelper.buildFileName(
      uid: _resolvedStorageId,
      base: baseName,
      contentType: contentType,
    );
    try {
      return await _storage.uploadBytes(
        bytes: bytes,
        fileName: fileName,
        contentType: contentType,
        folder: folder,
        publicIdHint: publicIdHint,
      );
    } catch (e) {
      final fb = _fallbackStorage;
      if (fb != null) {
        return fb.uploadBytes(
          bytes: bytes,
          fileName: fileName,
          contentType: contentType,
          folder: folder,
          publicIdHint: publicIdHint,
        );
      }
      rethrow;
    }
  }

  String get _resolvedStorageId =>
      state.initialProduct?.id.isNotEmpty == true
          ? state.initialProduct!.id
          : _draftId;
}

 END FILE: modules/features/catalog/presentation/admin/blocs/product_form/product_form_cubit.dart 

 FILE: modules/features/catalog/presentation/admin/blocs/product_form/product_form_state.dart 
import 'dart:typed_data';

import '../../../../domain/entities/admin_product.dart';

class ProductFormState {
  final AdminProduct? initialProduct;
  final bool isEditing;
  final String? selectedCategoryId;
  final String name;
  final UnitType? unitType;
  final int? unitsPerPack;
  final double? basePrice;
  final bool isVisible;
  final List<String> variants;
  final String? description;
  final String? imageUrl;
  final Uint8List? localImageBytes;
  final String? localImageMime;
  final bool processingImage;
  final bool isSaving;
  final bool saveSuccess;
  final String? errorMessage;
  final bool dirty;

  const ProductFormState({
    this.initialProduct,
    this.isEditing = false,
    this.selectedCategoryId,
    this.name = '',
    this.unitType,
    this.unitsPerPack,
    this.basePrice,
    this.isVisible = true,
    this.variants = const [],
    this.description,
    this.imageUrl,
    this.localImageBytes,
    this.localImageMime,
    this.processingImage = false,
    this.isSaving = false,
    this.saveSuccess = false,
    this.errorMessage,
    this.dirty = false,
  });

  bool get isValid =>
      (selectedCategoryId ?? '').isNotEmpty &&
      name.trim().isNotEmpty &&
      unitType != null &&
      (basePrice ?? 0) > 0;

  ProductFormState copyWith({
    AdminProduct? initialProduct,
    bool? isEditing,
    String? selectedCategoryId,
    String? name,
    UnitType? unitType,
    int? unitsPerPack,
    double? basePrice,
    bool? isVisible,
    List<String>? variants,
    String? description,
    String? imageUrl,
    Uint8List? localImageBytes,
    String? localImageMime,
    bool? processingImage,
    bool? isSaving,
    bool? saveSuccess,
    String? errorMessage,
    bool? dirty,
    bool resetError = false,
    bool resetSuccess = false,
  }) {
    return ProductFormState(
      initialProduct: initialProduct ?? this.initialProduct,
      isEditing: isEditing ?? this.isEditing,
      selectedCategoryId: selectedCategoryId ?? this.selectedCategoryId,
      name: name ?? this.name,
      unitType: unitType ?? this.unitType,
      unitsPerPack: unitsPerPack ?? this.unitsPerPack,
      basePrice: basePrice ?? this.basePrice,
      isVisible: isVisible ?? this.isVisible,
      variants: variants ?? this.variants,
      description: description ?? this.description,
      imageUrl: imageUrl ?? this.imageUrl,
      localImageBytes: resetSuccess ? null : (localImageBytes ?? this.localImageBytes),
      localImageMime: resetSuccess ? null : (localImageMime ?? this.localImageMime),
      processingImage: processingImage ?? this.processingImage,
      isSaving: isSaving ?? this.isSaving,
      saveSuccess: resetSuccess ? false : (saveSuccess ?? this.saveSuccess),
      errorMessage: resetError ? null : (errorMessage ?? this.errorMessage),
      dirty: dirty ?? this.dirty,
    );
  }
}

 END FILE: modules/features/catalog/presentation/admin/blocs/product_form/product_form_state.dart 

Dentro de /products_list:

 FILE: modules/features/catalog/presentation/admin/blocs/products_list/products_list_cubit.dart 
import 'dart:async';

import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../domain/entities/admin_product.dart';
import '../../../../domain/usecases/browse/watch_all_products_usecase.dart';
import '../../../../domain/usecases/browse/watch_products_by_category_usecase.dart';
import 'products_list_state.dart';

class ProductsListCubit extends Cubit<ProductsListState> {
  final WatchAllProductsUseCase watchAllProducts;
  final WatchProductsByCategoryUseCase? watchProductsByCategory;

  StreamSubscription<List<AdminProduct>>? _subscription;

  ProductsListCubit({
    required this.watchAllProducts,
    this.watchProductsByCategory,
  }) : super(const ProductsListState());

  void start() => _subscribe(categoryId: state.categoryFilter);

  void setCategory(String? categoryId) => _subscribe(categoryId: categoryId);

  void retry() => _subscribe(categoryId: state.categoryFilter);

  void _subscribe({String? categoryId}) {
    _subscription?.cancel();
    emit(
      state.copyWith(
        status: ProductsListStatus.loading,
        categoryFilter: categoryId,
        resetError: true,
      ),
    );
    final stream = categoryId != null &&
            categoryId.isNotEmpty &&
            watchProductsByCategory != null
        ? watchProductsByCategory!(categoryId)
        : watchAllProducts();

    _subscription = stream.listen(
      (products) {
        emit(
          state.copyWith(
            status: ProductsListStatus.loaded,
            products: products,
            resetError: true,
          ),
        );
      },
      onError: (error) {
        emit(
          state.copyWith(
            status: ProductsListStatus.error,
            errorMessage: error.toString(),
          ),
        );
      },
    );
  }

  @override
  Future<void> close() {
    _subscription?.cancel();
    return super.close();
  }
}

 END FILE: modules/features/catalog/presentation/admin/blocs/products_list/products_list_cubit.dart 

 FILE: modules/features/catalog/presentation/admin/blocs/products_list/products_list_state.dart 
import '../../../../domain/entities/admin_product.dart';

enum ProductsListStatus { initial, loading, loaded, error }

class ProductsListState {
  final ProductsListStatus status;
  final List<AdminProduct> products;
  final String? errorMessage;
  final String? categoryFilter;

  const ProductsListState({
    this.status = ProductsListStatus.initial,
    this.products = const [],
    this.errorMessage,
    this.categoryFilter,
  });

  bool get isLoading => status == ProductsListStatus.loading;

  ProductsListState copyWith({
    ProductsListStatus? status,
    List<AdminProduct>? products,
    String? errorMessage,
    String? categoryFilter,
    bool resetError = false,
  }) {
    return ProductsListState(
      status: status ?? this.status,
      products: products ?? this.products,
      errorMessage: resetError ? null : (errorMessage ?? this.errorMessage),
      categoryFilter: categoryFilter ?? this.categoryFilter,
    );
  }
}

 END FILE: modules/features/catalog/presentation/admin/blocs/products_list/products_list_state.dart 

Dentro de /categories:

Dentro de /blocs:

 FILE: modules/features/catalog/presentation/admin/categories/blocs/category_form_cubit.dart 
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:http/http.dart' as http;

import '../../../../domain/entities/category.dart' as domain;
import '../../../../domain/usecases/create_category.dart';
import '../../../../domain/usecases/delete_category.dart';
import '../../../../domain/usecases/update_category.dart';
import '../../../../../../core/config/storage_config.dart';
import '../../../../../../core/config/storage_flags.dart';
import '../../../../../../core/entities/image_crop_data.dart';
import '../../../../../../core/services/media/i_image_source.dart';
import '../../../../../../core/services/media/image_picker_service.dart';
import '../../../../../../core/services/storage/cloudinary_storage_service.dart';
import '../../../../../../core/services/storage/firebase_storage_service.dart'
    as fbstore;
import '../../../../../../core/services/storage/i_file_storage_service.dart';
import '../../../../../../core/utils/data/image_bytes.dart';
import '../../../../../../core/widgets/media/avatar_cropper_page.dart';

class CategoryFormState {
  final String id;
  final String name;
  final String? imageUrl;
  final String? imageOriginalUrl;
  final String? imageOriginalId;
  final ImageCropData? cropData;
  final String labelColor;
  final bool visible;
  final String? description;
  final bool saving;
  final String? error;
  final Uint8List? localImageBytes;
  final String? localImageMime;
  final bool processingImage;
  final bool dirty;

  const CategoryFormState({
    this.id = '',
    this.name = '',
    this.imageUrl,
    this.imageOriginalUrl,
    this.imageOriginalId,
    this.cropData,
    this.labelColor = 'neutral',
    this.visible = true,
    this.description,
    this.saving = false,
    this.error,
    this.localImageBytes,
    this.localImageMime,
    this.processingImage = false,
    this.dirty = false,
  });

  bool get isEdit => id.isNotEmpty;
  bool get canSubmit => !saving && dirty && name.trim().isNotEmpty;

  CategoryFormState copyWith({
    String? id,
    String? name,
    String? imageUrl,
    String? imageOriginalUrl,
    String? imageOriginalId,
    ImageCropData? cropData,
    String? labelColor,
    bool? visible,
    String? description,
    bool? saving,
    String? error,
    Uint8List? localImageBytes,
    String? localImageMime,
    bool? processingImage,
    bool? dirty,
    bool resetImageUrl = false,
    bool resetLocalImage = false,
  }) {
    return CategoryFormState(
      id: id ?? this.id,
      name: name ?? this.name,
      imageUrl: resetImageUrl ? null : (imageUrl ?? this.imageUrl),
      imageOriginalUrl:
          resetImageUrl ? null : (imageOriginalUrl ?? this.imageOriginalUrl),
      imageOriginalId:
          resetImageUrl ? null : (imageOriginalId ?? this.imageOriginalId),
      cropData: cropData ?? this.cropData,
      labelColor: labelColor ?? this.labelColor,
      visible: visible ?? this.visible,
      description: description ?? this.description,
      saving: saving ?? this.saving,
      error: error,
      localImageBytes:
          resetLocalImage ? null : (localImageBytes ?? this.localImageBytes),
      localImageMime:
          resetLocalImage ? null : (localImageMime ?? this.localImageMime),
      processingImage: processingImage ?? this.processingImage,
      dirty: dirty ?? this.dirty,
    );
  }
}

class CategoryFormCubit extends Cubit<CategoryFormState> {
  final CreateCategory createCategory;
  final UpdateCategory updateCategory;
  final DeleteCategory deleteCategory;
  final IImagePickerService _imagePicker;
  final IFileStorageService _storage;
  final IFileStorageService? _fallbackStorage;
  final String _draftId;
  Uint8List? _pendingOriginalBytes;
  String? _pendingOriginalMime;

  CategoryFormCubit({
    required this.createCategory,
    required this.updateCategory,
    required this.deleteCategory,
    IImagePickerService? imagePicker,
    IFileStorageService? storage,
    IFileStorageService? fallbackStorage,
  }) : _imagePicker = imagePicker ?? ImagePickerService(),
       _storage = storage ?? CloudinaryStorageService(),
       _fallbackStorage =
           fallbackStorage ??
           (StorageFlags.enableFirebaseFallback
               ? fbstore.FirebaseStorageService()
               : null),
       _draftId = 'draft-${DateTime.now().millisecondsSinceEpoch}',
       super(const CategoryFormState());

  void load(domain.Category? category) {
    if (category == null) return;
    emit(
      CategoryFormState(
        id: category.id,
        name: category.name,
        imageUrl: category.imageUrl,
        imageOriginalUrl: category.imageOriginalUrl,
        imageOriginalId: category.imageOriginalId,
        cropData: category.cropData,
        labelColor: category.labelColor,
        visible: category.visible,
        description: category.description,
        dirty: false,
      ),
    );
  }

  void setName(String value) => emit(state.copyWith(name: value, dirty: true));
  void setDescription(String value) =>
      emit(state.copyWith(description: value, dirty: true));
  void setVisible(bool value) =>
      emit(state.copyWith(visible: value, dirty: true));

  void clearImage() {
    _pendingOriginalBytes = null;
    _pendingOriginalMime = null;
    emit(
      state.copyWith(
        resetImageUrl: true,
        resetLocalImage: true,
        imageOriginalUrl: null,
        imageOriginalId: null,
        cropData: null,
        dirty: true,
      ),
    );
  }

  Future<void> pickLogo(
    NavigatorState navigator,
    AppImageSource source,
  ) async {
    if (isClosed) return;
    try {
      final picked = await _imagePicker.pick(source);
      if (picked == null) return;
      final mime =
          picked.mimeType ??
          ImageBytesHelper.sniffContentType(
            picked.bytes,
            fallbackName: picked.fileName,
          ) ??
          'image/jpeg';
      final validation = _validateImage(picked.bytes, mime);
      if (validation != null) {
        emit(state.copyWith(error: validation));
        return;
      }
      emit(state.copyWith(processingImage: true, error: null));
      final result = await _cropImage(
        navigator,
        picked.bytes,
      );
      if (result == null) {
        emit(state.copyWith(processingImage: false));
        return;
      }
      _pendingOriginalBytes = picked.bytes;
      _pendingOriginalMime = mime;
      _setLocalImage(
        bytes: result.previewBytes,
        mime: 'image/jpeg',
        cropData: result.recipe,
      );
    } catch (e, st) {
      if (kDebugMode) debugPrint('pickLogo error: $e\n$st');
      emit(
        state.copyWith(
          processingImage: false,
          error: 'No se pudo abrir la camara o galeria. Intenta nuevamente.',
        ),
      );
    }
  }

  Future<void> importLogoFromUrl(
    NavigatorState navigator,
    String url,
  ) async {
    if (isClosed) return;
    final uriString = url.trim();
    if (uriString.isEmpty) return;
    Uri? uri;
    try {
      uri = Uri.parse(uriString);
    } catch (_) {
      emit(state.copyWith(error: 'URL invalida. Revisa el enlace.'));
      return;
    }
    emit(state.copyWith(processingImage: true, error: null));
    try {
      final resp = await http.get(uri);
      if (resp.statusCode < 200 || resp.statusCode >= 300) {
        throw Exception('No se pudo obtener la imagen (${resp.statusCode}).');
      }
      final bytes = resp.bodyBytes;
      final headerMime = resp.headers['content-type']?.split(';').first;
      final mime =
          headerMime ??
          ImageBytesHelper.sniffContentType(bytes, fallbackName: uri.path) ??
          'image/jpeg';
      final validation = _validateImage(bytes, mime);
      if (validation != null) {
        emit(state.copyWith(processingImage: false, error: validation));
        return;
      }
      final result = await _cropImage(navigator, bytes);
      if (result == null) {
        emit(state.copyWith(processingImage: false));
        return;
      }
      _pendingOriginalBytes = bytes;
      _pendingOriginalMime = mime;
      _setLocalImage(
        bytes: result.previewBytes,
        mime: 'image/jpeg',
        cropData: result.recipe,
      );
    } catch (e, st) {
      if (kDebugMode) debugPrint('importLogoFromUrl error: $e\n$st');
      emit(
        state.copyWith(
          processingImage: false,
          error: 'No se pudo descargar la imagen. $e',
        ),
      );
    }
  }

  Future<void> save() async {
    if (isClosed) return;
    if (state.name.trim().isEmpty) {
      emit(state.copyWith(error: 'El nombre es requerido'));
      return;
    }

    emit(state.copyWith(saving: true, error: null));

    UploadedFile? uploadedOriginal;
    final hasOriginalBytes =
        _pendingOriginalBytes != null && _pendingOriginalBytes!.isNotEmpty;
    try {
      if (hasOriginalBytes) {
        uploadedOriginal = await _uploadBytes(
          bytes: _pendingOriginalBytes!,
          contentType: _pendingOriginalMime ?? 'image/jpeg',
          baseName: 'category_original',
          publicIdHint: 'original_$_resolvedStorageId',
        );
      }
    } catch (e, st) {
      if (kDebugMode) debugPrint('save upload error: $e\n$st');
      emit(
        state.copyWith(
          saving: false,
          error: 'No se pudo subir la imagen. Intenta nuevamente.',
        ),
      );
      return;
    }

    final category = domain.Category(
      id: state.id,
      name: state.name.trim(),
      imageUrl: uploadedOriginal?.url ?? state.imageUrl,
      imageOriginalUrl: uploadedOriginal?.url ?? state.imageOriginalUrl,
      imageOriginalId: uploadedOriginal?.publicId ?? state.imageOriginalId,
      cropData: state.cropData,
      labelColor: state.labelColor,
      visible: state.visible,
      description: state.description?.trim(),
    );

    try {
      if (state.isEdit) {
        await updateCategory(category);
      } else {
        await createCategory(category);
      }
      emit(
        state.copyWith(
          saving: false,
          dirty: false,
          imageUrl: uploadedOriginal?.url ?? state.imageUrl,
          imageOriginalUrl: uploadedOriginal?.url ?? state.imageOriginalUrl,
          imageOriginalId: uploadedOriginal?.publicId ?? state.imageOriginalId,
          resetLocalImage: true,
        ),
      );
      _pendingOriginalBytes = null;
      _pendingOriginalMime = null;
    } catch (e) {
      emit(state.copyWith(saving: false, error: e.toString()));
    }
  }

  Future<void> delete() async {
    if (!state.isEdit) return;
    emit(state.copyWith(saving: true, error: null));
    try {
      await deleteCategory(state.id);
      emit(state.copyWith(saving: false));
    } catch (e) {
      emit(state.copyWith(saving: false, error: e.toString()));
    }
  }

  String? _validateImage(Uint8List bytes, String mime) {
    if (!mime.startsWith('image/')) {
      return 'Selecciona un archivo de imagen (JPG o PNG).';
    }
    if (bytes.length > StorageConfig.maxFileBytes) {
      final mb = StorageConfig.maxFileBytes ~/ (1024 * 1024);
      return 'La imagen supera el limite de ${mb}MB.';
    }
    return null;
  }

  void _setLocalImage({
    required Uint8List bytes,
    required String mime,
    ImageCropData? cropData,
  }) {
    emit(
      state.copyWith(
        processingImage: false,
        localImageBytes: bytes,
        localImageMime: mime,
        resetImageUrl: true,
        cropData: cropData ?? state.cropData,
        dirty: true,
      ),
    );
  }

  Future<CropSelectionResult?> _cropImage(
    NavigatorState navigator,
    Uint8List bytes,
  ) {
    return navigator.push<CropSelectionResult>(
      MaterialPageRoute(
        builder: (_) => AvatarCropperPage(originalBytes: bytes),
      ),
    );
  }

  Future<UploadedFile> _uploadBytes({
    required Uint8List bytes,
    required String contentType,
    String baseName = 'category_media',
    String? publicIdHint,
  }) async {
    final storageId = _resolvedStorageId;
    final folder = '${StorageConfig.folder}/catalog/categories/$storageId';
    final fileName = ImageBytesHelper.buildFileName(
      uid: storageId,
      base: baseName,
      contentType: contentType,
    );
    return _uploadWithFallback(
      bytes: bytes,
      fileName: fileName,
      contentType: contentType,
      folder: folder,
      publicIdHint: publicIdHint,
    );
  }

  Future<UploadedFile> _uploadWithFallback({
    required Uint8List bytes,
    required String fileName,
    required String contentType,
    required String folder,
    String? publicIdHint,
  }) async {
    try {
      return await _storage.uploadBytes(
        bytes: bytes,
        fileName: fileName,
        contentType: contentType,
        folder: folder,
        publicIdHint: publicIdHint,
      );
    } catch (e, st) {
      if (kDebugMode) {
        debugPrint(
          'Cloudinary upload failed for $fileName '
          '-> folder=$folder, ct=$contentType, reason=$e\n$st',
        );
      }
      final fb = _fallbackStorage;
      if (fb != null) {
        try {
          if (kDebugMode) {
            debugPrint('Trying Firebase Storage fallback for $fileName');
          }
          return await fb.uploadBytes(
            bytes: bytes,
            fileName: fileName,
            contentType: contentType,
            folder: folder,
            publicIdHint: publicIdHint,
          );
        } catch (fbErr, fbSt) {
          if (kDebugMode) {
            debugPrint(
              'Firebase Storage fallback failed for $fileName: '
              '$fbErr\n$fbSt',
            );
          }
          throw Exception(
            'Cloudinary y Firebase fallaron al subir la imagen. '
            'Detalles: $e | $fbErr',
          );
        }
      }
      rethrow;
    }
  }

  String get _resolvedStorageId => state.id.isNotEmpty ? state.id : _draftId;
}



 END FILE: modules/features/catalog/presentation/admin/categories/blocs/category_form_cubit.dart 

 FILE: modules/features/catalog/presentation/admin/categories/blocs/category_list_cubit.dart 
import 'dart:async';

import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../domain/entities/category.dart';
import '../../../../domain/usecases/get_primary_categories_limit.dart';
import '../../../../domain/usecases/reorder_categories.dart';
import '../../../../domain/usecases/set_primary_categories_limit.dart';
import '../../../../domain/usecases/update_category.dart';
import '../../../../domain/usecases/watch_categories_stream.dart';

class CategoryListState {
  final List<Category> items;
  final bool loading;
  final String search;
  final bool reordering;
  final bool hasUnsavedChanges;
  final bool saving;
  final int primaryLimit;
  final String? error;

  const CategoryListState({
    this.items = const [],
    this.loading = false,
    this.search = '',
    this.reordering = false,
    this.hasUnsavedChanges = false,
    this.saving = false,
    this.primaryLimit = 6,
    this.error,
  });

  List<Category> get filtered {
    if (search.isEmpty) return items;
    final query = search.toLowerCase();
    return items
        .where((c) => c.name.toLowerCase().contains(query))
        .toList(growable: false);
  }

  CategoryListState copyWith({
    List<Category>? items,
    bool? loading,
    String? search,
    bool? reordering,
    bool? hasUnsavedChanges,
    bool? saving,
    int? primaryLimit,
    String? error,
  }) {
    return CategoryListState(
      items: items ?? this.items,
      loading: loading ?? this.loading,
      search: search ?? this.search,
      reordering: reordering ?? this.reordering,
      hasUnsavedChanges: hasUnsavedChanges ?? this.hasUnsavedChanges,
      saving: saving ?? this.saving,
      primaryLimit: primaryLimit ?? this.primaryLimit,
      error: error,
    );
  }
}

class CategoryListCubit extends Cubit<CategoryListState> {
  final WatchCategoriesStream watchCategories;
  final UpdateCategory updateCategory;
  final ReorderCategories reorderCategories;
  final GetPrimaryCategoriesLimit getPrimaryCategoriesLimit;
  final SetPrimaryCategoriesLimit setPrimaryCategoriesLimit;

  StreamSubscription<List<Category>>? _subscription;

  CategoryListCubit({
    required this.watchCategories,
    required this.updateCategory,
    required this.reorderCategories,
    required this.getPrimaryCategoriesLimit,
    required this.setPrimaryCategoriesLimit,
  }) : super(const CategoryListState());

  Future<void> init() async {
    emit(
      state.copyWith(
        loading: true,
        error: null,
        hasUnsavedChanges: false,
      ),
    );
    _subscription?.cancel();
    final limit = await _loadPrimaryLimit();
    emit(state.copyWith(primaryLimit: limit));
    _subscription = watchCategories().listen(
      (items) {
        final normalized = _normalize(items);
        final maxAllowed =
            normalized.isNotEmpty ? normalized.length : state.primaryLimit;
        final upperBound = maxAllowed < 1 ? 1 : maxAllowed;
        final sanitizedLimit = state.primaryLimit.clamp(1, upperBound).toInt();
        emit(
          state.copyWith(
            items: normalized,
            loading: false,
            error: null,
            hasUnsavedChanges: state.hasUnsavedChanges,
            primaryLimit: sanitizedLimit,
          ),
        );
      },
      onError: (e) => emit(state.copyWith(loading: false, error: e.toString())),
    );
  }

  void setSearch(String value) =>
      emit(state.copyWith(search: value, error: state.error));

  void toggleReorder() => emit(state.copyWith(reordering: !state.reordering));

  Future<void> toggleVisible(Category category) async {
    final updated = category.copyWith(visible: !category.visible);
    await updateCategory(updated);
  }

  void updatePrimaryLimitLocal(int newLimit) {
    final maxAllowed =
        state.items.isNotEmpty ? state.items.length : newLimit;
    final upperBound = maxAllowed < 1 ? 1 : maxAllowed;
    final sanitized = newLimit.clamp(1, upperBound).toInt();
    final normalized = _normalize(state.items);
    final hasChanges = sanitized != state.primaryLimit;
    emit(
      state.copyWith(
        primaryLimit: sanitized,
        items: normalized,
        hasUnsavedChanges: hasChanges || state.hasUnsavedChanges,
      ),
    );
  }

  Future<void> saveCustomization({
    required List<Category> orderedItems,
    required int primaryLimit,
  }) async {
    emit(state.copyWith(saving: true, error: null));
    try {
      final normalized = _normalize(orderedItems);
      final upperBound = normalized.isNotEmpty ? normalized.length : 1;
      final sanitizedLimit = primaryLimit.clamp(1, upperBound).toInt();
      await setPrimaryCategoriesLimit(sanitizedLimit);
      await reorderCategories(normalized);
      emit(
        state.copyWith(
          items: _normalize(normalized),
          primaryLimit: sanitizedLimit,
          saving: false,
          hasUnsavedChanges: false,
        ),
      );
    } catch (e) {
      emit(
        state.copyWith(
          saving: false,
          error: e.toString(),
          hasUnsavedChanges: true,
        ),
      );
    }
  }

  Future<void> resetToSavedState() async {
    await init();
  }

  @override
  Future<void> close() {
    _subscription?.cancel();
    return super.close();
  }

  Future<int> _loadPrimaryLimit() async {
    try {
      return await getPrimaryCategoriesLimit();
    } catch (_) {
      return 6;
    }
  }

  List<Category> _normalize(List<Category> items) {
    final withPos = items
        .where((c) => (c.position) > 0)
        .toList(growable: true)
      ..sort((a, b) => a.position.compareTo(b.position));
    final withoutPos =
        items.where((c) => (c.position) <= 0).toList(growable: true);
    final result = <Category>[];
    result.addAll(withPos);
    result.addAll(withoutPos);

    return List<Category>.generate(result.length, (i) {
      final base = result[i];
      final pos = i + 1;
      return base.copyWith(position: pos);
    });
  }
}

 END FILE: modules/features/catalog/presentation/admin/categories/blocs/category_list_cubit.dart 

Dentro de /pages:

 FILE: modules/features/catalog/presentation/admin/categories/pages/categories_customize_page.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../domain/entities/category.dart';
import '../../../../domain/repositories/categories_repository.dart';
import '../../../../domain/usecases/create_category.dart';
import '../../../../domain/usecases/delete_category.dart';
import '../../../../domain/usecases/update_category.dart';
import '../blocs/category_form_cubit.dart';
import '../blocs/category_list_cubit.dart';
import '../widgets/category_chip.dart';
import '../widgets/reorderable_category_list.dart';
import 'category_form_page.dart';

class CategoriesCustomizePage extends StatefulWidget {
  const CategoriesCustomizePage({super.key});

  @override
  State<CategoriesCustomizePage> createState() =>
      _CategoriesCustomizePageState();
}

class _CategoriesCustomizePageState extends State<CategoriesCustomizePage> {
  static const int _minPrimaryLimit = 3;
  static const int _maxPrimaryLimit = 8;

  int _primaryLimit = 6;
  int _baselinePrimaryLimit = 6;
  List<Category> _workingItems = const [];
  List<Category> _baselineItems = const [];
  bool _hasLocalChanges = false;
  final ScrollController _scrollController = ScrollController();

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CategoryListCubit, CategoryListState>(
      builder: (context, state) {
        _syncFromState(state);

        final filtered = _filterItems(_workingItems, state.search);
        final primaryUsedCount = _workingItems.take(_primaryLimit).length;
        final primaryCategories = filtered
            .take(_primaryLimit)
            .toList(growable: false);
        final hasRest = filtered.length > _primaryLimit;
        final hasEmptySlots =
            state.search.isEmpty && _workingItems.length < _primaryLimit;
        final missingSlots =
            hasEmptySlots ? (_primaryLimit - _workingItems.length) : 0;
        final hasChanges =
            state.hasUnsavedChanges || _hasLocalChanges || !_isSameAsBaseline();
        final isSaving = state.saving;
        const fabBottomPadding = 20.0;

        final header = _buildHeader(
          context: context,
          primaryCategories: primaryCategories,
          primaryUsedCount: primaryUsedCount,
          onAddCategory: () => _openForm(context, null),
          onPrimaryLimitChanged: (value) {
            setState(() {
              _primaryLimit = value;
              _workingItems = _normalizeForDisplay(_workingItems);
              _markDirty();
            });
            context.read<CategoryListCubit>().updatePrimaryLimitLocal(value);
          },
          onSearch: context.read<CategoryListCubit>().setSearch,
          searchValue: state.search,
        );

        final primaryPlaceholders =
            missingSlots > 0
                ? _buildEmptySlotsFooter(
                    context: context,
                    slots: missingSlots,
                    onAddCategory: () => _openForm(context, null),
                  )
                : const <Widget>[];

        Widget content;
        if (state.loading) {
          content = const Center(child: CircularProgressIndicator());
        } else if (filtered.isEmpty) {
          content = ListView(
            controller: _scrollController,
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 200),
            children: [
              ...header,
              const SizedBox(height: 12),
              Text(
                'Sin categorias con este filtro',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).hintColor,
                ),
              ),
            ],
          );
        } else {
          content = ReorderableCategoryList(
            scrollController: _scrollController,
            items: filtered,
            primaryLimit: _primaryLimit,
            showDragHandle: true,
            header: header,
            restHeader:
                hasRest
                    ? Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 16),
                        Text(
                          'Resto de categorias',
                          style: Theme.of(context).textTheme.titleMedium,
                        ),
                        const SizedBox(height: 4),
                        Text(
                          'A partir de la posicion ${_primaryLimit + 1}, las categorias apareceran al ver el catalogo completo.',
                          style:
                              Theme.of(context).textTheme.bodySmall?.copyWith(
                                color: Theme.of(context)
                                    .colorScheme
                                    .onSurfaceVariant,
                              ),
                        ),
                        const SizedBox(height: 8),
                      ],
                    )
                    : null,
            footer: primaryPlaceholders,
            padding: EdgeInsets.only(bottom: hasChanges ? 40 : 96),
            onReorderCommitted: (ordered) {
              setState(() {
                _workingItems = _normalizeForDisplay(ordered);
                _markDirty();
              });
            },
            onEdit: (category) async {
              final cubit = context.read<CategoryListCubit>();
              await _openForm(context, category);
              if (!mounted) return;
              _syncFromState(cubit.state);
              setState(_markDirty);
            },
            onToggleVisible: (category) {
              setState(() {
                _workingItems =
                    _workingItems
                        .map(
                          (c) =>
                              c.id == category.id
                                  ? c.copyWith(visible: !c.visible)
                                  : c,
                        )
                        .toList();
                _markDirty();
              });
              context.read<CategoryListCubit>().toggleVisible(category);
            },
          );
        }

        return Scaffold(
          appBar: AppBar(
            title: const Text('Personalizar categorias'),
          ),
          body: Stack(
            children: [
              RefreshIndicator(
                onRefresh: () async {
                  await context.read<CategoryListCubit>().init();
                },
                child: content,
              ),
              if (hasChanges) const _BottomFadeOverlay(),
            ],
          ),
          floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
          floatingActionButton: hasChanges
              ? null
              : SafeArea(
                  minimum:
                      const EdgeInsets.only(bottom: fabBottomPadding, right: 12),
                  child: FloatingActionButton.small(
                    onPressed: () => _openForm(context, null),
                    tooltip: 'Nueva categoria',
                    child: const Icon(Icons.add),
                  ),
                ),
          bottomNavigationBar:
              hasChanges
                  ? SafeArea(
                    minimum: const EdgeInsets.fromLTRB(16, 8, 16, 16),
                    child: Row(
                      children: [
                        Expanded(
                          child: TextButton(
                            onPressed: () async {
                              final cubit = context.read<CategoryListCubit>();
                              await cubit.resetToSavedState();
                              if (!mounted) return;
                              final current = cubit.state;
                              setState(() {
                                _primaryLimit = current.primaryLimit;
                                _baselinePrimaryLimit = current.primaryLimit;
                                _workingItems = _normalizeForDisplay(
                                  current.items,
                                );
                                _baselineItems = List.of(_workingItems);
                                _hasLocalChanges = false;
                              });
                            },
                            child: const Text('Cancelar'),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: FilledButton.icon(
                            onPressed:
                                _workingItems.isEmpty || isSaving
                                    ? null
                                    : () async {
                                      final normalized = _normalizeForDisplay(
                                        _workingItems,
                                      );
                                      final cubit =
                                          context.read<CategoryListCubit>();
                                      await cubit.saveCustomization(
                                        orderedItems: normalized,
                                        primaryLimit: _primaryLimit,
                                      );
                                      if (!mounted) return;
                                      final savedState = cubit.state;
                                      setState(() {
                                        _primaryLimit = savedState.primaryLimit;
                                        _baselinePrimaryLimit =
                                            savedState.primaryLimit;
                                        _workingItems = _normalizeForDisplay(
                                          savedState.items,
                                        );
                                        _baselineItems = List.of(_workingItems);
                                        _hasLocalChanges = false;
                                      });
                                    },
                            icon: const Icon(Icons.check),
                            label: const Text('Guardar cambios'),
                          ),
                        ),
                      ],
                    ),
                  )
                  : null,
        );
      },
    );
  }

  void _syncFromState(CategoryListState state) {
    if (_hasLocalChanges && !_isSameAsBaseline()) return;
    _primaryLimit = state.primaryLimit;
    _baselinePrimaryLimit = state.primaryLimit;
    _workingItems = _normalizeForDisplay(state.items);
    _baselineItems = List.of(_workingItems);
    _hasLocalChanges = false;
  }

  void _markDirty() {
    _hasLocalChanges = !_isSameAsBaseline();
  }

  List<Category> _filterItems(List<Category> items, String query) {
    if (query.isEmpty) return items;
    final q = query.toLowerCase().trim();
    return items
        .where((c) => c.name.toLowerCase().contains(q))
        .toList(growable: false);
  }

  List<Category> _normalizeForDisplay(List<Category> items) {
    final withPos = items.where((c) => (c.position) > 0).toList(growable: true)
      ..sort((a, b) => a.position.compareTo(b.position));
    final withoutPos = items
        .where((c) => (c.position) <= 0)
        .toList(growable: true);
    final merged = <Category>[];
    merged.addAll(withPos);
    merged.addAll(withoutPos);
    return List<Category>.generate(merged.length, (i) {
      final base = merged[i];
      final pos = i + 1;
      return base.copyWith(position: pos);
    });
  }

  bool _isSameAsBaseline() {
    if (_baselineItems.length != _workingItems.length) return false;
    for (var i = 0; i < _baselineItems.length; i++) {
      final a = _baselineItems[i];
      final b = _workingItems[i];
      if (a.id != b.id || a.position != b.position || a.visible != b.visible) {
        return false;
      }
    }
    return _primaryLimit == _baselinePrimaryLimit;
  }

  Future<void> _openForm(BuildContext context, Category? category) async {
    final repo = RepositoryProvider.of<CategoriesRepository>(context);
    final cubit = context.read<CategoryListCubit>();
    await Navigator.of(context, rootNavigator: true).push(
      MaterialPageRoute(
        fullscreenDialog: true,
        builder:
            (_) => RepositoryProvider.value(
              value: repo,
              child: BlocProvider(
                create:
                    (_) => CategoryFormCubit(
                      createCategory: CreateCategory(repo),
                      updateCategory: UpdateCategory(repo),
                      deleteCategory: DeleteCategory(repo),
                    )..load(category),
                child: const CategoryFormPage(),
              ),
            ),
      ),
    );
    if (!mounted) return;
    cubit.init();
  }

  List<Widget> _buildHeader({
    required BuildContext context,
    required List<Category> primaryCategories,
    required int primaryUsedCount,
    required VoidCallback onAddCategory,
    required ValueChanged<int> onPrimaryLimitChanged,
    required ValueChanged<String> onSearch,
    required String searchValue,
  }) {
    return [
      Text(
        'Arrastra para reordenar. Las posiciones 1-$_primaryLimit se muestran en la barra de categorias del catalogo.',
        style: Theme.of(context).textTheme.bodySmall,
      ),
      const SizedBox(height: 12),
      _SearchBar(initialValue: searchValue, onChanged: onSearch),
      const SizedBox(height: 16),
      _PrimarySummary(
        categories: primaryCategories,
        usedCount: primaryUsedCount,
        primaryLimit: _primaryLimit,
        minLimit: _minPrimaryLimit,
        maxLimit: _maxPrimaryLimit,
        onPrimaryLimitChanged: onPrimaryLimitChanged,
        onAddCategory: onAddCategory,
      ),
      const SizedBox(height: 12),
    ];
  }
}

List<Widget> _buildEmptySlotsFooter({
  required BuildContext context,
  required int slots,
  required VoidCallback onAddCategory,
}) {
  if (slots <= 0) return const [];
  return List<Widget>.generate(
    slots,
    (_) => _EmptyCategorySlotCard(onTap: onAddCategory),
  );
}

class _EmptyCategorySlotCard extends StatelessWidget {
  final VoidCallback onTap;
  const _EmptyCategorySlotCard({required this.onTap});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Material(
      color: colorScheme.surface,
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
        side: BorderSide(
          color: colorScheme.outlineVariant.withValues(alpha: 0.7),
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(10),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Container(
                width: 44,
                height: 44,
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(10),
                  border: Border.all(
                    color: colorScheme.outlineVariant.withValues(alpha: 0.7),
                  ),
                ),
                child: Icon(
                  Icons.add,
                  color: colorScheme.primary,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      'Agregar categoria',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      'Crea una nueva categoria para tu catalogo.',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Opacity(
                    opacity: 0,
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          'Visible',
                          style: theme.textTheme.bodySmall?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(width: 10),
                        Switch.adaptive(
                          value: true,
                          onChanged: (_) {},
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 6),
                  FilledButton.tonal(
                    onPressed: onTap,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 14,
                        vertical: 8,
                      ),
                      visualDensity: VisualDensity.compact,
                    ),
                    child: const Text('Nueva'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SearchBar extends StatefulWidget {
  final String initialValue;
  final ValueChanged<String> onChanged;
  const _SearchBar({required this.initialValue, required this.onChanged});

  @override
  State<_SearchBar> createState() => _SearchBarState();
}

class _SearchBarState extends State<_SearchBar> {
  late final TextEditingController controller = TextEditingController(
    text: widget.initialValue,
  );

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: controller,
      decoration: const InputDecoration(
        prefixIcon: Icon(Icons.search),
        hintText: 'Buscar categorias...',
        border: OutlineInputBorder(),
      ),
      onChanged: widget.onChanged,
    );
  }
}

class _PrimarySummary extends StatelessWidget {
  final List<Category> categories;
  final int usedCount;
  final int primaryLimit;
  final int minLimit;
  final int maxLimit;
  final ValueChanged<int> onPrimaryLimitChanged;
  final VoidCallback onAddCategory;
  const _PrimarySummary({
    required this.categories,
    required this.usedCount,
    required this.primaryLimit,
    required this.minLimit,
    required this.maxLimit,
    required this.onPrimaryLimitChanged,
    required this.onAddCategory,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final usedLabel =
        '$usedCount de $primaryLimit visibles en la barra del catalogo';
    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: theme.colorScheme.outlineVariant.withValues(alpha: 0.6),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Categorias principales',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      usedLabel,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              _PrimaryLimitStepper(
                value: primaryLimit,
                min: minLimit,
                max: maxLimit,
                onChanged: onPrimaryLimitChanged,
              ),
            ],
          ),
          const SizedBox(height: 8),
          _PrimaryChipsScroller(
            categories: categories,
            canAddMore: usedCount < primaryLimit,
            onAddCategory: onAddCategory,
          ),
        ],
      ),
    );
  }
}

class _PrimaryLimitStepper extends StatelessWidget {
  final int value;
  final int min;
  final int max;
  final ValueChanged<int> onChanged;
  const _PrimaryLimitStepper({
    required this.value,
    required this.min,
    required this.max,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final canDecrement = value > min;
    final canIncrement = value < max;
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.end,
      children: [
        Text(
          'Maximo en la barra',
          style: theme.textTheme.labelSmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 6),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            _StepperButton(
              icon: Icons.remove,
              enabled: canDecrement,
              onPressed: () => onChanged(value - 1),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 6),
              child: Text(
                '$value',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
            _StepperButton(
              icon: Icons.add,
              enabled: canIncrement,
              onPressed: () => onChanged(value + 1),
            ),
          ],
        ),
      ],
    );
  }
}

class _PrimaryChipsScroller extends StatelessWidget {
  final List<Category> categories;
  final bool canAddMore;
  final VoidCallback onAddCategory;
  const _PrimaryChipsScroller({
    required this.categories,
    required this.canAddMore,
    required this.onAddCategory,
  });

  @override
  Widget build(BuildContext context) {
    final chips = <Widget>[
      const CategoryChipBadge(label: 'Todos', highlighted: true),
      ...categories.map((c) => CategoryChipBadge(label: c.name)),
      if (canAddMore) _AddCategoryChip(onPressed: onAddCategory),
    ];

    return SizedBox(
      height: 38,
      child: ListView.separated(
        scrollDirection: Axis.horizontal,
        itemBuilder: (_, index) => chips[index],
        separatorBuilder: (_, _) => const SizedBox(width: 8),
        itemCount: chips.length,
      ),
    );
  }
}

class _AddCategoryChip extends StatelessWidget {
  final VoidCallback onPressed;
  const _AddCategoryChip({required this.onPressed});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return OutlinedButton.icon(
      onPressed: onPressed,
      style: OutlinedButton.styleFrom(
        shape: const StadiumBorder(),
        visualDensity: VisualDensity.compact,
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      ),
      icon: Icon(Icons.add, size: 18, color: theme.colorScheme.primary),
      label: Text(
        'Agregar',
        style: theme.textTheme.labelLarge?.copyWith(
          color: theme.colorScheme.primary,
        ),
      ),
    );
  }
}

class _StepperButton extends StatelessWidget {
  final IconData icon;
  final bool enabled;
  final VoidCallback onPressed;
  const _StepperButton({
    required this.icon,
    required this.enabled,
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return IconButton.filledTonal(
      onPressed: enabled ? onPressed : null,
      icon: Icon(icon),
      style: IconButton.styleFrom(
        minimumSize: const Size(34, 34),
        padding: EdgeInsets.zero,
      ),
    );
  }
}

class _BottomFadeOverlay extends StatelessWidget {
  const _BottomFadeOverlay();

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).colorScheme.surface;
    return Positioned(
      left: 0,
      right: 0,
      bottom: 0,
      height: 30,
      child: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
              colors: [
                color.withValues(alpha: 0.0),
                color.withValues(alpha: 0.9),
              ],
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/admin/categories/pages/categories_customize_page.dart 

 FILE: modules/features/catalog/presentation/admin/categories/pages/category_form_page.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/forms/admin_form_section.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/forms/admin_media_picker_field.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/shared/admin_form_field.dart';
import 'package:flutter_application_emprendedoras/modules/core/utils/input/keyboard.dart';
import 'package:flutter_application_emprendedoras/modules/core/widgets/dialogs/success_countdown_dialog.dart';

import '../blocs/category_form_cubit.dart';

class CategoryFormPage extends StatefulWidget {
  const CategoryFormPage({super.key});

  @override
  State<CategoryFormPage> createState() => _CategoryFormPageState();
}

class _CategoryFormPageState extends State<CategoryFormPage> {
  final _nameCtrl = TextEditingController();
  final _descCtrl = TextEditingController();
  bool _wasSaving = false;
  _FormAction? _lastAction;
  bool _savingWasEdit = false;

  @override
  void dispose() {
    _nameCtrl.dispose();
    _descCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<CategoryFormCubit, CategoryFormState>(
      listenWhen: (previous, current) =>
          previous.name != current.name ||
          previous.description != current.description ||
          previous.error != current.error ||
          previous.saving != current.saving ||
          previous.dirty != current.dirty,
      listener: (context, state) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (!mounted) return;
          _syncControllers(state);
        });
        if (state.error != null && state.error!.isNotEmpty) {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text(state.error!)));
        }
        if (_wasSaving && !state.saving && state.error == null) {
          if (mounted && _lastAction != null) {
            final title = switch (_lastAction!) {
              _FormAction.save =>
                _savingWasEdit ? 'CategorÃ­a actualizada' : 'CategorÃ­a creada',
              _FormAction.delete => 'CategorÃ­a eliminada',
            };
            final msg = switch (_lastAction!) {
              _FormAction.save =>
                _savingWasEdit ? 'Se actualizaron los datos.' : 'Se creÃ³ la categorÃ­a.',
              _FormAction.delete => 'Se eliminÃ³ la categorÃ­a.',
            };
            showSuccessCountdownDialog(
              context,
              title: title,
              message: msg,
              buttonText: 'Volver',
              onFinished: () {
                if (mounted) Navigator.of(context).maybePop(true);
              },
            );
          }
          _lastAction = null;
        }
        _wasSaving = state.saving;
      },
      builder: (context, state) {
        final cubit = context.read<CategoryFormCubit>();
        final title = state.isEdit ? 'Editar categorÃ­a' : 'Nueva categorÃ­a';
        return PopScope(
          canPop: !state.saving,
          child: Scaffold(
            appBar: AppBar(
              leading: state.saving ? const SizedBox.shrink() : null,
              titleSpacing: 0,
              title: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title),
                  const SizedBox(height: 2),
                  Text(
                    'Crea y personaliza categorÃ­as del catÃ¡logo',
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
              actions: [
                if (state.isEdit)
                  IconButton(
                    tooltip: 'Eliminar',
                    icon: const Icon(Icons.delete_outline),
                    onPressed: state.saving
                        ? null
                        : () async {
                            _lastAction = _FormAction.delete;
                            _savingWasEdit = state.isEdit;
                            await cubit.delete();
                          },
                  ),
              ],
            ),
            body: ListView(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 40),
              children: [
                AdminFormSection(
                  title: 'Nombre',
                  subtitle: 'Escribe un nombre (ej. Comidas).',
                  leading: _SectionIcon(
                    icon: Icons.folder_outlined,
                    color: Theme.of(context).colorScheme.primary,
                  ),
                  children: [
                    AdminFormField(
                      label: 'Nombre de la categorÃ­a',
                      controller: _nameCtrl,
                      hintText: 'Escribe un nombre (ej. Comidas)',
                      prefixIcon: const Icon(Icons.drive_file_rename_outline),
                      textInputAction: TextInputAction.next,
                      onChanged: cubit.setName,
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                AdminFormSection(
                  title: 'Logo / Imagen',
                  subtitle:
                      'Sube una imagen, ajustala y previsualÃ­zala antes de publicar.',
                  leading: _SectionIcon(
                    icon: Icons.image_outlined,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
                  children: [
                    AdminMediaPickerField(
                      title: 'AÃ±adir logo',
                      subtitle:
                          'Puedes recortar y reemplazar la imagen en cualquier momento.',
                      imageUrl: state.imageUrl,
                      imageBytes: state.localImageBytes,
                      processing: state.processingImage,
                      onPickImage: (navigator, source) =>
                          cubit.pickLogo(navigator, source),
                      onPasteUrl: () => _promptPasteUrl(context, cubit),
                      onRemove: cubit.clearImage,
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                AdminFormSection(
                  title: 'Visibilidad',
                  subtitle:
                      'Decide si esta categorÃ­a se muestra en tu catÃ¡logo.',
                  leading: _SectionIcon(
                    icon: Icons.visibility_outlined,
                    color: Theme.of(context).colorScheme.primary,
                  ),
                  children: [
                    AdminSwitchTile(
                      title: 'Publicado',
                      subtitle: 'Visible en el catÃ¡logo',
                      value: state.visible,
                      onChanged: cubit.setVisible,
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                AdminFormSection(
                  title: 'DescripciÃ³n',
                  subtitle:
                      'Comparte detalles opcionales sobre esta categorÃ­a.',
                  leading: _SectionIcon(
                    icon: Icons.menu_book_outlined,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
                  children: [
                    AdminFormField(
                      label: 'DescripciÃ³n',
                      controller: _descCtrl,
                      hintText: 'Describe esta categorÃ­a (opcional)',
                      maxLines: 4,
                      minLines: 3,
                      textCapitalization: TextCapitalization.sentences,
                      onChanged: cubit.setDescription,
                    ),
                  ],
                ),
              ],
            ),
            bottomNavigationBar: SafeArea(
              child: AnimatedPadding(
                duration: const Duration(milliseconds: 220),
                curve: Curves.easeOut,
                padding: EdgeInsets.only(
                  bottom: MediaQuery.of(context).viewInsets.bottom,
                ),
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
                  child: !state.dirty
                      ? const SizedBox.shrink()
                      : AdminFormButtonBar(
                          buttons: [
                            OutlinedButton.icon(
                              onPressed: state.saving
                                  ? null
                                  : () => Navigator.of(context).maybePop(),
                              icon: const Icon(Icons.close),
                              label: const Text('Descartar'),
                            ),
                            FilledButton.icon(
                            onPressed: state.canSubmit
                                ? () async {
                                    _lastAction = _FormAction.save;
                                    _savingWasEdit = state.isEdit;
                                    await hideKeyboard(context);
                                    await cubit.save();
                                  }
                                : null,
                              icon: state.saving
                                  ? const SizedBox(
                                      width: 16,
                                      height: 16,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                      ),
                                    )
                                  : const Icon(Icons.check),
                              label: Text(
                                state.isEdit
                                    ? 'Guardar cambios'
                                    : 'Guardar categorÃ­a',
                              ),
                            ),
                          ],
                        ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  void _syncControllers(CategoryFormState state) {
    if (_nameCtrl.text != state.name) {
      _nameCtrl.value = TextEditingValue(
        text: state.name,
        selection: TextSelection.collapsed(offset: state.name.length),
      );
    }
    final description = state.description ?? '';
    if (_descCtrl.text != description) {
      _descCtrl.value = TextEditingValue(
        text: description,
        selection: TextSelection.collapsed(offset: description.length),
      );
    }
  }

  Future<void> _promptPasteUrl(
    BuildContext context,
    CategoryFormCubit cubit,
  ) async {
    final navigator = Navigator.of(context);
    final link = await showDialog<String>(
      context: context,
      builder: (_) => _LinkInputDialog(initialValue: cubit.state.imageUrl ?? ''),
    );
    if (link != null && link.isNotEmpty) {
      await cubit.importLogoFromUrl(navigator, link);
    }
  }
}

class _SectionIcon extends StatelessWidget {
  final IconData icon;
  final Color color;
  const _SectionIcon({required this.icon, required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 38,
      height: 38,
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.12),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Icon(icon, color: color),
    );
  }
}

class _LinkInputDialog extends StatefulWidget {
  final String initialValue;

  const _LinkInputDialog({required this.initialValue});

  @override
  State<_LinkInputDialog> createState() => _LinkInputDialogState();
}

class _LinkInputDialogState extends State<_LinkInputDialog> {
  late final TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Pegar URL de la imagen'),
      content: TextField(
        controller: _controller,
        autofocus: true,
        decoration: const InputDecoration(
          labelText: 'Enlace',
          hintText: 'https://ejemplo.com/logo.png',
        ),
        keyboardType: TextInputType.url,
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancelar'),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_controller.text.trim()),
          child: const Text('Usar enlace'),
        ),
      ],
    );
  }
}

enum _FormAction { save, delete }

 END FILE: modules/features/catalog/presentation/admin/categories/pages/category_form_page.dart 

Dentro de /widgets:

 FILE: modules/features/catalog/presentation/admin/categories/widgets/category_chip.dart 
import 'package:flutter/material.dart';

class CategoryChipBadge extends StatelessWidget {
  final String label;
  final bool highlighted;

  const CategoryChipBadge({
    super.key,
    required this.label,
    this.highlighted = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bg =
        highlighted
            ? theme.colorScheme.primary.withValues(alpha: 0.1)
            : theme.colorScheme.surfaceContainerHighest;
    final border =
        highlighted
            ? theme.colorScheme.primary
            : theme.colorScheme.outlineVariant.withValues(alpha: 0.7);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: border),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontWeight: FontWeight.w600,
          color:
              highlighted
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface,
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/admin/categories/widgets/category_chip.dart 

 FILE: modules/features/catalog/presentation/admin/categories/widgets/category_list_item.dart 
import 'package:flutter/material.dart';

import '../../../../domain/entities/category.dart';

class CategoryListItem extends StatelessWidget {
  final Category category;
  final VoidCallback onEdit;
  final VoidCallback onVisibilityToggle;
  final bool showDragHandle;
  final int? primaryPosition;
  final int? dragIndex;
  final Widget? dragHandle;

  const CategoryListItem({
    super.key,
    required this.category,
    required this.onEdit,
    required this.onVisibilityToggle,
    this.showDragHandle = false,
    this.primaryPosition,
    this.dragIndex,
    this.dragHandle,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    assert(
      !showDragHandle || dragIndex != null,
      'dragIndex is required when showDragHandle is true',
    );

    return Material(
      color: colorScheme.surface,
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
        side: BorderSide(
          color: colorScheme.outlineVariant.withValues(alpha: 0.7),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                if (dragHandle != null)
                  Padding(
                    padding: const EdgeInsets.only(right: 10),
                    child: dragHandle,
                  )
                else if (showDragHandle)
                  Padding(
                    padding: const EdgeInsets.only(right: 10),
                    child: ReorderableDragStartListener(
                      index: dragIndex!,
                      child: Container(
                        width: 36,
                        height: 44,
                        alignment: Alignment.center,
                        decoration: BoxDecoration(
                          color: colorScheme.surfaceContainerHighest
                              .withValues(alpha: 0.6),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Icon(
                          Icons.drag_indicator,
                          color: colorScheme.outline,
                          size: 18,
                        ),
                      ),
                    ),
                  ),
                _CategoryAvatarWithBadge(
                  imageUrl: category.imageUrl,
                  primaryPosition: primaryPosition,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        category.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: theme.textTheme.titleMedium,
                      ),
                      const SizedBox(height: 2),
                      Text(
                        _productsLabel(category.productsCount),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.w400,
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),
                Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    _VisibilityToggle(
                      isVisible: category.visible,
                      onChanged: (_) => onVisibilityToggle(),
                    ),
                    const SizedBox(height: 6),
                    TextButton.icon(
                      onPressed: onEdit,
                      style: TextButton.styleFrom(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 6,
                        ),
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                      icon: const Icon(Icons.edit, size: 18),
                      label: const Text('Editar'),
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

String _productsLabel(int count) {
  if (count == 0) return 'Sin productos';
  if (count == 1) return '1 producto';
  return '$count productos';
}

class _CategoryAvatarWithBadge extends StatelessWidget {
  final String? imageUrl;
  final int? primaryPosition;
  const _CategoryAvatarWithBadge({this.imageUrl, this.primaryPosition});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          width: 44,
          height: 44,
          decoration: BoxDecoration(
            color: colorScheme.surfaceContainerHighest,
            borderRadius: BorderRadius.circular(10),
            border: Border.all(
              color: colorScheme.outlineVariant.withValues(alpha: 0.7),
            ),
          ),
          clipBehavior: Clip.antiAlias,
          child: imageUrl == null || imageUrl!.isEmpty
              ? Icon(Icons.image_outlined, color: colorScheme.outline)
              : Image.network(
                  imageUrl!,
                  fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) => Icon(
                    Icons.broken_image_outlined,
                    color: colorScheme.outline,
                  ),
                ),
        ),
        if (primaryPosition != null)
          Positioned(
            right: -4,
            bottom: -4,
            child: _PrimaryBadge(number: primaryPosition!),
          ),
      ],
    );
  }
}

class _PrimaryBadge extends StatelessWidget {
  final int number;
  const _PrimaryBadge({required this.number});

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.all(4),
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.6),
      ),
      child: Text(
        '$number',
        style: TextStyle(
          fontWeight: FontWeight.w600,
          fontSize: 11,
          color: colorScheme.onSurfaceVariant,
        ),
      ),
    );
  }
}

class _VisibilityToggle extends StatelessWidget {
  final bool isVisible;
  final ValueChanged<bool> onChanged;
  const _VisibilityToggle({required this.isVisible, required this.onChanged});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final label = isVisible ? 'Visible' : 'Oculta';
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          label,
          style: theme.textTheme.bodySmall?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(width: 10),
        Switch.adaptive(
          value: isVisible,
          onChanged: onChanged,
        ),
      ],
    );
  }
}

 END FILE: modules/features/catalog/presentation/admin/categories/widgets/category_list_item.dart 

 FILE: modules/features/catalog/presentation/admin/categories/widgets/reorderable_category_list.dart 
import 'dart:ui';

import 'package:animated_list_plus/animated_list_plus.dart';
import 'package:animated_list_plus/transitions.dart';
import 'package:flutter/material.dart';

import '../../../../domain/entities/category.dart';
import 'category_list_item.dart';

class ReorderableCategoryList extends StatefulWidget {
  final List<Category> items;
  final void Function(List<Category>) onReorderCommitted;
  final void Function(Category) onEdit;
  final void Function(Category) onToggleVisible;
  final int primaryLimit;
  final bool showDragHandle;
  final Widget? restHeader;
  final List<Widget> header;
  final List<Widget> footer;
  final ScrollController? scrollController;
  final EdgeInsets? padding;

  const ReorderableCategoryList({
    super.key,
    required this.items,
    required this.onReorderCommitted,
    required this.onEdit,
    required this.onToggleVisible,
    this.primaryLimit = 6,
    this.showDragHandle = true,
    this.restHeader,
    this.header = const [],
    this.footer = const [],
    this.scrollController,
    this.padding,
  });

  @override
  State<ReorderableCategoryList> createState() =>
      _ReorderableCategoryListState();
}

class _ReorderableCategoryListState extends State<ReorderableCategoryList> {
  late List<Category> _local;

  @override
  void initState() {
    super.initState();
    _local = List.of(widget.items);
  }

  @override
  void didUpdateWidget(covariant ReorderableCategoryList oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.items != widget.items) {
      _local = List.of(widget.items);
    }
  }

  @override
  Widget build(BuildContext context) {
    final basePadding = widget.padding ?? EdgeInsets.zero;
    final effectivePadding = basePadding.copyWith(
      top: basePadding.top + 8,
      bottom: basePadding.bottom,
    );

    final list = ImplicitlyAnimatedReorderableList<Category>(
      items: _local,
      padding: effectivePadding,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      areItemsTheSame: (a, b) => a.id == b.id,
      onReorderFinished: (item, from, to, newItems) {
        setState(() {
          _local = _recalculate(newItems);
        });
        widget.onReorderCommitted(_local);
      },
      itemBuilder: (context, itemAnimation, category, index) {
        final isPrimary = index < widget.primaryLimit;
        final primaryPosition = isPrimary ? index + 1 : null;
        final showRestHeader =
            widget.restHeader != null &&
            index == widget.primaryLimit &&
            _local.length > widget.primaryLimit;

        return _buildReorderableCard(
          context,
          category,
          primaryPosition,
          itemAnimation,
          index,
          leading: showRestHeader ? widget.restHeader : null,
        );
      },
    );

    final hasHeader = widget.header.isNotEmpty;
    final hasFooter = widget.footer.isNotEmpty;

    if (!hasHeader && !hasFooter) {
      return list;
    }

    return CustomScrollView(
      controller: widget.scrollController,
      physics: const ClampingScrollPhysics(),
      slivers: [
        if (hasHeader)
          SliverToBoxAdapter(child: Column(children: widget.header)),
        SliverToBoxAdapter(child: list),
        if (hasFooter)
          SliverToBoxAdapter(child: Column(children: widget.footer)),
      ],
    );
  }

  Reorderable _buildReorderableCard(
    BuildContext context,
    Category category,
    int? primaryPosition,
    Animation<double> itemAnimation,
    int dragIndex,
    {Widget? leading}
  ) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final dragHandle = widget.showDragHandle
        ? Handle(
            delay: const Duration(milliseconds: 80),
            capturePointer: true,
            child: Container(
              width: 36,
              height: 44,
              alignment: Alignment.center,
              decoration: BoxDecoration(
                color: colorScheme.surfaceContainerHighest
                    .withValues(alpha: 0.6),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                Icons.drag_indicator,
                size: 18,
                color: colorScheme.outline,
              ),
            ),
          )
        : null;

    return Reorderable(
      key: ValueKey(category.id),
      builder: (context, dragAnimation, inDrag) {
        final t = dragAnimation.value;
        final elevation = lerpDouble(0, 8, t) ?? 0;
        final color = Color.lerp(
          Theme.of(context).colorScheme.surface,
          Theme.of(context).colorScheme.surface.withValues(alpha: 0.9),
          t,
        );

        Widget content = Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: CategoryListItem(
                category: category,
                onEdit: () => widget.onEdit(category),
                onVisibilityToggle: () => widget.onToggleVisible(category),
                showDragHandle: false,
                primaryPosition: primaryPosition,
                dragIndex: dragIndex,
                dragHandle: dragHandle,
              ),
            ),
          ],
        );

        if (leading != null) {
          content = Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              leading,
              const SizedBox(height: 8),
              content,
            ],
          );
        }

        return SizeFadeTransition(
          sizeFraction: 0.7,
          curve: Curves.easeInOut,
          animation: itemAnimation,
          child: Material(
            color: color,
            elevation: elevation,
            borderRadius: BorderRadius.circular(12),
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 6),
              child: content,
            ),
          ),
        );
      },
    );
  }

  List<Category> _recalculate(List<Category> source) {
    return List<Category>.generate(source.length, (i) {
      final base = source[i];
      final pos = i + 1;
      return base.copyWith(position: pos);
    });
  }
}

 END FILE: modules/features/catalog/presentation/admin/categories/widgets/reorderable_category_list.dart 

Dentro de /pages:

 FILE: modules/features/catalog/presentation/admin/pages/product_form_page.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:flutter_application_emprendedoras/modules/core/config/app_theme.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/forms/admin_form_section.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/forms/admin_media_picker_field.dart';
import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/shared/admin_form_field.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/entities/category.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/entities/admin_product.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/usecases/watch_categories_stream.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/presentation/admin/blocs/product_form/product_form_cubit.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/presentation/admin/blocs/product_form/product_form_state.dart';

class ProductFormPage extends StatefulWidget {
  final AdminProduct? initialProduct;
  final String? productId;
  final String? preselectedCategoryId;
  final WatchCategoriesStream watchCategories;

  const ProductFormPage({
    super.key,
    this.initialProduct,
    this.productId,
    this.preselectedCategoryId,
    required this.watchCategories,
  });

  @override
  State<ProductFormPage> createState() => _ProductFormPageState();
}

class _ProductFormPageState extends State<ProductFormPage> {
  final _nameCtrl = TextEditingController();
  final _unitsCtrl = TextEditingController();
  final _priceCtrl = TextEditingController();
  final _descriptionCtrl = TextEditingController();

  late final Stream<List<Category>> _visibleCategoriesStream;
  late final Stream<List<Category>> _allCategoriesStream;

  @override
  void initState() {
    super.initState();
    _visibleCategoriesStream = widget.watchCategories(onlyVisible: true);
    _allCategoriesStream = widget.watchCategories(onlyVisible: false);
    final cubit = context.read<ProductFormCubit>();
    if (widget.initialProduct != null) {
      cubit.initForEdit(widget.initialProduct!);
    } else {
      cubit.initForCreate(preselectedCategoryId: widget.preselectedCategoryId);
      if (widget.productId != null && widget.productId!.isNotEmpty) {
        cubit.loadById(widget.productId!);
      }
    }
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    _unitsCtrl.dispose();
    _priceCtrl.dispose();
    _descriptionCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocListener<ProductFormCubit, ProductFormState>(
      listenWhen: (previous, current) =>
          previous.errorMessage != current.errorMessage ||
          previous.saveSuccess != current.saveSuccess ||
          previous.name != current.name ||
          previous.unitsPerPack != current.unitsPerPack ||
          previous.basePrice != current.basePrice ||
          previous.description != current.description,
      listener: (context, state) {
        _syncControllers(state);
        if (state.errorMessage != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.errorMessage!)),
          );
        }
        if (state.saveSuccess) {
          Navigator.of(context).maybePop(true);
        }
      },
      child: BlocBuilder<ProductFormCubit, ProductFormState>(
        builder: (context, state) {
          final cubit = context.read<ProductFormCubit>();
          final title = state.isEditing ? 'Editar producto' : 'Nuevo producto';
          return Scaffold(
            appBar: AppBar(
              title: Text(title),
            ),
            body: SafeArea(
              child: SingleChildScrollView(
                padding: const EdgeInsets.fromLTRB(16, 12, 16, 120),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    AdminFormSection(
                      title: 'Datos b\u00e1sicos',
                      subtitle:
                          'Este producto se ver\u00e1 como parte de esta categor\u00eda en el cat\u00e1logo y filtros del mapa.',
                      leading: _SectionIcon(
                        icon: Icons.category_outlined,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      children: [
                        _CategorySelector(
                          visibleCategoriesStream: _visibleCategoriesStream,
                          selectedId: state.selectedCategoryId,
                          onSelected: cubit.onCategoryChanged,
                          onOpenAll: () => _openAllCategoriesSheet(context),
                        ),
                        AdminFormField(
                          label: 'Nombre del producto',
                          controller: _nameCtrl,
                          hintText: 'Ej.: Bandeja 6 empanadas',
                          prefixIcon: const Icon(Icons.drive_file_rename_outline),
                          textInputAction: TextInputAction.next,
                          onChanged: cubit.onNameChanged,
                        ),
                        _VisibilityChips(
                          value: state.isVisible,
                          onChanged: cubit.onVisibilityToggled,
                        ),
                        Text(
                          'Define si se muestra en pedidos y pantallas p\u00fablicas.',
                          style: Theme.of(context).textTheme.bodySmall,
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    AdminFormSection(
                      title: 'Presentaci\u00f3n y precio',
                      subtitle: 'Configura c\u00f3mo vendes este producto.',
                      leading: _SectionIcon(
                        icon: Icons.attach_money_outlined,
                        color: Theme.of(context).colorScheme.secondary,
                      ),
                      children: [
                        _UnitTypeChips(
                          selected: state.unitType,
                          onChanged: cubit.onUnitTypeChanged,
                        ),
                        AdminFormField(
                          label: 'Contenido por unidad',
                          controller: _unitsCtrl,
                          hintText: 'Ej.: 6',
                          prefixIcon: const Icon(Icons.format_list_numbered),
                          keyboardType: TextInputType.number,
                          supportingText: _unitsHelper(state.unitType),
                          onChanged: cubit.onUnitsPerPackChanged,
                        ),
                        AdminFormField(
                          label: 'Precio base',
                          controller: _priceCtrl,
                          hintText: 'Ej.: 1.50',
                          prefixIcon: const Icon(Icons.sell_outlined),
                          keyboardType:
                              const TextInputType.numberWithOptions(
                                decimal: true,
                              ),
                          supportingText:
                              'Precio normal de esta presentaci\u00f3n. Descuentos por cantidad se configuran en pedidos.',
                          onChanged: cubit.onBasePriceChanged,
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    AdminFormSection(
                      title: 'Sabores y variantes',
                      subtitle:
                          'Opcional. Para sabores (queso, carne, pollo) o tipos de masa (verde, harina).',
                      leading: _SectionIcon(
                        icon: Icons.local_dining_outlined,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      children: [
                        if (state.variants.isEmpty)
                          Text(
                            'A\u00fan no has agregado sabores.',
                            style: Theme.of(context).textTheme.bodyMedium,
                          ),
                        ...List.generate(
                          state.variants.length,
                          (index) => _VariantTile(
                            value: state.variants[index],
                            onChanged: (value) =>
                                cubit.updateVariant(index, value),
                            onRemove: () => cubit.removeVariant(index),
                          ),
                        ),
                        Align(
                          alignment: Alignment.centerLeft,
                          child: TextButton.icon(
                            onPressed: cubit.addVariant,
                            icon: const Icon(Icons.add),
                            label: const Text('Agregar sabor / variante'),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    AdminFormSection(
                      title: 'Imagen del producto',
                      subtitle: 'Opcional. Ayuda a que el cat\u00e1logo sea m\u00e1s visual.',
                      leading: _SectionIcon(
                        icon: Icons.image_outlined,
                        color: Theme.of(context).colorScheme.secondary,
                      ),
                      children: [
                        AdminMediaPickerField(
                          title: 'Imagen principal',
                          subtitle:
                              'Sube una foto o pega un enlace para mostrarla en el cat\u00e1logo.',
                          imageUrl: state.imageUrl,
                          imageBytes: state.localImageBytes,
                          processing: state.processingImage,
                          onPickImage: (navigator, source) =>
                              cubit.pickImage(navigator, source),
                          onPasteUrl: () => _promptImageUrl(
                            context,
                            onSelected: (link) => cubit.importImageFromUrl(
                              Navigator.of(context),
                              link,
                            ),
                          ),
                          onRemove: cubit.clearImage,
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    AdminFormSection(
                      title: 'Descripci\u00f3n corta',
                      subtitle:
                          'Opcional. Se muestra en la ficha del mapa y otras pantallas.',
                      leading: _SectionIcon(
                        icon: Icons.notes_outlined,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      children: [
                        AdminFormField(
                          label: 'Descripci\u00f3n',
                          controller: _descriptionCtrl,
                          hintText:
                              'Empanadas de verde rellenas, ideales para compartir.',
                          maxLines: 3,
                          minLines: 2,
                          textCapitalization: TextCapitalization.sentences,
                          onChanged: cubit.onDescriptionChanged,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
            bottomNavigationBar: _BottomBar(
              isSaving: state.isSaving,
              isValid: state.isValid,
              onDiscard: () => _handleDiscard(context, state),
              onSubmit: cubit.submit,
            ),
          );
        },
      ),
    );
  }

  void _syncControllers(ProductFormState state) {
    if (_nameCtrl.text != state.name) {
      _nameCtrl.value = TextEditingValue(
        text: state.name,
        selection: TextSelection.collapsed(offset: state.name.length),
      );
    }

    final unitsText = state.unitsPerPack?.toString() ?? '';
    if (_unitsCtrl.text != unitsText) {
      _unitsCtrl.value = TextEditingValue(
        text: unitsText,
        selection: TextSelection.collapsed(offset: unitsText.length),
      );
    }

    final priceText =
        state.basePrice != null ? state.basePrice!.toString() : '';
    if (_priceCtrl.text != priceText) {
      _priceCtrl.value = TextEditingValue(
        text: priceText,
        selection: TextSelection.collapsed(offset: priceText.length),
      );
    }

    final description = state.description ?? '';
    if (_descriptionCtrl.text != description) {
      _descriptionCtrl.value = TextEditingValue(
        text: description,
        selection: TextSelection.collapsed(offset: description.length),
      );
    }
  }

  String? _unitsHelper(UnitType? unitType) {
    return switch (unitType) {
      UnitType.tray => 'Unidades por bandeja',
      UnitType.combo => 'Contenido por combo',
      UnitType.bottle => 'Mililitros o litros por botella',
      UnitType.unit => 'Cantidad por unidad',
      null => null,
    };
  }

  Future<void> _handleDiscard(
    BuildContext context,
    ProductFormState state,
  ) async {
    if (!state.dirty) {
      Navigator.of(context).maybePop();
      return;
    }
    final confirm = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Descartar cambios'),
        content: const Text(
          'Perder\u00e1s los cambios. \u00bfSeguro que deseas descartar?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancelar'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Descartar'),
          ),
        ],
      ),
    );
    if (confirm == true && context.mounted) {
      Navigator.of(context).maybePop();
    }
  }

  Future<void> _openAllCategoriesSheet(BuildContext context) async {
    final cubit = context.read<ProductFormCubit>();
    final selectedId = cubit.state.selectedCategoryId;
    await showModalBottomSheet(
      context: context,
      builder: (_) {
        return StreamBuilder<List<Category>>(
          stream: _allCategoriesStream,
          builder: (context, snapshot) {
            final categories = snapshot.data ?? const <Category>[];
            if (categories.isEmpty) {
              return const SafeArea(
                child: Padding(
                  padding: EdgeInsets.all(16),
                  child: Text('A\u00fan no hay categor\u00edas'),
                ),
              );
            }
            return SafeArea(
              child: ListView.separated(
                padding: const EdgeInsets.all(16),
                itemBuilder: (context, index) {
                  final category = categories[index];
                  final isSelected = category.id == selectedId;
                  return ListTile(
                    leading: _VisibilityDot(visible: category.visible),
                    title: Text(category.name),
                    subtitle:
                        category.visible ? null : const Text('No visible'),
                    onTap: () {
                      cubit.onCategoryChanged(category.id);
                      Navigator.of(context).pop();
                    },
                    selected: isSelected,
                  );
                },
                separatorBuilder: (_, _) => const Divider(height: 1),
                itemCount: categories.length,
              ),
            );
          },
        );
      },
    );
  }
}

class _CategorySelector extends StatelessWidget {
  final Stream<List<Category>> visibleCategoriesStream;
  final String? selectedId;
  final ValueChanged<String> onSelected;
  final VoidCallback onOpenAll;

  const _CategorySelector({
    required this.visibleCategoriesStream,
    required this.selectedId,
    required this.onSelected,
    required this.onOpenAll,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        StreamBuilder<List<Category>>(
          stream: visibleCategoriesStream,
          builder: (context, snapshot) {
            final categories = snapshot.data ?? const <Category>[];
            if (categories.isEmpty) {
              return Text(
                'No hay categor\u00edas visibles. Crea una para continuar.',
                style: Theme.of(context).textTheme.bodyMedium,
              );
            }
            return SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: categories.map((category) {
                  final isSelected = category.id == selectedId;
                  return Padding(
                    padding: const EdgeInsets.only(right: 8),
                    child: ChoiceChip(
                      label: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          _VisibilityDot(visible: category.visible),
                          const SizedBox(width: 6),
                          Text(category.name),
                        ],
                      ),
                      selected: isSelected,
                      onSelected: (_) => onSelected(category.id),
                      selectedColor: Theme.of(context).colorScheme.primary,
                      labelStyle: TextStyle(
                        color:
                            isSelected
                                ? Colors.white
                                : Theme.of(context).textTheme.bodyMedium?.color,
                      ),
                    ),
                  );
                }).toList(),
              ),
            );
          },
        ),
        const SizedBox(height: 8),
        Align(
          alignment: Alignment.centerLeft,
          child: TextButton.icon(
            onPressed: onOpenAll,
            icon: const Icon(Icons.list_alt_outlined),
            label: const Text('Ver todas las categor\u00edas'),
          ),
        ),
      ],
    );
  }
}

class _VisibilityDot extends StatelessWidget {
  final bool visible;
  const _VisibilityDot({required this.visible});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 8,
      height: 8,
      decoration: BoxDecoration(
        color: visible ? Colors.green : Colors.red,
        shape: BoxShape.circle,
      ),
    );
  }
}

class _UnitTypeChips extends StatelessWidget {
  final UnitType? selected;
  final ValueChanged<UnitType> onChanged;

  const _UnitTypeChips({required this.selected, required this.onChanged});

  @override
  Widget build(BuildContext context) {
    const options = [
      (UnitType.tray, 'Bandeja'),
      (UnitType.unit, 'Unidad'),
      (UnitType.combo, 'Combo'),
      (UnitType.bottle, 'Botella'),
    ];
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: options.map((option) {
        final isSelected = option.$1 == selected;
        return ChoiceChip(
          label: Text(option.$2),
          selected: isSelected,
          onSelected: (_) => onChanged(option.$1),
          selectedColor: Theme.of(context).colorScheme.secondary,
          labelStyle: TextStyle(
            color:
                isSelected
                    ? Colors.white
                    : Theme.of(context).textTheme.bodyMedium?.color,
          ),
        );
      }).toList(),
    );
  }
}

class _VisibilityChips extends StatelessWidget {
  final bool value;
  final ValueChanged<bool> onChanged;

  const _VisibilityChips({required this.value, required this.onChanged});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final options = [
      (true, 'Visible'),
      (false, 'Oculto'),
    ];
    return Wrap(
      spacing: 8,
      children: options.map((option) {
        final selected = option.$1 == value;
        return ChoiceChip(
          label: Text(option.$2),
          selected: selected,
          onSelected: (_) => onChanged(option.$1),
          selectedColor: theme.colorScheme.primary,
          labelStyle: TextStyle(
            color:
                selected
                    ? Colors.white
                    : theme.textTheme.bodyMedium?.color,
          ),
        );
      }).toList(),
    );
  }
}

class _VariantTile extends StatelessWidget {
  final String value;
  final ValueChanged<String> onChanged;
  final VoidCallback onRemove;

  const _VariantTile({
    required this.value,
    required this.onChanged,
    required this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: TextFormField(
            initialValue: value,
            decoration: const InputDecoration(
              labelText: 'Nombre del sabor',
            ),
            onChanged: onChanged,
          ),
        ),
        IconButton(
          tooltip: 'Eliminar',
          onPressed: onRemove,
          icon: const Icon(Icons.delete_outline),
        ),
      ],
    );
  }
}

class _BottomBar extends StatelessWidget {
  final bool isSaving;
  final bool isValid;
  final VoidCallback onDiscard;
  final VoidCallback onSubmit;

  const _BottomBar({
    required this.isSaving,
    required this.isValid,
    required this.onDiscard,
    required this.onSubmit,
  });

  @override
  Widget build(BuildContext context) {
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;
    return SafeArea(
      child: AnimatedPadding(
        duration: const Duration(milliseconds: 180),
        padding: EdgeInsets.only(
          left: 16,
          right: 16,
          bottom: bottomInset == 0 ? 16 : bottomInset,
          top: 12,
        ),
        child: Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: isSaving ? null : onDiscard,
                child: const Text('Descartar'),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: FilledButton(
                onPressed: isValid && !isSaving ? onSubmit : null,
                style: FilledButton.styleFrom(
                  minimumSize: const Size.fromHeight(48),
                  backgroundColor: AppTheme.deepBlue,
                ),
                child: isSaving
                    ? const SizedBox(
                        height: 18,
                        width: 18,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            Colors.white,
                          ),
                        ),
                      )
                    : const Text('Guardar producto'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _SectionIcon extends StatelessWidget {
  final IconData icon;
  final Color color;

  const _SectionIcon({required this.icon, required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 38,
      height: 38,
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.12),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Icon(icon, color: color),
    );
  }
}

Future<void> _promptImageUrl(
  BuildContext context, {
  required Future<void> Function(String) onSelected,
}) async {
  final controller = TextEditingController();
  final link = await showDialog<String>(
    context: context,
    builder: (_) => AlertDialog(
      title: const Text('Pegar URL de la imagen'),
      content: TextField(
        controller: controller,
        autofocus: true,
        decoration: const InputDecoration(
          labelText: 'Enlace',
          hintText: 'https://ejemplo.com/imagen.png',
        ),
        keyboardType: TextInputType.url,
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancelar'),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(controller.text.trim()),
          child: const Text('Usar'),
        ),
      ],
    ),
  );
  if (link != null && link.isNotEmpty && context.mounted) {
    await onSelected(link);
  }
}

 END FILE: modules/features/catalog/presentation/admin/pages/product_form_page.dart 

 FILE: modules/features/catalog/presentation/admin/pages/products_list_page.dart 
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:flutter_application_emprendedoras/modules/features/admin/presentation/widgets/shared/admin_surface.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/entities/category.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/entities/admin_product.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/usecases/admin/save_product_usecase.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/usecases/browse/get_product_usecase.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/domain/usecases/watch_categories_stream.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/catalog_routes.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/presentation/admin/blocs/product_form/product_form_cubit.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/presentation/admin/blocs/products_list/products_list_cubit.dart';
import 'package:flutter_application_emprendedoras/modules/features/catalog/presentation/admin/blocs/products_list/products_list_state.dart';

import 'product_form_page.dart';

class ProductsListPage extends StatefulWidget {
  final WatchCategoriesStream watchCategories;
  final SaveProductUseCase saveProductUseCase;
  final GetProductUseCase getProductUseCase;

  const ProductsListPage({
    super.key,
    required this.watchCategories,
    required this.saveProductUseCase,
    required this.getProductUseCase,
  });

  @override
  State<ProductsListPage> createState() => _ProductsListPageState();
}

class _ProductsListPageState extends State<ProductsListPage> {
  late final Stream<List<Category>> _categoriesStream;

  @override
  void initState() {
    super.initState();
    _categoriesStream = widget.watchCategories(onlyVisible: false);
    context.read<ProductsListCubit>().start();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Productos del cat\u00e1logo'),
        leading: BackButton(onPressed: () => _handleBack(context)),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _openCreate(context),
        icon: const Icon(Icons.add),
        label: const Text('Nuevo producto'),
      ),
      body: StreamBuilder<List<Category>>(
        stream: _categoriesStream,
        builder: (context, snapshot) {
          final categoryNames = {
            for (final category in snapshot.data ?? const <Category>[])
              category.id: category.name,
          };
          return BlocBuilder<ProductsListCubit, ProductsListState>(
            builder: (context, state) {
              if (state.status == ProductsListStatus.loading &&
                  state.products.isEmpty) {
                return const Center(child: CircularProgressIndicator());
              }

              if (state.status == ProductsListStatus.error &&
                  state.products.isEmpty) {
                return _ErrorView(
                  message: state.errorMessage ?? 'No se pudo cargar',
                  onRetry: () =>
                      context.read<ProductsListCubit>().retry(),
                );
              }

              if (state.products.isEmpty) {
                return _EmptyView(onCreate: () => _openCreate(context));
              }

              return RefreshIndicator(
                onRefresh: () async {
                  context.read<ProductsListCubit>().retry();
                },
                child: ListView.separated(
                  physics: const AlwaysScrollableScrollPhysics(),
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
                  itemBuilder: (context, index) {
                    final product = state.products[index];
                    final category = categoryNames[product.categoryId];
                    return _ProductTile(
                      product: product,
                      categoryName: category,
                      onTap: () => _openEdit(context, product),
                    );
                  },
                  separatorBuilder: (context, _) => const SizedBox(height: 12),
                  itemCount: state.products.length,
                ),
              );
            },
          );
        },
      ),
    );
  }

  void _openCreate(BuildContext context) {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => BlocProvider(
          create: (_) => ProductFormCubit(
            saveProductUseCase: widget.saveProductUseCase,
            getProductUseCase: widget.getProductUseCase,
          ),
          child: ProductFormPage(
            watchCategories: widget.watchCategories,
          ),
        ),
      ),
    );
  }

  void _openEdit(BuildContext context, AdminProduct product) {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => BlocProvider(
          create: (_) => ProductFormCubit(
            saveProductUseCase: widget.saveProductUseCase,
            getProductUseCase: widget.getProductUseCase,
          ),
          child: ProductFormPage(
            watchCategories: widget.watchCategories,
            initialProduct: product,
          ),
        ),
      ),
    );
  }

  Future<void> _handleBack(BuildContext context) async {
    final navigator = Navigator.of(context);
    final didPop = await navigator.maybePop();
    if (!didPop && navigator.mounted) {
      navigator.pushReplacementNamed(CatalogRoutes.home);
    }
  }
}

class _ProductTile extends StatelessWidget {
  final AdminProduct product;
  final String? categoryName;
  final VoidCallback onTap;

  const _ProductTile({
    required this.product,
    required this.categoryName,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;
    return InkWell(
      onTap: onTap,
      child: AdminSurface(
        padding: const EdgeInsets.all(14),
        child: Row(
          children: [
            _ProductImage(url: product.imageUrl),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    product.name,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.w700,
                        ),
                  ),
                  if (categoryName != null) ...[
                    const SizedBox(height: 2),
                    Text(
                      categoryName!,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ],
                  const SizedBox(height: 4),
                  Text(
                    '${_unitLabel(product.unitType)} \u00b7 \$${product.basePrice.toStringAsFixed(2)}',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context)
                              .textTheme
                              .bodySmall
                              ?.color
                              ?.withValues(alpha: 0.8),
                        ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 8),
            Chip(
              label: Text(product.isVisible ? 'Visible' : 'Oculto'),
              backgroundColor: product.isVisible
                  ? scheme.primary.withValues(alpha: 0.12)
                  : scheme.surfaceContainerHighest,
              labelStyle: TextStyle(
                color: product.isVisible ? scheme.primary : scheme.outline,
              ),
            ),
            const Icon(Icons.chevron_right),
          ],
        ),
      ),
    );
  }

  String _unitLabel(UnitType unitType) {
    return switch (unitType) {
      UnitType.tray => 'Bandeja',
      UnitType.unit => 'Unidad',
      UnitType.combo => 'Combo',
      UnitType.bottle => 'Botella',
    };
  }
}

class _ProductImage extends StatelessWidget {
  final String? url;
  const _ProductImage({this.url});

  @override
  Widget build(BuildContext context) {
    final placeholder = Container(
      width: 64,
      height: 64,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
      ),
      child: const Icon(Icons.fastfood_outlined),
    );
    if (url == null || url!.isEmpty) return placeholder;
    return ClipRRect(
      borderRadius: BorderRadius.circular(12),
      child: Image.network(
        url!,
        width: 64,
        height: 64,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) => placeholder,
      ),
    );
  }
}

class _EmptyView extends StatelessWidget {
  final VoidCallback onCreate;
  const _EmptyView({required this.onCreate});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.inbox_outlined, size: 48),
            const SizedBox(height: 8),
            const Text('A\u00fan no hay productos'),
            const SizedBox(height: 12),
            FilledButton.icon(
              onPressed: onCreate,
              icon: const Icon(Icons.add),
              label: const Text('Nuevo producto'),
            ),
          ],
        ),
      ),
    );
  }
}

class _ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;

  const _ErrorView({required this.message, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(message, textAlign: TextAlign.center),
            const SizedBox(height: 12),
            FilledButton.icon(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              label: const Text('Reintentar'),
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/admin/pages/products_list_page.dart 

Dentro de /blocs:

----- FILE: modules/features/catalog/presentation/blocs/catalog_cubit.dart -----
import 'dart:typed_data';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/services/storage/i_file_storage_service.dart';
import '../../../../core/config/storage_flags.dart';
import '../../../../core/utils/data/image_bytes.dart';
import '../../../catalog/domain/entities/public_product.dart';
import '../../../catalog/domain/entities/presentation.dart';
import '../../../catalog/domain/usecases/get_products_with_presentations.dart';
import '../../../catalog/domain/usecases/add_presentation.dart';

sealed class CatalogState {}

class CatalogLoading extends CatalogState {}

class CatalogLoaded extends CatalogState {
  final PublicProduct product;
  final List<Presentation> presentations;
  final bool isDirty;

  CatalogLoaded({
    required this.product,
    required this.presentations,
    this.isDirty = false,
  });

  CatalogLoaded copyWith({
    PublicProduct? product,
    List<Presentation>? presentations,
    bool? isDirty,
  }) => CatalogLoaded(
    product: product ?? this.product,
    presentations: presentations ?? this.presentations,
    isDirty: isDirty ?? this.isDirty,
  );
}

class CatalogError extends CatalogState {
  final String message;
  CatalogError(this.message);
}

class CatalogCubit extends Cubit<CatalogState> {
  final GetProductsWithPresentations getProducts;
  final AddPresentation addPresentation;
  final IFileStorageService primaryStorage;
  final IFileStorageService? fallbackStorage;

  late String _productId;

  // Imagen pendiente (privada)
  Uint8List? _pendingBytes;
  String? _pendingContentType;

  CatalogCubit({
    required this.getProducts,
    required this.addPresentation,
    required this.primaryStorage,
    this.fallbackStorage,
  }) : super(CatalogLoading());

  Future<void> loadProduct(String productId) async {
    _productId = productId;
    emit(CatalogLoading());
    try {
      final res = await getProducts(productId);
      final product = res.product;
      final pres = res.presentations;
      if (product == null) {
        emit(CatalogError('Producto no existe'));
        return;
      }
      emit(CatalogLoaded(product: product, presentations: pres));
    } catch (_) {
      emit(CatalogError('No se pudo cargar el producto'));
    }
  }

  void markDirty() {
    final st = state;
    if (st is CatalogLoaded && !st.isDirty) {
      emit(st.copyWith(isDirty: true));
    }
  }

  void setPendingImage(Uint8List bytes, String contentType) {
    _pendingBytes = bytes;
    _pendingContentType = contentType;
    markDirty();
  }

  Future<String?> _uploadIfNeeded(String uidHint) async {
    if (_pendingBytes == null || _pendingContentType == null) return null;
    final fileName = ImageBytesHelper.buildFileName(
      uid: uidHint,
      base: 'presentation',
      contentType: _pendingContentType!,
    );
    try {
      final r = await primaryStorage.uploadBytes(
        bytes: _pendingBytes!,
        fileName: fileName,
        contentType: _pendingContentType!,
        folder: StorageFlags.catalogFolder,
      );
      return r.url;
    } catch (_) {
      if (fallbackStorage == null) rethrow;
      final r = await fallbackStorage!.uploadBytes(
        bytes: _pendingBytes!,
        fileName: fileName,
        contentType: _pendingContentType!,
        folder: StorageFlags.catalogFolder,
      );
      return r.url;
    } finally {
      // Limpia pending al terminar
      _pendingBytes = null;
      _pendingContentType = null;
    }
  }

  Future<void> saveNewPresentation({
    required String name,
    required double unitPrice,
    required int minQty,
    int order = 0,
    String? existingPresentationId,
    String? currentImageUrl,
  }) async {
    final st = state;
    if (st is! CatalogLoaded) return;

    try {
      final imageUrl = await _uploadIfNeeded(_productId) ?? currentImageUrl;

      final data = Presentation(
        id: existingPresentationId ?? '',
        name: name.trim(),
        unitPrice: unitPrice,
        minQty: minQty,
        imageUrl: imageUrl,
        order: order,
      );

      await addPresentation(
        productId: _productId,
        data: data,
        presentationId: existingPresentationId,
      );

      await loadProduct(_productId);
    } catch (_) {
      emit(CatalogError('No se pudo guardar la presentaciÃ³n'));
    }
  }
}

--- END FILE: modules/features/catalog/presentation/blocs/catalog_cubit.dart ---

----- FILE: modules/features/catalog/presentation/blocs/category_cubit.dart ----
// modules/features/catalog/presentation/blocs/category_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/product_mini.dart';
import '../../domain/usecases/get_products_by_category.dart';

sealed class CategoryState {}
class CategoryLoading extends CategoryState {}
class CategoryError extends CategoryState {
  final String message;
  CategoryError(this.message);
}
class CategoryLoaded extends CategoryState {
  final String categoryId;
  final String? subcategory;
  final List<ProductMini> items;
  CategoryLoaded({
    required this.categoryId,
    required this.items,
    this.subcategory,
  });

  CategoryLoaded copyWith({
    String? categoryId,
    String? subcategory,
    List<ProductMini>? items,
  }) => CategoryLoaded(
        categoryId: categoryId ?? this.categoryId,
        subcategory: subcategory ?? this.subcategory,
        items: items ?? this.items,
      );
}

class CategoryCubit extends Cubit<CategoryState> {
  final GetProductsByCategory _getByCategory;
  final String _categoryId;

  String? _sub;

  CategoryCubit(this._getByCategory, {required String categoryId, String? sub})
      : _categoryId = categoryId,
        _sub = sub,
        super(CategoryLoading()) {
    load();
  }

  Future<void> load() async {
    emit(CategoryLoading());
    try {
      final list = await _getByCategory(
        categoryId: _categoryId,
        subcategory: _sub,
      );
      emit(CategoryLoaded(categoryId: _categoryId, subcategory: _sub, items: list));
    } catch (_) {
      emit(CategoryError('No pudimos cargar la categorÃ­a'));
    }
  }

  void selectSubcategory(String? sub) {
    _sub = sub;
    load();
  }
}

--- END FILE: modules/features/catalog/presentation/blocs/category_cubit.dart --

--- FILE: modules/features/catalog/presentation/blocs/home_catalog_cubit.dart --
// modules/features/catalog/presentation/blocs/home_catalog_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../domain/entities/category.dart';
import '../../domain/entities/product_mini.dart';
import '../../domain/entities/section.dart';
import '../../domain/usecases/get_categories.dart';
import '../../domain/usecases/get_home_sections.dart';
import '../../domain/usecases/get_primary_categories_limit.dart';
import '../../domain/value_objects/catalog_mode.dart';

sealed class HomeCatalogState {}

class HomeCatalogLoading extends HomeCatalogState {}

class HomeCatalogError extends HomeCatalogState {
  final String message;
  HomeCatalogError(this.message);
}

class SectionVM<T> {
  final String id;
  final String title;
  final List<T> items;
  const SectionVM({required this.id, required this.title, required this.items});

  SectionVM<T> withTitle(String t) =>
      SectionVM<T>(id: id, title: t, items: items);
}

class HomeCatalogLoaded extends HomeCatalogState {
  final CatalogMode mode;
  final SectionVM<ProductMini> forYou;
  final SectionVM<ProductMini> repeat;
  final SectionVM<ProductMini> priceCap;
  final SectionVM<ProductMini> bestSellers;
  final List<Category> categories;
  final FooterBanner? footerBanner;
  final List<ProductMini> searchSource;
  final int primaryLimit;

  HomeCatalogLoaded({
    required this.mode,
    required this.forYou,
    required this.repeat,
    required this.priceCap,
    required this.bestSellers,
    required this.categories,
    required this.searchSource,
    required this.primaryLimit,
    this.footerBanner,
  });

  HomeCatalogLoaded copyWith({
    CatalogMode? mode,
    SectionVM<ProductMini>? forYou,
    SectionVM<ProductMini>? repeat,
    SectionVM<ProductMini>? priceCap,
    SectionVM<ProductMini>? bestSellers,
    List<Category>? categories,
    FooterBanner? footerBanner,
    List<ProductMini>? searchSource,
    int? primaryLimit,
  }) =>
      HomeCatalogLoaded(
        mode: mode ?? this.mode,
        forYou: forYou ?? this.forYou,
        repeat: repeat ?? this.repeat,
        priceCap: priceCap ?? this.priceCap,
        bestSellers: bestSellers ?? this.bestSellers,
        categories: categories ?? this.categories,
        footerBanner: footerBanner ?? this.footerBanner,
        searchSource: searchSource ?? this.searchSource,
        primaryLimit: primaryLimit ?? this.primaryLimit,
      );
}

class HomeCatalogCubit extends Cubit<HomeCatalogState> {
  final GetHomeSections getHomeSections;
  final GetCategories getCategories;
  final GetPrimaryCategoriesLimit getPrimaryCategoriesLimit;

  CatalogMode _mode = CatalogMode.oficial;

  HomeCatalogCubit(
    this.getHomeSections,
    this.getCategories,
    this.getPrimaryCategoriesLimit,
  ) : super(HomeCatalogLoading());

  Future<void> load() async {
    emit(HomeCatalogLoading());
    try {
      final sections = await getHomeSections(mode: _mode);
      final primaryLimit = await getPrimaryCategoriesLimit();
      final cats = await getCategories();
      final visibleCats = cats.where((c) => c.visible).toList();

      emit(
        HomeCatalogLoaded(
          mode: _mode,
          forYou: SectionVM<ProductMini>(
            id: 'home_for_you',
            title: 'Te puede interesar',
            items: sections.forYou,
          ),
          repeat: SectionVM<ProductMini>(
            id: 'home_repeat',
            title: 'Repite lo que ya pediste',
            items: sections.repeat,
          ),
          priceCap: SectionVM<ProductMini>(
            id: 'home_price_cap',
            title: sections.combos.isNotEmpty
                ? 'Combos desde \$${sections.combosFrom.toStringAsFixed(0)}'
                : 'Favoritos de la casa',
            items: sections.combos.isNotEmpty
                ? sections.combos
                : sections.favorites,
          ),
          bestSellers: SectionVM<ProductMini>(
            id: 'home_best_sellers',
            title: 'Mas vendidos',
            items: sections.bestSellers,
          ),
          categories: visibleCats,
          footerBanner: sections.footerBanner,
          searchSource: sections.searchSource,
          primaryLimit: primaryLimit,
        ),
      );
    } catch (_) {
      emit(HomeCatalogError('No se pudo cargar el catalogo'));
    }
  }

  Future<void> reload() => load();

  void switchMode(CatalogMode m) {
    _mode = m;
    load();
  }
}

- END FILE: modules/features/catalog/presentation/blocs/home_catalog_cubit.dart 

Dentro de /pages:

--- FILE: modules/features/catalog/presentation/pages/catalog_home_host.dart ---
// lib/modules/features/catalog/presentation/pages/catalog_home_host.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

// import '../../catalog_routes.dart' show CatalogRoutes;
import '../../domain/usecases/get_home_sections.dart';
import '../../domain/usecases/get_categories.dart';
import '../../domain/usecases/get_primary_categories_limit.dart';
// import '../../domain/value_objects/catalog_mode.dart';
import '../../data/datasources/sections_remote_datasource.dart' as sections_ds;
import '../../data/datasources/categories_remote_datasource.dart' as cats_ds;
import '../../data/repositories/sections_repository_impl.dart';
import '../../data/repositories/categories_repository_impl.dart';
import '../../data/repositories/catalog_settings_repository_impl.dart';
import '../blocs/home_catalog_cubit.dart';
import 'catalog_home_page.dart';

/// Host para embebido dentro de HomePage (tabs).
/// Replica el DI usado en rutas para no mezclar responsabilidades en Pages.
class CatalogHomeHost extends StatelessWidget {
  const CatalogHomeHost({super.key});

  @override
  Widget build(BuildContext context) {
    final fs = FirebaseFirestore.instance;

    final sectionsDs = sections_ds.SectionsRemoteDataSource(fs);
    final categoriesDs = cats_ds.CategoriesRemoteDataSource(fs);

    final sectionsRepo = SectionsRepositoryImpl(sectionsDs, fs);
    final categoriesRepo = CategoriesRepositoryImpl(categoriesDs);
    final settingsRepo = CatalogSettingsRepositoryImpl(fs);

    final getHomeSections = GetHomeSections(sectionsRepo);
    final getCategories = GetCategories(categoriesRepo);
    final getPrimaryLimit = GetPrimaryCategoriesLimit(settingsRepo);

    return BlocProvider<HomeCatalogCubit>(
      create: (_) => HomeCatalogCubit(
        getHomeSections,
        getCategories,
        getPrimaryLimit,
      )..load(),
      child: const CatalogHomePage(),
    );
  }
}

- END FILE: modules/features/catalog/presentation/pages/catalog_home_host.dart -

--- FILE: modules/features/catalog/presentation/pages/catalog_home_page.dart ---
// modules/features/catalog/presentation/pages/catalog_home_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/images/safe_network_image.dart';
import '../../../../core/blocs/net_signal_cubit.dart';
import '../../../cart/presentation/widgets/cart_icon_button.dart';
import '../../domain/entities/category.dart';
import '../../domain/entities/product_mini.dart';
import '../../domain/value_objects/catalog_mode.dart';
import '../../catalog_routes.dart';
import '../blocs/home_catalog_cubit.dart';
import '../widgets/header/mode_selector_header.dart';
import '../widgets/editorial_banner.dart';
import '../widgets/categories/category_grid.dart';
import '../widgets/categories/all_categories_sheet.dart';
import '../widgets/carousels/section_carousel.dart';
import '../widgets/product/product_card_official.dart';
import '../widgets/product/product_card_vitrina.dart';
import '../widgets/skeletons/skeletons.dart';
import '../widgets/search/catalog_search_delegate.dart';
import '../widgets/categories/highlighted_categories_row.dart';
import '../widgets/filters/filter_row.dart';

class CatalogHomePage extends StatefulWidget {
  const CatalogHomePage({super.key});

  @override
  State<CatalogHomePage> createState() => _CatalogHomePageState();
}

class _CatalogHomePageState extends State<CatalogHomePage> {
  final ScrollController _scroll = ScrollController();

  void _openSearch(List<ProductMini> source) {
    showSearch<ProductMini?>(
      context: context,
      delegate: CatalogSearchDelegate(
        source: source,
        onOpen: (p) => Navigator.pushNamed(
          context,
          CatalogRoutes.productDetail,
          arguments: {'productId': p.id},
        ),
      ),
    );
  }

  void _openAllCategories(List<Category> cats) async {
    final result = await showModalBottomSheet<Category?>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (_) => AllCategoriesSheet(categories: cats),
    );
    if (!mounted || result == null) return;
    Navigator.pushNamed(
      context,
      CatalogRoutes.category,
      arguments: {'categoryId': result.id, 'name': result.name},
    );
  }

  @override
  Widget build(BuildContext context) {
    final net = context.watch<NetSignalCubit>().state;
    final online = net == NetStatus.online;

    return BlocBuilder<HomeCatalogCubit, HomeCatalogState>(
      builder: (context, state) {
        final bool loading = state is HomeCatalogLoading;
        final bool error = state is HomeCatalogError;
        final data = state is HomeCatalogLoaded ? state : null;

        final searchSource = data?.searchSource ?? <ProductMini>[];
        final categories = data?.categories ?? <Category>[];
        final primaryLimit = data != null ? (categories.length < 6 ? categories.length : 6) : 6;

        return Scaffold(
          appBar: AppBar(
            title: const Text('CatÃ¡logo'),
            centerTitle: true,
            actions: [
              Padding(
                padding: const EdgeInsets.only(right: 8),
                child: ModeSelectorHeader(
                  mode: data?.mode ?? CatalogMode.oficial,
                  onModeChanged: (m) =>
                      context.read<HomeCatalogCubit>().switchMode(m),
                  onSearchTap: () => _openSearch(searchSource),
                  cart: const CartIconButton(),
                ),
              ),
            ],
          ),
          body: RefreshIndicator(
            onRefresh: () => context.read<HomeCatalogCubit>().reload(),
            child: CustomScrollView(
              controller: _scroll,
              slivers: [
                const SliverToBoxAdapter(
                  child: Padding(
                    padding: EdgeInsets.fromLTRB(12, 10, 12, 8),
                    child: FilterRow(),
                  ),
                ),

                // ââ CategorÃ­as destacadas (placeholders si vacÃ­o/offline)
                SliverToBoxAdapter(
                  child: HighlightedCategoriesRow(
                    categories: categories,
                    maxVisible: primaryLimit,
                    showWhenEmpty: true,
                    onTapCategory:
                        (c) => Navigator.pushNamed(
                          context,
                          CatalogRoutes.category,
                          arguments: {'categoryId': c.id, 'name': c.name},
                        ),
                    onShowAll: categories.isNotEmpty && online
                        ? () => _openAllCategories(categories)
                        : null, // deshabilita si vacÃ­o u offline
                  ),
                ),

                // Branding + banner editorial
                SliverToBoxAdapter(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: const [
                      _BrandStrip(),
                      SizedBox(height: 8),
                      Padding(
                        padding: EdgeInsets.symmetric(horizontal: 16),
                        child: EditorialBanner(
                          title: 'FÃ¡brica 100 Mujeres Trabajando',
                          subtitle:
                              'Productos elaborados artesanalmente por mujeres de la comunidad.',
                          gradient: [
                            Color(0xFFE05CA0),
                            Color(0xFF5C39B5),
                          ],
                        ),
                      ),
                      SizedBox(height: 8),
                    ],
                  ),
                ),

                if (loading) const SliverToBoxAdapter(child: SectionSkeleton()),
                if (error)
                  const SliverToBoxAdapter(
                    child: Padding(
                      padding: EdgeInsets.all(16),
                      child: Text('No pudimos cargar secciones.'),
                    ),
                  ),

                if (!loading)
                  SliverToBoxAdapter(
                    child: SectionCarousel<ProductMini>(
                      title: 'Recomendados',
                      items: data?.forYou.items ?? const [],
                      showWhenEmpty: true, // ð cuadros grises si vacÃ­o
                      itemBuilder: (ctx, it) =>
                          (data?.mode ?? CatalogMode.oficial) == CatalogMode.oficial
                              ? ProductCardOfficial(item: it)
                              : ProductCardVitrina(
                                  item: VitrinaItem(id: it.id, name: it.name),
                                ),
                    ),
                  ),
                if (!loading)
                  SliverToBoxAdapter(
                    child: SectionCarousel<ProductMini>(
                      title: 'Repite lo que ya pediste',
                      items: data?.repeat.items ?? const [],
                      showWhenEmpty: true,
                      itemBuilder: (ctx, it) =>
                          (data?.mode ?? CatalogMode.oficial) == CatalogMode.oficial
                              ? ProductCardOfficial(item: it)
                              : ProductCardVitrina(
                                  item: VitrinaItem(id: it.id, name: it.name),
                                ),
                    ),
                  ),
                if (!loading)
                  SliverToBoxAdapter(
                    child: SectionCarousel<ProductMini>(
                      title: data?.priceCap.title ?? 'Favoritos de la casa',
                      items: data?.priceCap.items ?? const [],
                      showWhenEmpty: true,
                      itemBuilder: (ctx, it) =>
                          (data?.mode ?? CatalogMode.oficial) == CatalogMode.oficial
                              ? ProductCardOfficial(item: it)
                              : ProductCardVitrina(
                                  item: VitrinaItem(id: it.id, name: it.name),
                                ),
                    ),
                  ),

                // Encabezado "CategorÃ­as" + botÃ³n "Ver todas" (deshabilitado si no hay)
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(16, 6, 16, 10),
                    child: Row(
                      children: [
                        const Expanded(
                          child: Text(
                            'CategorÃ­as',
                            style: TextStyle(
                              fontWeight: FontWeight.w900,
                              fontSize: 18,
                              color: AppTheme.deepBlue,
                            ),
                          ),
                        ),
                        TextButton(
                          onPressed: categories.isNotEmpty && online
                              ? () => _openAllCategories(categories)
                              : null, // deshabilitado
                          child: const Text('Ver todas'),
                        ),
                      ],
                    ),
                  ),
                ),
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 12),
                    child: CategoryGrid(
                      categories: categories,
                      showWhenEmpty: true, // ð grilla fantasma si vacÃ­o
                      onTap: (c) => Navigator.pushNamed(
                        context,
                        CatalogRoutes.category,
                        arguments: {'categoryId': c.id, 'name': c.name},
                      ),
                    ),
                  ),
                ),

                if (!loading)
                  SliverToBoxAdapter(
                    child: SectionCarousel<ProductMini>(
                      title: 'MÃ¡s vendidos',
                      items: data?.bestSellers.items ?? const [],
                      showWhenEmpty: true,
                      itemBuilder: (ctx, it) =>
                          (data?.mode ?? CatalogMode.oficial) == CatalogMode.oficial
                              ? ProductCardOfficial(item: it)
                              : ProductCardVitrina(
                                  item: VitrinaItem(id: it.id, name: it.name),
                                ),
                    ),
                  ),
                if (data?.footerBanner != null)
                  SliverToBoxAdapter(
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 24),
                      child: EditorialBanner(
                        title: data!.footerBanner!.title,
                        subtitle: data.footerBanner!.subtitle,
                        imageUrl: data.footerBanner!.imageUrl,
                      ),
                    ),
                  ),

                const SliverToBoxAdapter(child: SizedBox(height: 16)),
              ],
            ),
          ),
        );
      },
    );
  }
}

class _BrandStrip extends StatelessWidget {
  const _BrandStrip();

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 10, 16, 4),
      child: Row(
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: const SizedBox(
              width: 40,
              height: 40,
              child: SafeNetworkImage(
                url:
                    'https://res.cloudinary.com/diopytenw/image/upload/v1730000000/app100mt/logo_mini.png',
                fit: BoxFit.cover,
              ),
            ),
          ),
          const SizedBox(width: 10),
          const Expanded(
            child: Text(
              '100 Mujeres Trabajando',
              style: TextStyle(
                fontWeight: FontWeight.w900,
                fontSize: 16,
                color: AppTheme.deepBlue,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

- END FILE: modules/features/catalog/presentation/pages/catalog_home_page.dart -

----- FILE: modules/features/catalog/presentation/pages/category_page.dart -----
// modules/features/catalog/presentation/pages/category_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/category.dart';
import '../../domain/entities/product_mini.dart';
import '../blocs/category_cubit.dart';
import '../widgets/product/product_card_official.dart';

class CategoryPage extends StatefulWidget {
  final Category category;
  const CategoryPage({super.key, required this.category});

  @override
  State<CategoryPage> createState() => _CategoryPageState();
}

class _CategoryPageState extends State<CategoryPage> {
  final ScrollController _sc = ScrollController();
  late String _activeSub;

  List<String> get _subs {
    switch (widget.category.id) {
      case 'empanadas':
        return const ['Todo', 'Queso', 'Pollo', 'Carne', 'Mixtas'];
      case 'muchines':
        return const ['Todo', 'Verde', 'Yuca', 'Maduro'];
      case 'acomp':
        return const ['Todo', 'AjÃ­', 'Salsa rosada', 'Encurtido'];
      case 'bebidas':
        return const ['Todo', 'Frutilla', 'MaracuyÃ¡', 'Naranja', 'CafÃ© frÃ­o'];
      case 'postres':
        return const ['Todo', 'Flan', 'Brownie', 'Cupcake'];
      case 'combos':
        return const ['Todo', 'Familiar', 'DegustaciÃ³n', 'Promocional'];
      default:
        return const ['Todo'];
    }
  }

  @override
  void initState() {
    super.initState();
    _activeSub = _subs.first;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.category.name),
        centerTitle: true,
      ),
      body: CustomScrollView(
        controller: _sc,
        slivers: [
          // Subfiltros (ChoiceChips) â la lÃ³gica de carga estÃ¡ en el BLoC
          SliverAppBar(
            pinned: true,
            automaticallyImplyLeading: false,
            toolbarHeight: 48,
            title: SizedBox(
              height: 36,
              child: ListView.separated(
                scrollDirection: Axis.horizontal,
                itemBuilder: (_, i) {
                  final id = _subs[i];
                  final selected = id == _activeSub;
                  return ChoiceChip(
                    label: Text(id),
                    selected: selected,
                    onSelected: (_) {
                      setState(() => _activeSub = id);
                      context.read<CategoryCubit>()
                        .selectSubcategory(id == 'Todo' ? null : id);
                    },
                  );
                },
                // â ï¸ Fix lint: no uses "__", usa un nombre normal aunque no se use
                separatorBuilder: (_, i) => const SizedBox(width: 8),
                itemCount: _subs.length,
              ),
            ),
          ),

          // Contenido
          SliverToBoxAdapter(
            child: BlocBuilder<CategoryCubit, CategoryState>(
              builder: (_, st) {
                if (st is CategoryLoading) {
                  return const Padding(
                    padding: EdgeInsets.all(24),
                    child: Center(child: CircularProgressIndicator()),
                  );
                }
                if (st is CategoryError) {
                  return Padding(
                    padding: const EdgeInsets.all(24),
                    child: Center(child: Text(st.message)),
                  );
                }
                if (st is! CategoryLoaded) {
                  return const SizedBox.shrink();
                }

                final List<ProductMini> items = st.items;
                if (items.isEmpty) {
                  return const Padding(
                    padding: EdgeInsets.all(24),
                    child: Center(child: Text('Pronto tendremos productos aquÃ­.')),
                  );
                }

                return Padding(
                  padding: const EdgeInsets.fromLTRB(12, 8, 12, 16),
                  child: GridView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 2,
                      childAspectRatio: .75,
                      crossAxisSpacing: 10,
                      mainAxisSpacing: 10,
                    ),
                    itemCount: items.length,
                    itemBuilder: (context, i) =>
                        ProductCardOfficial(item: items[i]),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

--- END FILE: modules/features/catalog/presentation/pages/category_page.dart ---

-- FILE: modules/features/catalog/presentation/pages/product_detail_page.dart --
// modules/features/catalog/presentation/pages/product_detail_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../cart/presentation/widgets/cart_icon_button.dart';
import '../../../cart/presentation/blocs/cart_cubit.dart';
import '../../../cart/domain/entities/cart_item.dart';
import '../../../cart/cart_routes.dart';
import '../blocs/catalog_cubit.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../../../core/config/feature_flags.dart';
import '../../../../core/dev/dev_placeholders.dart';
import '../../../../core/widgets/images/safe_network_image.dart';
import '../widgets/product/variant_chips.dart';
import '../../../../core/widgets/inputs/quantity_stepper.dart';

class ProductDetailPage extends StatefulWidget {
  final String productId;
  const ProductDetailPage({super.key, required this.productId});

  @override
  State<ProductDetailPage> createState() => _ProductDetailPageState();
}

class _ProductDetailPageState extends State<ProductDetailPage> {
  String? _variantId;
  double _unitPrice = 0;
  int _minQty = 1;
  int _qty = 1;
  bool _adding = false;

  void _selectVariant(Variant v) {
    setState(() {
      _variantId = v.id;
      _unitPrice = v.price;
      _qty = _minQty;
    });
  }

  Future<void> _addToCart({
    required String productId,
    required String productName,
  }) async {
    if (_variantId == null) return;
    setState(() => _adding = true);

    context.read<CartCubit>().add(
          CartItem(
            productId: productId,
            productName: productName,
            presentationId: _variantId!,
            presentationName: 'Variante',
            unitPrice: _unitPrice,
            minQty: _minQty,
            qty: _qty,
          ),
        );

    await Future<void>.delayed(const Duration(milliseconds: 220));
    if (!mounted) return;
    setState(() => _adding = false);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Agregado al carrito'),
        action: SnackBarAction(
          label: 'Ver carrito',
          onPressed: () => Navigator.pushNamed(context, CartRoutes.cart),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Detalle'),
        actions: const [CartIconButton()],
      ),
      body: BlocBuilder<CatalogCubit, CatalogState>(
        builder: (context, state) {
          if (state is CatalogLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          if (state is CatalogError) {
            return Center(child: Text(state.message));
          }
          if (state is! CatalogLoaded) return const SizedBox();

          final p = state.product;
          var list = state.presentations;
          if (FeatureFlags.useDevPlaceholdersInUI && list.isEmpty) {
            list = DevPlaceholders.presentations();
          }

          final variants = list
              .map((e) => Variant(
                    id: e.id,
                    name: e.name,
                    price: e.unitPrice,
                    inStock: true,
                  ))
              .toList();

          if (_variantId == null && variants.isNotEmpty) {
            _variantId = variants.first.id;
            _unitPrice = variants.first.price;
            _minQty = list.first.minQty;
            _qty = _minQty;
          }

          final heroTag = 'prod:${p.id}';
          final total = _unitPrice * _qty;

          return Stack(
            children: [
              ListView(
                padding: const EdgeInsets.only(bottom: 120),
                children: [
                  AspectRatio(
                    aspectRatio: 1.2,
                    child: ClipRRect(
                      borderRadius: const BorderRadius.vertical(
                        bottom: Radius.circular(16),
                      ),
                      child: Hero(
                        tag: heroTag,
                        child: p.imageUrl == null
                            ? Container(
                                color: Colors.grey.shade200,
                                child: const Icon(
                                  Icons.fastfood_rounded,
                                  size: 48,
                                ),
                              )
                            : SafeNetworkImage(
                                url: p.imageUrl!,
                                fit: BoxFit.cover,
                              ),
                      ),
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
                    child: Text(
                      p.name,
                      style: const TextStyle(
                        fontSize: 22,
                        fontWeight: FontWeight.w800,
                      ),
                    ),
                  ),
                  if ((p.description ?? '').isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 4, 16, 16),
                      child: Text(
                        p.description!,
                        style: const TextStyle(fontSize: 14, height: 1.3),
                      ),
                    ),
                  if (variants.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 0, 16, 4),
                      child: VariantChips(
                        variants: variants,
                        selectedId: _variantId,
                        onSelect: _selectVariant,
                      ),
                    ),
                  const SizedBox(height: 8),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: QuantityStepper(
                      qty: _qty,
                      minQty: _minQty,
                      onDec: () =>
                          setState(() => _qty = (_qty - 1).clamp(_minQty, 999)),
                      onInc: () => setState(() => _qty += 1),
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 12),
                    child: Text(
                      'Combina con',
                      style: TextStyle(
                        fontWeight: FontWeight.w900,
                        // Reemplazo de deprecated: withOpacity -> withValues
                        color: Colors.black.withValues(alpha: 0.78),
                      ),
                    ),
                  ),
                  SizedBox(
                    height: 142,
                    child: ListView.separated(
                      scrollDirection: Axis.horizontal,
                      padding: const EdgeInsets.symmetric(horizontal: 12),
                      itemCount: 6,
                      separatorBuilder: (_, i) => const SizedBox(width: 8),
                      itemBuilder: (_, i) => Container(
                        width: 120,
                        decoration: BoxDecoration(
                          color: Colors.grey.shade100,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: Colors.black12),
                        ),
                        child: const Center(child: Text('Bebida/Salsa')),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                ],
              ),
              Align(
                alignment: Alignment.bottomCenter,
                child: SafeArea(
                  child: Container(
                    width: double.infinity,
                    margin: const EdgeInsets.fromLTRB(12, 0, 12, 12),
                    padding:
                        const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(16),
                      boxShadow: const [
                        BoxShadow(
                          blurRadius: 16,
                          color: Color(0x14000000),
                          offset: Offset(0, -2),
                        )
                      ],
                    ),
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            variants.isNotEmpty
                                ? '\$${total.toStringAsFixed(2)}'
                                : 'Sin precio',
                            style: const TextStyle(
                              fontWeight: FontWeight.w900,
                              fontSize: 16,
                            ),
                          ),
                        ),
                        PrimaryButton(
                          text: _adding
                              ? 'AÃ±adiendoâ¦'
                              : (variants.isNotEmpty
                                  ? 'AÃ±adir \$${total.toStringAsFixed(2)}'
                                  : 'AÃ±adir'),
                          isLoading: _adding,
                          onPressed: variants.isEmpty || _variantId == null
                              ? null
                              : () => _addToCart(
                                    productId: p.id,
                                    productName: p.name,
                                  ),
                          fullWidth: false,
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/pages/product_detail_page.dart 

-- FILE: modules/features/catalog/presentation/pages/vitrina_profile_page.dart -
// modules/features/catalog/presentation/pages/vitrina_profile_page.dart
import 'package:flutter/material.dart';
import '../widgets/product/product_card_vitrina.dart';

class VitrinaProfilePage extends StatelessWidget {
  final VitrinaItem item;
  const VitrinaProfilePage({super.key, required this.item});

  @override
  Widget build(BuildContext context) {
    final list = List.generate(
      6,
      (i) => VitrinaItem(id: '${item.id}_$i', name: '${item.name} #$i'),
    );

    return Scaffold(
      appBar: AppBar(title: Text(item.name)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Text('Barrio: ${item.barrio ?? 's/d'}'),
          const SizedBox(height: 8),
          const Text('DescripciÃ³n de la emprendedora...', style: TextStyle(height: 1.3)),
          const SizedBox(height: 12),
          const Text('Sus productos', style: TextStyle(fontWeight: FontWeight.w900, fontSize: 16)),
          const SizedBox(height: 8),
          Wrap(
            spacing: 10,
            runSpacing: 10,
            children: list
                .map((e) => SizedBox(width: 160, child: ProductCardVitrina(item: e)))
                .toList(),
          ),
          const SizedBox(height: 16),
          OutlinedButton.icon(
            icon: const Icon(Icons.chat),
            label: const Text('Contactar fuera de la app'),
            onPressed: () {},
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/pages/vitrina_profile_page.dart 

----- FILE: modules/features/catalog/presentation/pages/vitrinas_page.dart -----
// modules/features/catalog/presentation/pages/vitrinas_page.dart
import 'package:flutter/material.dart';
import '../widgets/product/product_card_vitrina.dart';
import 'vitrina_profile_page.dart';

class VitrinasPage extends StatelessWidget {
  const VitrinasPage({super.key});

  @override
  Widget build(BuildContext context) {
    final items = <VitrinaItem>[
      const VitrinaItem(id: 'v1', name: 'Empanada artesanal', barrio: 'Centro'),
      const VitrinaItem(id: 'v2', name: 'Tamal casero', barrio: 'Norte'),
    ];

    return Scaffold(
      appBar: AppBar(title: const Text('Vitrina de Emprendedoras')),
      body: ListView.separated(
        padding: const EdgeInsets.all(12),
        itemCount: items.length,
        separatorBuilder: (_, i) => const SizedBox(height: 10),
        itemBuilder: (_, i) {
          final it = items[i];
          return ProductCardVitrina(
            item: it,
            onOpenProfile: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => VitrinaProfilePage(item: it)),
            ),
          );
        },
      ),
    );
  }
}

--- END FILE: modules/features/catalog/presentation/pages/vitrinas_page.dart ---

Dentro de /widgets:

--- FILE: modules/features/catalog/presentation/widgets/editorial_banner.dart --
// modules/features/catalog/presentation/widgets/editorial_banner.dart
import 'package:flutter/material.dart';

class EditorialBanner extends StatelessWidget {
  final String title;
  final String subtitle;
  final List<Color>? gradient;
  final String? imageUrl;
  final VoidCallback? onPressed;

  const EditorialBanner({
    super.key,
    required this.title,
    required this.subtitle,
    this.gradient,
    this.imageUrl,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    final hasCTA = onPressed != null;

    return Container(
      height: 120,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16),
        gradient:
            gradient != null
                ? LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: gradient!,
                )
                : null,
        color: gradient == null ? Colors.grey.shade200 : null,
        boxShadow: const [
          BoxShadow(
            blurRadius: 16,
            color: Color(0x11000000),
            offset: Offset(0, 4),
          ),
        ],
      ),
      child: Stack(
        children: [
          if (imageUrl != null)
            Positioned.fill(
              child: ClipRRect(
                borderRadius: BorderRadius.circular(16),
                child: Image.network(imageUrl!, fit: BoxFit.cover),
              ),
            ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: Align(
              alignment: Alignment.centerLeft,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    title,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w800,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    subtitle,
                    style: const TextStyle(
                      color: Colors.white,
                      height: 1.2,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
          ),
          if (hasCTA)
            Positioned(
              right: 12,
              bottom: 12,
              child: FilledButton(
                onPressed: onPressed,
                child: const Text('Ver mÃ¡s'),
              ),
            ),
        ],
      ),
    );
  }
}

- END FILE: modules/features/catalog/presentation/widgets/editorial_banner.dart 

Dentro de /carousels:

 FILE: modules/features/catalog/presentation/widgets/carousels/section_carousel.dart 
// modules/features/catalog/presentation/widgets/carousels/section_carousel.dart
import 'package:flutter/material.dart';

typedef ItemBuilder<T> = Widget Function(BuildContext context, T item);

class SectionCarousel<T> extends StatelessWidget {
  final String title;
  final List<T> items;
  final ItemBuilder<T> itemBuilder;
  final VoidCallback? onShowAll;

  /// Si `true`, cuando no hay items se renderiza la estructura con placeholders
  /// (cuadros grises) y el botÃ³n "Ver todos" deshabilitado.
  final bool showWhenEmpty;
  final int placeholderCount;

  const SectionCarousel({
    super.key,
    required this.title,
    required this.items,
    required this.itemBuilder,
    this.onShowAll,
    this.showWhenEmpty = false,
    this.placeholderCount = 4,
  });

  @override
  Widget build(BuildContext context) {
    final hasItems = items.isNotEmpty;
    if (!hasItems && !showWhenEmpty) return const SizedBox.shrink();

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 10, 16, 6),
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    title,
                    style: const TextStyle(
                      fontWeight: FontWeight.w900,
                      fontSize: 18,
                    ),
                  ),
                ),
                if (onShowAll != null)
                  TextButton(
                    onPressed: hasItems ? onShowAll : null, // deshabilitado si vacÃ­o
                    child: const Text('Ver todos'),
                  ),
              ],
            ),
          ),
          // Lista
          SizedBox(
            height: 230,
            child: ListView.separated(
              padding: const EdgeInsets.symmetric(horizontal: 12),
              scrollDirection: Axis.horizontal,
              itemCount: hasItems ? items.length : placeholderCount,
              separatorBuilder: (_, _) => const SizedBox(width: 10),
              itemBuilder: (context, i) {
                if (hasItems) {
                  return SizedBox(width: 160, child: itemBuilder(context, items[i]));
                }
                return Container(
                  width: 160,
                  decoration: BoxDecoration(
                    color: Colors.black12,
                    borderRadius: BorderRadius.circular(12),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/carousels/section_carousel.dart 

Dentro de /categories:

 FILE: modules/features/catalog/presentation/widgets/categories/all_categories_sheet.dart 
// modules/features/catalog/presentation/widgets/categories/all_categories_sheet.dart
import 'package:flutter/material.dart';
import '../../../domain/entities/category.dart';

class AllCategoriesSheet extends StatelessWidget {
  final List<Category> categories;
  const AllCategoriesSheet({super.key, required this.categories});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(12, 8, 12, 16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              'Todas las categorÃ­as',
              style: TextStyle(fontWeight: FontWeight.w900, fontSize: 18),
            ),
            const SizedBox(height: 10),
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: categories.length,
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                childAspectRatio: .9,
                crossAxisSpacing: 8,
                mainAxisSpacing: 8,
              ),
              itemBuilder: (_, i) {
                final c = categories[i];
                return InkWell(
                  onTap: () => Navigator.pop(context, c),
                  borderRadius: BorderRadius.circular(12),
                  child: Ink(
                    decoration: BoxDecoration(
                      color: Colors.grey.shade100,
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(color: Colors.black12),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(_iconFromKey(c.iconKey)),
                        const SizedBox(height: 8),
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 6),
                          child: Text(
                            c.name,
                            textAlign: TextAlign.center,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }

  IconData _iconFromKey(String? key) {
    switch (key) {
      case 'fastfood':
        return Icons.fastfood;
      case 'lunch_dining':
        return Icons.lunch_dining;
      case 'local_cafe':
        return Icons.local_cafe;
      case 'bakery_dining':
        return Icons.bakery_dining;
      case 'icecream':
        return Icons.icecream;
      default:
        return Icons.category;
    }
  }
}

 END FILE: modules/features/catalog/presentation/widgets/categories/all_categories_sheet.dart 

 FILE: modules/features/catalog/presentation/widgets/categories/category_carousel.dart 
import 'package:flutter/material.dart';

import '../../../domain/entities/category.dart';

typedef CategoryItemBuilder =
    Widget Function(
      BuildContext context,
      Category category,
      bool selected,
      VoidCallback onTap,
    );

typedef CategoryPlaceholderBuilder =
    Widget Function(BuildContext context, int index);

class CategoryCarousel extends StatelessWidget {
  final List<Category> categories;
  final String? selectedCategoryId;
  final ValueChanged<String?>? onCategorySelected;
  final CategoryItemBuilder itemBuilder;
  final Widget? trailing;
  final double spacing;
  final double? height;
  final int? maxItems;
  final bool allowClearSelection;
  final CategoryPlaceholderBuilder? placeholderBuilder;
  final int placeholderCount;

  const CategoryCarousel({
    super.key,
    required this.categories,
    required this.itemBuilder,
    this.selectedCategoryId,
    this.onCategorySelected,
    this.trailing,
    this.spacing = 8,
    this.height,
    this.maxItems,
    this.allowClearSelection = false,
    this.placeholderBuilder,
    this.placeholderCount = 0,
  });

  @override
  Widget build(BuildContext context) {
    final visibleCategories =
        maxItems == null
            ? categories
            : categories.take(maxItems!).toList(growable: false);

    final children = <Widget>[];

    if (visibleCategories.isEmpty && placeholderBuilder != null) {
      for (var i = 0; i < placeholderCount; i++) {
        children.add(placeholderBuilder!(context, i));
        if (i != placeholderCount - 1 || trailing != null) {
          children.add(SizedBox(width: spacing));
        }
      }
    } else {
      for (var i = 0; i < visibleCategories.length; i++) {
        final category = visibleCategories[i];
        final selected = selectedCategoryId == category.id;
        children.add(
          itemBuilder(context, category, selected, () {
            final handler = onCategorySelected;
            if (handler == null) return;
            if (allowClearSelection && selected) {
              handler(null);
            } else {
              handler(category.id);
            }
          }),
        );
        if (i != visibleCategories.length - 1 || trailing != null) {
          children.add(SizedBox(width: spacing));
        }
      }
    }

    if (trailing != null) {
      children.add(trailing!);
    }

    final row = Row(children: children);
    final content =
        height == null
            ? row
            : SizedBox(
              height: height,
              child: Align(alignment: Alignment.centerLeft, child: row),
            );

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 4),
      child: content,
    );
  }
}

class CategoryChipCarousel extends StatelessWidget {
  final List<Category> categories;
  final String? selectedCategoryId;
  final ValueChanged<String?> onCategorySelected;
  final Widget? trailing;
  final bool allowClearSelection;

  const CategoryChipCarousel({
    super.key,
    required this.categories,
    required this.selectedCategoryId,
    required this.onCategorySelected,
    this.trailing,
    this.allowClearSelection = true,
  });

  @override
  Widget build(BuildContext context) {
    return CategoryCarousel(
      categories: categories,
      selectedCategoryId: selectedCategoryId,
      onCategorySelected: onCategorySelected,
      allowClearSelection: allowClearSelection,
      trailing: trailing,
      itemBuilder: (context, category, selected, onTap) {
        return _CategoryChip(
          label: category.name,
          iconKey: category.iconKey,
          selected: selected,
          onTap: onTap,
        );
      },
    );
  }
}

class _CategoryChip extends StatelessWidget {
  final String label;
  final String? iconKey;
  final bool selected;
  final VoidCallback onTap;

  const _CategoryChip({
    required this.label,
    required this.iconKey,
    required this.selected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = theme.colorScheme.primary;
    final background =
        selected ? color.withValues(alpha: 0.15) : theme.cardColor;
    final borderColor =
        selected ? color : theme.dividerColor.withValues(alpha: 0.4);
    final textColor =
        selected ? color : theme.textTheme.bodyMedium?.color ?? Colors.black87;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(999),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(999),
          color: background,
          border: Border.all(color: borderColor),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircleAvatar(
              radius: 12,
              backgroundColor: borderColor.withValues(alpha: 0.2),
              child: Icon(_iconFromKey(iconKey), size: 14, color: textColor),
            ),
            const SizedBox(width: 8),
            Text(
              label,
              style: TextStyle(color: textColor, fontWeight: FontWeight.w600),
            ),
          ],
        ),
      ),
    );
  }

  IconData _iconFromKey(String? key) {
    switch (key) {
      case 'fastfood':
        return Icons.fastfood;
      case 'lunch_dining':
        return Icons.lunch_dining;
      case 'local_cafe':
        return Icons.local_cafe;
      case 'bakery_dining':
        return Icons.bakery_dining;
      case 'icecream':
        return Icons.icecream;
      default:
        return Icons.category;
    }
  }
}

 END FILE: modules/features/catalog/presentation/widgets/categories/category_carousel.dart 

 FILE: modules/features/catalog/presentation/widgets/categories/category_grid.dart 
// modules/features/catalog/presentation/widgets/categories/category_grid.dart
import 'package:flutter/material.dart';
import '../../../domain/entities/category.dart';

class CategoryGrid extends StatelessWidget {
  final List<Category> categories;
  final void Function(Category)? onTap;

  /// Si `true`, con lista vacÃ­a dibuja una grilla de placeholders.
  final bool showWhenEmpty;
  final int placeholderCount;

  const CategoryGrid({
    super.key,
    required this.categories,
    required this.onTap,
    this.showWhenEmpty = false,
    this.placeholderCount = 6,
  });

  @override
  Widget build(BuildContext context) {
    final hasData = categories.isNotEmpty;
    if (!hasData && !showWhenEmpty) return const SizedBox.shrink();

    final count = hasData ? categories.length : placeholderCount;

    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: count,
      padding: const EdgeInsets.only(bottom: 8),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        mainAxisExtent: 98,
        crossAxisSpacing: 10,
        mainAxisSpacing: 10,
      ),
      itemBuilder: (_, i) {
        if (!hasData) {
          return Container(
            decoration: BoxDecoration(
              color: Colors.black12,
              borderRadius: BorderRadius.circular(12),
            ),
          );
        }

        final c = categories[i];
        return InkWell(
          onTap: onTap == null ? null : () => onTap!(c),
          borderRadius: BorderRadius.circular(12),
          child: Ink(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.black.withAlpha(20)),
              boxShadow: const [
                BoxShadow(
                  blurRadius: 8,
                  color: Color(0x0F000000),
                  offset: Offset(0, 2),
                ),
              ],
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(_iconFromKey(c.iconKey), size: 26),
                const SizedBox(height: 8),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Text(
                    c.name,
                    maxLines: 2,
                    textAlign: TextAlign.center,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(fontWeight: FontWeight.w700),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  IconData _iconFromKey(String? key) {
    switch (key) {
      case 'fastfood':
        return Icons.fastfood;
      case 'lunch_dining':
        return Icons.lunch_dining;
      case 'local_cafe':
        return Icons.local_cafe;
      case 'bakery_dining':
        return Icons.bakery_dining;
      case 'icecream':
        return Icons.icecream;
      default:
        return Icons.category;
    }
  }
}

 END FILE: modules/features/catalog/presentation/widgets/categories/category_grid.dart 

 FILE: modules/features/catalog/presentation/widgets/categories/highlighted_categories_row.dart 
// modules/features/catalog/presentation/widgets/categories/highlighted_categories_row.dart
import 'package:flutter/material.dart';

import '../../../../../core/config/app_theme.dart';
import '../../../../../core/widgets/images/safe_network_image.dart';
import '../../../domain/entities/category.dart';
import 'category_carousel.dart';

class HighlightedCategoriesRow extends StatelessWidget {
  final List<Category> categories;
  final void Function(Category category)? onTapCategory;
  final VoidCallback? onShowAll;
  final bool showWhenEmpty;
  final int maxVisible;

  const HighlightedCategoriesRow({
    super.key,
    required this.categories,
    this.onTapCategory,
    this.onShowAll,
    this.showWhenEmpty = false,
    this.maxVisible = 5,
  });

  @override
  Widget build(BuildContext context) {
    final hasData = categories.isNotEmpty;
    if (!hasData && !showWhenEmpty) return const SizedBox.shrink();

    final limit = maxVisible < 1 ? 1 : maxVisible;
    final visible =
        hasData
            ? categories.take(limit).toList()
            : <Category>[];

    return CategoryCarousel(
      categories: visible,
      selectedCategoryId: null,
      onCategorySelected:
          onTapCategory == null
              ? null
              : (categoryId) {
                if (categoryId == null) return;
                final found = _findById(categories, categoryId) ??
                    _findById(visible, categoryId) ??
                    (visible.isNotEmpty ? visible.first : null) ??
                    (categories.isNotEmpty ? categories.first : null);
                if (found == null) return;
                onTapCategory!(found);
              },
      itemBuilder:
          (context, category, selected, onTap) => SizedBox(
            width: 96,
            child: _CategoryCard(category: category, onTap: onTap),
          ),
      trailing: SizedBox(
        width: 96,
        child: _SeeAllCard(
          enabled: hasData && onShowAll != null,
          onTap: onShowAll,
        ),
      ),
      height: 110,
      spacing: 8,
      maxItems: limit,
      placeholderBuilder:
          showWhenEmpty
              ? (context, _) => const SizedBox(width: 96, child: _GhostCard())
              : null,
      placeholderCount: showWhenEmpty ? limit : 0,
      allowClearSelection: false,
    );
  }
}

class _GhostCard extends StatelessWidget {
  const _GhostCard();

  @override
  Widget build(BuildContext context) {
    return Ink(
      width: 96,
      decoration: BoxDecoration(
        color: Colors.black12,
        borderRadius: BorderRadius.circular(14),
      ),
    );
  }
}

class _CategoryCard extends StatelessWidget {
  final Category category;
  final VoidCallback? onTap;
  const _CategoryCard({required this.category, this.onTap});

  @override
  Widget build(BuildContext context) {
    final hasImage =
        category.imageUrl != null && category.imageUrl!.trim().isNotEmpty;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(14),
      child: Ink(
        width: 96,
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.black12),
          boxShadow: const [
            BoxShadow(blurRadius: 10, color: Color(0x12000000)),
          ],
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: 54,
              height: 54,
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(12),
              ),
              clipBehavior: Clip.antiAlias,
              child:
                  hasImage
                      ? SafeNetworkImage(
                        url: category.imageUrl!,
                        fit: BoxFit.cover,
                      )
                      : Icon(
                        _iconFromKey(category.iconKey),
                        color: AppTheme.deepBlue,
                      ),
            ),
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: Text(
                category.name,
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  fontWeight: FontWeight.w800,
                  fontSize: 12,
                  color: AppTheme.deepBlue,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _SeeAllCard extends StatelessWidget {
  final VoidCallback? onTap;
  final bool enabled;
  const _SeeAllCard({required this.enabled, this.onTap});

  @override
  Widget build(BuildContext context) {
    final bg = enabled ? AppTheme.white : Colors.grey.shade200;
    final border =
        enabled
            ? AppTheme.cyan.withValues(alpha: .35)
            : Colors.grey.withValues(alpha: .35);
    final fg = enabled ? AppTheme.cyan : Colors.grey;

    return InkWell(
      onTap: enabled ? onTap : null,
      borderRadius: BorderRadius.circular(14),
      child: Ink(
        width: 96,
        decoration: BoxDecoration(
          color: bg,
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: border),
          boxShadow: const [
            BoxShadow(blurRadius: 10, color: Color(0x12000000)),
          ],
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.grid_view_rounded, color: fg),
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: Text(
                'Ver todas ->',
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: TextStyle(
                  fontWeight: FontWeight.w800,
                  fontSize: 12,
                  color: fg,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

IconData _iconFromKey(String? key) {
  switch (key) {
    case 'fastfood':
      return Icons.fastfood;
    case 'lunch_dining':
      return Icons.lunch_dining;
    case 'local_cafe':
      return Icons.local_cafe;
    case 'bakery_dining':
      return Icons.bakery_dining;
    case 'icecream':
      return Icons.icecream;
    default:
      return Icons.category;
  }
}

Category? _findById(List<Category> list, String id) {
  for (final c in list) {
    if (c.id == id) return c;
  }
  return null;
}

 END FILE: modules/features/catalog/presentation/widgets/categories/highlighted_categories_row.dart 

Dentro de /filters:

-- FILE: modules/features/catalog/presentation/widgets/filters/filter_row.dart -
// modules/features/catalog/presentation/widgets/filters/filter_row.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';

class FilterRow extends StatefulWidget {
  const FilterRow({super.key});

  @override
  State<FilterRow> createState() => _FilterRowState();
}

class _FilterRowState extends State<FilterRow> {
  bool pickup = false;
  bool discounts = false;
  String sort = 'Relevancia';

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 40,
      child: ListView(
        scrollDirection: Axis.horizontal,
        padding: const EdgeInsets.symmetric(horizontal: 4),
        children: [
          _ChipButton(
            icon: Icons.filter_list_rounded,
            label: 'Filter',
            onTap: () {},
          ),
          const SizedBox(width: 8),
          _SortDropdown(
            value: sort,
            onChanged: (v) => setState(() => sort = v),
          ),
          const SizedBox(width: 8),
          _ToggleChip(
            label: 'Pickup',
            active: pickup,
            onTap: () => setState(() => pickup = !pickup),
          ),
          const SizedBox(width: 8),
          _ToggleChip(
            label: 'Discounts',
            active: discounts,
            onTap: () => setState(() => discounts = !discounts),
          ),
        ],
      ),
    );
  }
}

class _ChipButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  const _ChipButton({
    required this.icon,
    required this.label,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      borderRadius: BorderRadius.circular(20),
      onTap: onTap,
      child: Ink(
        padding: const EdgeInsets.symmetric(horizontal: 12),
        decoration: BoxDecoration(
          color: Colors.white,
          border: Border.all(color: Colors.black12),
          borderRadius: BorderRadius.circular(20),
          boxShadow: const [BoxShadow(blurRadius: 8, color: Color(0x0F000000))],
        ),
        child: Row(
          children: [
            Icon(icon, size: 18, color: AppTheme.deepBlue),
            const SizedBox(width: 6),
            Text(
              label,
              style: const TextStyle(
                fontWeight: FontWeight.w700,
                color: Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ToggleChip extends StatelessWidget {
  final String label;
  final bool active;
  final VoidCallback onTap;

  const _ToggleChip({
    required this.label,
    required this.active,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final bg = active ? AppTheme.cyan : Colors.white;
    final fg = active ? Colors.white : AppTheme.deepBlue;
    return InkWell(
      borderRadius: BorderRadius.circular(20),
      onTap: onTap,
      child: Ink(
        padding: const EdgeInsets.symmetric(horizontal: 12),
        decoration: BoxDecoration(
          color: bg,
          border: Border.all(color: Colors.black12),
          borderRadius: BorderRadius.circular(20),
          boxShadow: const [BoxShadow(blurRadius: 8, color: Color(0x0F000000))],
        ),
        child: Center(
          child: Text(
            label,
            style: TextStyle(
              fontWeight: FontWeight.w700,
              color: fg,
            ),
          ),
        ),
      ),
    );
  }
}

class _SortDropdown extends StatelessWidget {
  final String value;
  final ValueChanged<String> onChanged;

  const _SortDropdown({
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final items = const ['Relevancia', 'Precio', 'Popularidad'];
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border.all(color: Colors.black12),
        borderRadius: BorderRadius.circular(20),
        boxShadow: const [BoxShadow(blurRadius: 8, color: Color(0x0F000000))],
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          items: items.map((e) {
            return DropdownMenuItem<String>(
              value: e,
              child: Text(
                e,
                style: const TextStyle(fontWeight: FontWeight.w700),
              ),
            );
          }).toList(),
          onChanged: (v) {
            if (v != null) onChanged(v);
          },
          icon: const Icon(Icons.keyboard_arrow_down_rounded),
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/filters/filter_row.dart 

Dentro de /header:

 FILE: modules/features/catalog/presentation/widgets/header/mode_selector_header.dart 
// modules/features/catalog/presentation/widgets/header/mode_selector_header.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import '../../../domain/value_objects/catalog_mode.dart';

class ModeSelectorHeader extends StatelessWidget {
  final CatalogMode mode;
  final ValueChanged<CatalogMode> onModeChanged;
  final VoidCallback onSearchTap;
  final Widget? cart;

  const ModeSelectorHeader({
    super.key,
    required this.mode,
    required this.onModeChanged,
    required this.onSearchTap,
    this.cart,
  });

  @override
  Widget build(BuildContext context) {
    // IMPORTANTE:
    // - AppBar.actions impone ancho no acotado y mainAxisSize=min en su Row padre.
    // - No usar Spacer/Expanded dentro de este hijo; mantenemos ancho compacto.
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        _ModePill(
          text: 'Oficial',
          selected: mode == CatalogMode.oficial,
          onTap: () => onModeChanged(CatalogMode.oficial),
        ),
        const SizedBox(width: 6),
        _ModePill(
          text: 'Vitrina',
          selected: mode == CatalogMode.vitrina,
          onTap: () => onModeChanged(CatalogMode.vitrina),
        ),
        const SizedBox(width: 6),
        IconButton(
          tooltip: 'Buscar',
          onPressed: onSearchTap,
          icon: const Icon(Icons.search),
          color: AppTheme.deepBlue,
        ),
        if (cart != null) cart!,
      ],
    );
  }
}

class _ModePill extends StatelessWidget {
  final String text;
  final bool selected;
  final VoidCallback onTap;

  const _ModePill({
    required this.text,
    required this.selected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: selected ? null : onTap,
      borderRadius: BorderRadius.circular(16),
      child: Ink(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        decoration: BoxDecoration(
          color: selected ? AppTheme.deepBlue : Colors.black12,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Text(
          text,
          style: TextStyle(
            color: selected ? Colors.white : AppTheme.deepBlue,
            fontWeight: FontWeight.w700,
            fontSize: 12,
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/header/mode_selector_header.dart 

Dentro de /product:

 FILE: modules/features/catalog/presentation/widgets/product/product_card_official.dart 
// modules/features/catalog/presentation/widgets/product/product_card_official.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import '../../../../../core/widgets/images/safe_network_image.dart';
import '../../../domain/entities/product_mini.dart';

class ProductCardOfficial extends StatelessWidget {
  final ProductMini item;
  final VoidCallback? onTap;

  const ProductCardOfficial({super.key, required this.item, this.onTap});

  @override
  Widget build(BuildContext context) {
    final heroTag = 'prod:${item.id}';
    return InkWell(
      onTap: onTap ??
          () => Navigator.pushNamed(
                context,
                '/catalog/detail',
                arguments: {'productId': item.id},
              ),
      borderRadius: BorderRadius.circular(16),
      child: Ink(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: const [BoxShadow(blurRadius: 14, color: Color(0x12000000), offset: Offset(0, 4))],
          border: Border.all(color: Colors.black12),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Imagen (60% aprox) + "+" overlay bottom-right
            Expanded(
              child: Stack(
                children: [
                  ClipRRect(
                    borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
                    child: Hero(
                      tag: heroTag,
                      child: item.imageUrl == null
                          ? Container(
                              color: Colors.grey.shade100,
                              child: const Center(child: Icon(Icons.fastfood_rounded)),
                            )
                          : SafeNetworkImage(url: item.imageUrl!, fit: BoxFit.cover),
                    ),
                  ),
                  Positioned(
                    right: 8,
                    bottom: 8,
                    child: _AddButton(
                      onTap: () {
                        // Mantener funcionalidad actual: navegar al detalle
                        Navigator.pushNamed(
                          context,
                          '/catalog/detail',
                          arguments: {'productId': item.id},
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
            // Texto
            Padding(
              padding: const EdgeInsets.fromLTRB(10, 8, 10, 2),
              child: Text(
                item.name,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w800, color: Colors.black87),
              ),
            ),
            if (item.priceFrom != null)
              Padding(
                padding: const EdgeInsets.fromLTRB(10, 0, 10, 10),
                child: Text(
                  '\$${item.priceFrom!.toStringAsFixed(2)}',
                  style: const TextStyle(fontWeight: FontWeight.w900, color: Colors.black87),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class _AddButton extends StatelessWidget {
  final VoidCallback onTap;
  const _AddButton({required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Material(
      color: AppTheme.deepBlue,
      borderRadius: BorderRadius.circular(16),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: SizedBox(
          width: 36,
          height: 36,
          child: const Icon(Icons.add, color: Colors.white, size: 20),
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/product/product_card_official.dart 

 FILE: modules/features/catalog/presentation/widgets/product/product_card_vitrina.dart 
// modules/features/catalog/presentation/widgets/product/product_card_vitrina.dart
import 'package:flutter/material.dart';
import '../../../../../core/widgets/images/safe_network_image.dart';

class VitrinaItem {
  final String id;
  final String name;
  final String? imageUrl;
  final String? barrio;

  const VitrinaItem({
    required this.id,
    required this.name,
    this.imageUrl,
    this.barrio,
  });
}

class ProductCardVitrina extends StatelessWidget {
  final VitrinaItem item;
  final VoidCallback? onOpenProfile;
  const ProductCardVitrina({super.key, required this.item, this.onOpenProfile});

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.white,
      borderRadius: BorderRadius.circular(12),
      child: InkWell(
        onTap: onOpenProfile,
        borderRadius: BorderRadius.circular(12),
        child: Ink(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.black12),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Imagen / avatar de vitrina
              Expanded(
                child: ClipRRect(
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
                  child: item.imageUrl == null || item.imageUrl!.isEmpty
                      ? Container(
                          color: Colors.grey.shade100,
                          alignment: Alignment.center,
                          child: const Icon(Icons.store_mall_directory_rounded, size: 28),
                        )
                      : SafeNetworkImage(url: item.imageUrl!, fit: BoxFit.cover),
                ),
              ),
              // Texto
              Padding(
                padding: const EdgeInsets.fromLTRB(10, 8, 10, 4),
                child: Text(
                  item.name,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(fontWeight: FontWeight.w800),
                ),
              ),
              if ((item.barrio ?? '').isNotEmpty)
                Padding(
                  padding: const EdgeInsets.fromLTRB(10, 0, 10, 10),
                  child: Text(
                    item.barrio!,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(color: Colors.black54, fontSize: 12),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/product/product_card_vitrina.dart 

 FILE: modules/features/catalog/presentation/widgets/product/variant_chips.dart 
// modules/features/catalog/presentation/widgets/product/variant_chips.dart
import 'package:flutter/material.dart';

class Variant {
  final String id;
  final String name;
  final double price;
  final bool inStock;
  const Variant({
    required this.id,
    required this.name,
    required this.price,
    this.inStock = true,
  });
}

class VariantChips extends StatelessWidget {
  final List<Variant> variants;
  final String? selectedId;
  final void Function(Variant) onSelect;

  const VariantChips({
    super.key,
    required this.variants,
    required this.selectedId,
    required this.onSelect,
  });

  @override
  Widget build(BuildContext context) {
    if (variants.isEmpty) return const SizedBox.shrink();
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: variants.map((v) {
          final selected = v.id == selectedId;
          return Padding(
            padding: const EdgeInsets.only(right: 8),
            child: ChoiceChip(
              label: Text(
                v.inStock ? v.name : '${v.name} Â· Agotado',
                style: TextStyle(
                  fontWeight: FontWeight.w700,
                  color: selected ? Colors.white : null,
                ),
              ),
              selected: selected,
              onSelected: v.inStock ? (_) => onSelect(v) : null,
              selectedColor: const Color(0xFF1B2459),
              shape: StadiumBorder(
                side: BorderSide(
                  color: selected ? const Color(0xFF1B2459) : Colors.black12,
                ),
              ),
              backgroundColor: Colors.white,
            ),
          );
        }).toList(),
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/product/variant_chips.dart 

Dentro de /search:

 FILE: modules/features/catalog/presentation/widgets/search/catalog_search_delegate.dart 
// modules/features/catalog/presentation/widgets/search/catalog_search_delegate.dart
import 'package:flutter/material.dart';
import '../../../domain/entities/product_mini.dart';

class CatalogSearchDelegate extends SearchDelegate<ProductMini?> {
  final List<ProductMini> source;
  final void Function(ProductMini item)? onOpen;

  CatalogSearchDelegate({required this.source, this.onOpen});

  List<ProductMini> _filter(String q) {
    final s = q.trim().toLowerCase();
    if (s.isEmpty) return source;
    return source
        .where((e) => e.name.toLowerCase().contains(s))
        .toList(growable: false);
  }

  @override
  List<Widget> buildActions(BuildContext context) => [
    IconButton(onPressed: () => query = '', icon: const Icon(Icons.clear)),
  ];

  @override
  Widget buildLeading(BuildContext context) => IconButton(
    onPressed: () => close(context, null),
    icon: const Icon(Icons.arrow_back),
  );

  @override
  Widget buildResults(BuildContext context) => _buildList(context);
  @override
  Widget buildSuggestions(BuildContext context) => _buildList(context);

  Widget _buildList(BuildContext context) {
    final items = _filter(query);
    if (items.isEmpty) {
      return const Center(child: Text('Sin resultados'));
    }
    return ListView.separated(
      itemCount: items.length,
      separatorBuilder: (_, i) => const Divider(height: 1),
      itemBuilder: (ctx, i) {
        final it = items[i];
        return ListTile(
          title: Text(it.name),
          subtitle:
              it.priceFrom != null
                  ? Text('\$${it.priceFrom!.toStringAsFixed(2)}')
                  : null,
          onTap: () {
            onOpen?.call(it);
            close(context, it);
          },
        );
      },
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/search/catalog_search_delegate.dart 

Dentro de /skeletons:

- FILE: modules/features/catalog/presentation/widgets/skeletons/skeletons.dart -
// modules/features/catalog/presentation/widgets/skeletons/skeletons.dart
import 'package:flutter/material.dart';

class SectionSkeleton extends StatelessWidget {
  const SectionSkeleton({super.key});

  @override
  Widget build(BuildContext context) {
    final base = Colors.black12;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            height: 18,
            width: 160,
            margin: const EdgeInsets.fromLTRB(16, 10, 16, 8),
            decoration: BoxDecoration(
              color: base,
              borderRadius: BorderRadius.circular(6),
            ),
          ),
          SizedBox(
            height: 230,
            child: ListView.separated(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 12),
              itemCount: 4,
              separatorBuilder: (_, i) => const SizedBox(width: 10),
              itemBuilder: (_, i) => Container(
                width: 160,
                decoration: BoxDecoration(
                  color: base,
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

 END FILE: modules/features/catalog/presentation/widgets/skeletons/skeletons.dart 

Dentro de /home:

----------------- FILE: modules/features/home/home_routes.dart -----------------
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'presentation/pages/home_page.dart';

import 'data/datasources/home_featured_remote_datasource.dart';
import 'data/repositories/home_featured_repository_impl.dart';
import 'domain/usecases/get_featured_products.dart';
import 'presentation/blocs/home_featured_cubit.dart';

// Orders summary
import 'data/datasources/orders_summary_remote_datasource.dart';
import 'data/repositories/orders_summary_repository_impl.dart';
import 'domain/usecases/get_recent_orders.dart';
import 'presentation/blocs/orders_summary_cubit.dart';

// Profile DI ð
import '../profile/data/datasources/profile_read_remote_datasource.dart';
import '../profile/data/repositories/profile_read_repository_impl.dart';
import '../profile/domain/usecases/watch_user_stream.dart';
import '../profile/presentation/blocs/profile_overview_cubit.dart';

class HomeRoutes {
  static const String home = '/home';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case home:
        // Featured products
        final featuredDs = HomeFeaturedRemoteDataSource(FirebaseFirestore.instance);
        final featuredRepo = HomeFeaturedRepositoryImpl(featuredDs);
        final getFeaturedUc = GetFeaturedProducts(featuredRepo);

        // Orders summary
        final ordersDs = OrdersSummaryRemoteDataSource(FirebaseFirestore.instance);
        final ordersRepo = OrdersSummaryRepositoryImpl(ordersDs);
        final getRecentOrders = GetRecentOrders(ordersRepo);

        // Profile
        final profileDs = ProfileRemoteDataSource(FirebaseFirestore.instance);
        final profileRepo = ProfileRepositoryImpl(profileDs);
        final watchUserProfile = WatchUserProfile(profileRepo);

        final user = FirebaseAuth.instance.currentUser;
        final String? uid = (user != null && user.isAnonymous == false) ? user.uid : null;

        return MaterialPageRoute(
          builder: (_) => MultiBlocProvider(
            providers: [
              BlocProvider(create: (_) => HomeFeaturedCubit(getFeaturedUc)..load()),
              BlocProvider(create: (_) {
                final c = OrdersSummaryCubit(getRecentOrders);
                c.load(userId: uid); // uid==null -> emite Empty
                return c;
              }),
              // ð Proveedor del ProfileCubit, queda accesible para ProfileTab
              BlocProvider(create: (_) {
                final c = ProfileCubit(watchUserProfile);
                c.watch(uid); // invitado -> ProfileGuest
                return c;
              }),
            ],
            child: const HomePage(),
          ),
        );

      default:
        return MaterialPageRoute(
          builder: (_) => const Scaffold(
            body: Center(child: Text('Ruta Home no definida')),
          ),
        );
    }
  }
}

--------------- END FILE: modules/features/home/home_routes.dart ---------------

Dentro de /data:

Dentro de /datasources:

 FILE: modules/features/home/data/datasources/home_featured_remote_datasource.dart 
import 'dart:math' as math;
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../../../modules/core/config/feature_flags.dart';
import '../../../../../modules/core/dev/dev_placeholders.dart';
import '../models/product_summary_model.dart';

class HomeFeaturedRemoteDataSource {
  final FirebaseFirestore firestore;
  HomeFeaturedRemoteDataSource(this.firestore);

  /// Estrategia:
  /// 1) Intentar leer /home_config/featured.productIds (curado por admin).
  ///    Si PERMISSION_DENIED â ignorar y seguir al fallback.
  ///    Si hay IDs, se respetarÃ¡ su orden.
  ///
  /// 2) Fallback: /products con isActive == true ordenado por popularity desc.
  ///    Esta consulta requiere Ã­ndice compuesto:
  ///    - isActive (ASC)
  ///    - popularity (DESC)
  ///    Si el Ã­ndice aÃºn no existe (FAILED_PRECONDITION), aplica plan B:
  ///    - orderBy(FieldPath.documentId()) para no romper la UI.
  Future<List<ProductSummaryModel>> fetchFeatured({int limit = 8}) async {
    List<String> curatedIds = const [];

    // 1) Leer lista curada (silenciosamente si no hay permisos)
    try {
      final configRef = firestore.collection('home_config').doc('featured');
      final cfg = await configRef.get();
      if (cfg.exists) {
        final Map<String, dynamic> data = cfg.data() ?? <String, dynamic>{};
        curatedIds = (data['productIds'] as List?)?.cast<String>() ?? const [];
      }
    } on FirebaseException catch (e) {
      if (e.code != 'permission-denied') {}
      curatedIds = const [];
    }

    // Si hay lista curada, Ãºsala (mÃ¡x 10 por whereIn) y preserva el orden
    if (curatedIds.isNotEmpty) {
      try {
        final takeCount = math.min(limit, 10);
        final ids = curatedIds.take(takeCount).toList();

        final snap = await firestore
            .collection('products')
            .where(FieldPath.documentId, whereIn: ids)
            .get();

        // Reordenar segÃºn el orden de curatedIds
        final byId = {
          for (final d in snap.docs) d.id: ProductSummaryModel.fromDoc(d)
        };

        final ordered = <ProductSummaryModel>[];
        for (final id in ids) {
          final m = byId[id];
          if (m != null) ordered.add(m);
        }
        if (ordered.isNotEmpty) return ordered;
      } on FirebaseException {
        // Ignorar si falla la lectura de la lista curada
      }
    }

    // 2) Fallback por popularidad (requiere Ã­ndice compuesto)
    try {
      final snap = await firestore
          .collection('products')
          .where('isActive', isEqualTo: true)
          .orderBy('popularity', descending: true)
          .limit(limit)
          .get();

      final list = snap.docs.map((d) => ProductSummaryModel.fromDoc(d)).toList();
      if (list.isNotEmpty) return list;
    } on FirebaseException catch (e) {
      // Plan B: sin Ã­ndice compuesto â ordenar por __name__ (documentId)
      if (e.code == 'failed-precondition') {
        try {
          final snap = await firestore
              .collection('products')
              .where('isActive', isEqualTo: true)
              .orderBy(FieldPath.documentId)
              .limit(limit)
              .get();

          final list = snap.docs.map((d) => ProductSummaryModel.fromDoc(d)).toList();
          if (list.isNotEmpty) return list;
        } catch (_) {}
      }
    } catch (_) {}

    // Placeholders en DEV para que la UI se âveaâ
    if (FeatureFlags.useDevPlaceholdersInUI) {
      return DevPlaceholders.featured()
          .map((e) => ProductSummaryModel(
                id: e.id,
                name: e.name,
                imageUrl: e.imageUrl,
                isPromo: e.isPromo,
              ))
          .toList();
    }
    return const <ProductSummaryModel>[];
  }
}

 END FILE: modules/features/home/data/datasources/home_featured_remote_datasource.dart 

--- FILE: modules/features/home/data/datasources/home_remote_datasource.dart ---
// lib/modules/features/home/data/datasources/home_remote_datasource.dart
import '../models/home_data_model.dart';

class HomeRemoteDataSource {
  Future<List<HomeDataModel>> fetchDashboardItems() async {
    // AquÃ­ tu lÃ³gica real (Firestore, API, etc.)
    // Por ahora devolvemos ejemplos estÃ¡ticos:
    return [
      const HomeDataModel(id: '1', title: 'Pedidos'),
      const HomeDataModel(id: '2', title: 'Perfil'),
    ];
  }
}

- END FILE: modules/features/home/data/datasources/home_remote_datasource.dart -

 FILE: modules/features/home/data/datasources/orders_summary_remote_datasource.dart 
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/order_summary_model.dart';

class OrdersSummaryRemoteDataSource {
  final FirebaseFirestore firestore;
  OrdersSummaryRemoteDataSource(this.firestore);

  Future<List<OrderSummaryModel>> fetchRecent({
    required String userId,
    int limit = 3,
  }) async {
    try {
      final snap = await firestore
          .collection('orders')
          .where('userId', isEqualTo: userId)
          .orderBy('createdAt', descending: true)
          .limit(limit)
          .get();

      return snap.docs
          .map((d) => OrderSummaryModel.fromDoc(d as DocumentSnapshot<Map<String, dynamic>>))
          .toList();
    } on FirebaseException catch (e) {
      // Si falta Ã­ndice compuesto, hacemos un fallback que no lo requiera
      if (e.code == 'failed-precondition') {
        try {
          final snap = await firestore
              .collection('orders')
              .where('userId', isEqualTo: userId)
              .orderBy(FieldPath.documentId, descending: true)
              .limit(limit)
              .get();

          return snap.docs
              .map((d) => OrderSummaryModel.fromDoc(d as DocumentSnapshot<Map<String, dynamic>>))
              .toList();
        } catch (_) {
          return const [];
        }
      }
      return const [];
    } catch (_) {
      return const [];
    }
  }
}

 END FILE: modules/features/home/data/datasources/orders_summary_remote_datasource.dart 

Dentro de /models:

--------- FILE: modules/features/home/data/models/home_data_model.dart ---------
// lib/modules/features/home/data/models/home_data_model.dart
import '../../domain/entities/home_item.dart';

class HomeDataModel extends HomeItem {
  const HomeDataModel({required super.id, required super.title});

  factory HomeDataModel.fromJson(Map<String, dynamic> json) =>
      HomeDataModel(id: json['id'], title: json['title']);
  Map<String, dynamic> toJson() => {'id': id, 'title': title};
}

------- END FILE: modules/features/home/data/models/home_data_model.dart -------

------- FILE: modules/features/home/data/models/order_summary_model.dart -------
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/order_summary.dart';

class OrderSummaryModel extends OrderSummary {
  const OrderSummaryModel({
    required super.id,
    required super.status,
    required super.createdAt,
    required super.total,
  });

  factory OrderSummaryModel.fromDoc(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};
    final ts = data['createdAt'];
    DateTime createdAt;
    if (ts is Timestamp) {
      createdAt = ts.toDate();
    } else if (ts is int) {
      createdAt = DateTime.fromMillisecondsSinceEpoch(ts);
    } else {
      createdAt = DateTime.now();
    }

    return OrderSummaryModel(
      id: doc.id,
      status: (data['status'] ?? 'unknown').toString(),
      createdAt: createdAt,
      total: (data['total'] ?? 0) is num ? (data['total'] as num) : num.tryParse('${data['total']}') ?? 0,
    );
  }
}

----- END FILE: modules/features/home/data/models/order_summary_model.dart -----

------ FILE: modules/features/home/data/models/product_summary_model.dart ------
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/product_summary.dart';

class ProductSummaryModel extends ProductSummary {
  const ProductSummaryModel({
    required super.id,
    required super.name,
    super.imageUrl,
    super.isPromo = false,
  });

  factory ProductSummaryModel.fromDoc(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};
    return ProductSummaryModel(
      id: doc.id,
      name: (data['name'] ?? '').toString(),
      imageUrl: (data['imageUrl'] ?? '').toString().isEmpty ? null : (data['imageUrl'] as String),
      isPromo: (data['isPromo'] ?? false) == true,
    );
  }
}

---- END FILE: modules/features/home/data/models/product_summary_model.dart ----

Dentro de /repositories:

 FILE: modules/features/home/data/repositories/home_featured_repository_impl.dart 
import '../../domain/entities/product_summary.dart';
import '../../domain/repositories/home_featured_repository.dart';
import '../datasources/home_featured_remote_datasource.dart';

class HomeFeaturedRepositoryImpl implements HomeFeaturedRepository {
  final HomeFeaturedRemoteDataSource remote;
  HomeFeaturedRepositoryImpl(this.remote);

  @override
  Future<List<ProductSummary>> getFeaturedProducts({int limit = 8}) async {
    final models = await remote.fetchFeatured(limit: limit);
    return models;
  }
}

 END FILE: modules/features/home/data/repositories/home_featured_repository_impl.dart 

---- FILE: modules/features/home/data/repositories/home_repository_impl.dart ---
// lib/modules/features/home/data/repositories/home_repository_impl.dart
import '../../domain/entities/home_item.dart';
import '../../domain/repositories/home_repository.dart';
import '../datasources/home_remote_datasource.dart';
import '../models/home_data_model.dart';

class HomeRepositoryImpl implements HomeRepository {
  final HomeRemoteDataSource remote;
  HomeRepositoryImpl(this.remote);

  @override
  Future<List<HomeItem>> getHomeItems() async {
    final List<HomeDataModel> models = await remote.fetchDashboardItems();
    return models;
  }
}

-- END FILE: modules/features/home/data/repositories/home_repository_impl.dart -

 FILE: modules/features/home/data/repositories/orders_summary_repository_impl.dart 
import '../../domain/entities/order_summary.dart';
import '../../domain/repositories/orders_summary_repository.dart';
import '../datasources/orders_summary_remote_datasource.dart';

class OrdersSummaryRepositoryImpl implements OrdersSummaryRepository {
  final OrdersSummaryRemoteDataSource remote;
  OrdersSummaryRepositoryImpl(this.remote);

  @override
  Future<List<OrderSummary>> getRecentOrders({
    required String userId,
    int limit = 3,
  }) async {
    final models = await remote.fetchRecent(userId: userId, limit: limit);
    return models;
  }
}

 END FILE: modules/features/home/data/repositories/orders_summary_repository_impl.dart 

Dentro de /domain:

Dentro de /entities:

---------- FILE: modules/features/home/domain/entities/home_item.dart ----------
// lib/modules/features/home/domain/entities/home_item.dart
class HomeItem {
  final String id;
  final String title;
  const HomeItem({required this.id, required this.title});
}

-------- END FILE: modules/features/home/domain/entities/home_item.dart --------

-------- FILE: modules/features/home/domain/entities/order_summary.dart --------
class OrderSummary {
  final String id;
  final String status;      // ej: pending, delivered, canceled
  final DateTime createdAt; // fecha/hora del pedido
  final num total;          // total del pedido

  const OrderSummary({
    required this.id,
    required this.status,
    required this.createdAt,
    required this.total,
  });
}

------ END FILE: modules/features/home/domain/entities/order_summary.dart ------

------- FILE: modules/features/home/domain/entities/product_summary.dart -------
class ProductSummary {
  final String id;
  final String name;
  final String? imageUrl;
  final bool isPromo;

  const ProductSummary({
    required this.id,
    required this.name,
    this.imageUrl,
    this.isPromo = false,
  });
}

----- END FILE: modules/features/home/domain/entities/product_summary.dart -----

Dentro de /repositories:

- FILE: modules/features/home/domain/repositories/home_featured_repository.dart 
import '../entities/product_summary.dart';

abstract class HomeFeaturedRepository {
  /// Retorna una lista de productos para mostrar en el âExplorar por tipoâ.
  /// Puede venir de una lista curada por admin o por popularidad.
  Future<List<ProductSummary>> getFeaturedProducts({int limit});
}

 END FILE: modules/features/home/domain/repositories/home_featured_repository.dart 

----- FILE: modules/features/home/domain/repositories/home_repository.dart -----
// lib/modules/features/home/domain/repositories/home_repository.dart
import '../entities/home_item.dart';

abstract class HomeRepository {
  Future<List<HomeItem>> getHomeItems();
}

--- END FILE: modules/features/home/domain/repositories/home_repository.dart ---

 FILE: modules/features/home/domain/repositories/orders_summary_repository.dart 
import '../entities/order_summary.dart';

abstract class OrdersSummaryRepository {
  Future<List<OrderSummary>> getRecentOrders({
    required String userId,
    int limit,
  });
}

 END FILE: modules/features/home/domain/repositories/orders_summary_repository.dart 

Dentro de /usecases:

---- FILE: modules/features/home/domain/usecases/get_featured_products.dart ----
import '../entities/product_summary.dart';
import '../repositories/home_featured_repository.dart';

class GetFeaturedProducts {
  final HomeFeaturedRepository repository;
  GetFeaturedProducts(this.repository);

  Future<List<ProductSummary>> call({int limit = 8}) {
    return repository.getFeaturedProducts(limit: limit);
  }
}

-- END FILE: modules/features/home/domain/usecases/get_featured_products.dart --

-------- FILE: modules/features/home/domain/usecases/get_home_items.dart -------
// lib/modules/features/home/domain/usecases/get_home_items.dart
import '../entities/home_item.dart';
import '../repositories/home_repository.dart';

class GetHomeItems {
  final HomeRepository repository;
  GetHomeItems(this.repository);

  Future<List<HomeItem>> call() {
    return repository.getHomeItems();
  }
}

------ END FILE: modules/features/home/domain/usecases/get_home_items.dart -----

------ FILE: modules/features/home/domain/usecases/get_recent_orders.dart ------
import '../entities/order_summary.dart';
import '../repositories/orders_summary_repository.dart';

class GetRecentOrders {
  final OrdersSummaryRepository repository;
  GetRecentOrders(this.repository);

  Future<List<OrderSummary>> call({
    required String userId,
    int limit = 3,
  }) {
    return repository.getRecentOrders(userId: userId, limit: limit);
  }
}

---- END FILE: modules/features/home/domain/usecases/get_recent_orders.dart ----

Dentro de /presentation:

Dentro de /blocs:

-------- FILE: modules/features/home/presentation/blocs/home_cubit.dart --------
// lib/modules/features/home/presentation/blocs/home_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/home_item.dart';
import '../../domain/usecases/get_home_items.dart';

abstract class HomeState {}
class HomeInitial extends HomeState {}
class HomeLoading extends HomeState {}
class HomeLoaded extends HomeState {
  final List<HomeItem> items;
  HomeLoaded(this.items);
}
class HomeError extends HomeState {
  final String message;
  HomeError(this.message);
}

class HomeCubit extends Cubit<HomeState> {
  final GetHomeItems getHomeItems;
  HomeCubit(this.getHomeItems) : super(HomeInitial());

  void loadItems() async {
    emit(HomeLoading());
    try {
      final items = await getHomeItems();
      emit(HomeLoaded(items));
    } catch (e) {
      emit(HomeError(e.toString()));
    }
  }
}

------ END FILE: modules/features/home/presentation/blocs/home_cubit.dart ------

---- FILE: modules/features/home/presentation/blocs/home_featured_cubit.dart ---
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/product_summary.dart';
import '../../domain/usecases/get_featured_products.dart';

abstract class HomeFeaturedState {}
class HomeFeaturedLoading extends HomeFeaturedState {}
class HomeFeaturedLoaded extends HomeFeaturedState {
  final List<ProductSummary> items;
  HomeFeaturedLoaded(this.items);
}
class HomeFeaturedEmpty extends HomeFeaturedState {}
class HomeFeaturedError extends HomeFeaturedState {
  final String message;
  HomeFeaturedError(this.message);
}

class HomeFeaturedCubit extends Cubit<HomeFeaturedState> {
  final GetFeaturedProducts getFeaturedProducts;

  HomeFeaturedCubit(this.getFeaturedProducts) : super(HomeFeaturedLoading());

  Future<void> load({int limit = 8}) async {
    if (isClosed) return;
    emit(HomeFeaturedLoading());
    try {
      final list = await getFeaturedProducts(limit: limit);
      if (isClosed) return;
      emit(list.isEmpty ? HomeFeaturedEmpty() : HomeFeaturedLoaded(list));
    } catch (e) {
      if (isClosed) return;
      emit(HomeFeaturedError(e.toString()));
    }
  }
}

-- END FILE: modules/features/home/presentation/blocs/home_featured_cubit.dart -

--- FILE: modules/features/home/presentation/blocs/orders_summary_cubit.dart ---
// lib/modules/features/home/presentation/blocs/orders_summary_cubit.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/order_summary.dart';
import '../../domain/usecases/get_recent_orders.dart';

sealed class OrdersSummaryState {}
class OrdersSummaryInitial extends OrdersSummaryState {}
class OrdersSummaryLoading extends OrdersSummaryState {}
class OrdersSummaryEmpty extends OrdersSummaryState {}
class OrdersSummaryLoaded extends OrdersSummaryState {
  final List<OrderSummary> items;
  OrdersSummaryLoaded(this.items);
}
class OrdersSummaryError extends OrdersSummaryState {
  final String message;
  OrdersSummaryError(this.message);
}

class OrdersSummaryCubit extends Cubit<OrdersSummaryState> {
  final GetRecentOrders _getRecent;
  int _token = 0; // cancela emisiones viejas

  OrdersSummaryCubit(this._getRecent) : super(OrdersSummaryInitial());

  Future<void> load({String? userId, int limit = 3}) async {
    final myToken = ++_token;

    // Invitado/AnÃ³nimo/uid vacÃ­o => no consultar
    if (userId == null || userId.isEmpty) {
      if (!isClosed) emit(OrdersSummaryEmpty());
      return;
    }

    if (!isClosed) emit(OrdersSummaryLoading());
    try {
      final list = await _getRecent(userId: userId, limit: limit);

      // Si durante el await te cerraron/reemplazaron, aborta
      if (isClosed || myToken != _token) return;

      if (list.isEmpty) {
        emit(OrdersSummaryEmpty());
      } else {
        emit(OrdersSummaryLoaded(list));
      }
    } catch (e) {
      if (isClosed || myToken != _token) return;
      emit(OrdersSummaryError(e.toString()));
    }
  }

  @override
  Future<void> close() {
    _token++; // invalida cargas en vuelo
    return super.close();
  }
}

- END FILE: modules/features/home/presentation/blocs/orders_summary_cubit.dart -

Dentro de /pages:

--------- FILE: modules/features/home/presentation/pages/home_page.dart --------
// lib/modules/features/home/presentation/pages/home_page.dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/services/storage/verification_grace_storage.dart';
import '../../../../core/utils/navigation/minimize.dart';
import '../../../../core/widgets/layout/tab_back_guard.dart';
import '../../../auth/auth_routes.dart';
import '../../../../core/utils/validation/validators.dart';
import '../../../auth/presentation/widgets/email_verification_reminder_banner.dart';
import '../widgets/bottom_nav.dart';
import 'tabs/home_tab.dart';

// CatÃ¡logo (host con Provider integrado)
import '../../../catalog/presentation/pages/catalog_home_host.dart';

// Pedidos / Perfil (usa tus pages reales)
import '../../../orders/presentation/pages/orders_tab.dart';
import '../../../profile/presentation/pages/tabs/profile_overview_tab.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key});
  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  int _tabIndex = 0;
  bool _showVerificationReminder = false;
  String? _reminderContact;

  void _goToTab(int index) {
    if (index == _tabIndex) return;
    setState(() => _tabIndex = index);
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _evaluateVerificationReminder());
  }

  Future<void> _evaluateVerificationReminder() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    if (user.emailVerified) return;
    if (!_requiresEmailVerification(user)) return;
    final storage = RepositoryProvider.of<VerificationGraceStorage>(context, listen: false);
    final uid = user.uid;
    if (!storage.hasValidDeadline(uid)) return;
    if (!storage.shouldShowReminder(uid)) return;
    await storage.markReminderShown(uid);
    if (!mounted) return;
    setState(() {
      _showVerificationReminder = true;
      _reminderContact = user.email ?? 'tu cuenta';
    });
  }

  bool _requiresEmailVerification(User user) {
    return requiresEmailVerification(user.email);
  }

  void _dismissReminder() {
    if (!_showVerificationReminder) return;
    setState(() => _showVerificationReminder = false);
  }

  void _goToVerificationScreen() {
    _dismissReminder();
    Navigator.pushNamed(context, AuthRoutes.emailVerification);
  }

  @override
  Widget build(BuildContext context) {
    return TabBackGuard(
      currentIndex: _tabIndex,
      onRequestRoot: () => _goToTab(0),
      onExit: () => AppMinimize.toBackground(),
      child: Scaffold(
        backgroundColor: AppTheme.white,
        body: Stack(
          children: [
            IndexedStack(
              index: _tabIndex,
              children: [
                HomeTab(onOpenCatalog: () => _goToTab(1)),
                const CatalogHomeHost(),
                const OrdersTab(),
                const ProfileTab(),
              ],
            ),
            if (_showVerificationReminder)
              Positioned(
                top: MediaQuery.of(context).padding.top + 12,
                left: 16,
                right: 16,
                child: EmailVerificationReminderBanner(
                  contactLabel: _reminderContact ?? 'tu cuenta',
                  onVerify: _goToVerificationScreen,
                  onDismiss: _dismissReminder,
                ),
              ),
          ],
        ),
        bottomNavigationBar: HomeBottomNav(
          currentIndex: _tabIndex,
          onTap: _goToTab,
        ),
      ),
    );
  }
}

------- END FILE: modules/features/home/presentation/pages/home_page.dart ------

Dentro de /tabs:

------- FILE: modules/features/home/presentation/pages/tabs/home_tab.dart ------
// lib/modules/features/home/presentation/pages/tabs/home_tab.dart
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';
import '../../widgets/home_topbar.dart';
import '../../widgets/greeting_header.dart';
import '../../widgets/featured_products_strip.dart';
import '../../widgets/home_info_grid.dart';
import '../../widgets/orders_summary_card.dart';

class HomeTab extends StatelessWidget {
  final VoidCallback onOpenCatalog;
  const HomeTab({super.key, required this.onOpenCatalog});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: ColoredBox( // usa tu color de fondo
        color: AppTheme.white,
        child: CustomScrollView(
          slivers: [
            // Topbar + saludo (sin const para evitar lookup de compile-time)
            SliverToBoxAdapter(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: const [
                  HomeTopBar(),
                  GreetingHeader(),
                ],
              ),
            ),

            // Explorar por tipo dinÃ¡mico
            SliverToBoxAdapter(
              child: FeaturedProductsStrip(onOpenCatalog: onOpenCatalog),
            ),

            // Tarjetas âPuntos de ventaâ y âConÃ³cenosâ
            SliverToBoxAdapter(
              child: HomeInfoGrid(
                onOpenPickupPoints: () {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Puntos de venta prÃ³ximamente'),
                      backgroundColor: AppTheme.purpleDark,
                      behavior: SnackBarBehavior.floating,
                    ),
                  );
                },
                onOpenAbout: () {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('ConÃ³cenos prÃ³ximamente'),
                      backgroundColor: AppTheme.purpleDark,
                      behavior: SnackBarBehavior.floating,
                    ),
                  );
                },
              ),
            ),

            // Resumen âHistorial de pedidosâ
            SliverToBoxAdapter(
              child: OrdersSummaryCard(
                onSeeAll: () {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Ver todos los pedidos (tab Pedidos)'),
                      backgroundColor: AppTheme.purpleDark,
                      behavior: SnackBarBehavior.floating,
                    ),
                  );
                },
              ),
            ),

            const SliverToBoxAdapter(child: SizedBox(height: 24)),
          ],
        ),
      ),
    );
  }
}

----- END FILE: modules/features/home/presentation/pages/tabs/home_tab.dart ----

Dentro de /widgets:

------- FILE: modules/features/home/presentation/widgets/bottom_nav.dart -------
// lib/modules/features/home/presentation/widgets/bottom_nav.dart
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';

class HomeBottomNav extends StatelessWidget {
  final int currentIndex;
  final ValueChanged<int> onTap;

  const HomeBottomNav({
    super.key,
    required this.currentIndex,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return BottomNavigationBar(
      currentIndex: currentIndex,
      onTap: onTap,
      type: BottomNavigationBarType.fixed,
      backgroundColor: AppTheme.white,
      selectedItemColor: AppTheme.purpleDark,
      unselectedItemColor: Colors.grey,
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.home_outlined),
          activeIcon: Icon(Icons.home),
          label: 'Inicio',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.storefront_outlined),
          activeIcon: Icon(Icons.storefront),
          label: 'CatÃ¡logo',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.receipt_long_outlined),
          activeIcon: Icon(Icons.receipt_long),
          label: 'Pedidos',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.person_outline),
          activeIcon: Icon(Icons.person),
          label: 'Perfil',
        ),
      ],
    );
  }
}

----- END FILE: modules/features/home/presentation/widgets/bottom_nav.dart -----

--- FILE: modules/features/home/presentation/widgets/explore_quick_chips.dart --
import 'package:flutter/material.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../../catalog/domain/entities/category.dart';

class ExploreQuickChips extends StatelessWidget {
  final List<Category> categories;
  final VoidCallback onOpenCatalog;
  final ValueChanged<Category>? onCategoryTap;
  final int maxVisible;

  const ExploreQuickChips({
    super.key,
    this.categories = const [],
    required this.onOpenCatalog,
    this.onCategoryTap,
    this.maxVisible = 6,
  });

  @override
  Widget build(BuildContext context) {
    final visible = categories.take(maxVisible).toList();
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Explorar por tipo',
            style: TextStyle(
              color: AppTheme.black,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 12),
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: AppTheme.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
            ),
            padding: const EdgeInsets.all(10),
            child:
                visible.isEmpty
                    ? _EmptyCategoriesNotice(onOpenCatalog: onOpenCatalog)
                    : Wrap(
                      spacing: 10,
                      runSpacing: 10,
                      children:
                          visible
                              .map(
                                (category) => _SquareChip(
                                  iconKey: category.iconKey,
                                  label: category.name,
                                  onTap: () => onCategoryTap?.call(category),
                                ),
                              )
                              .toList(),
                    ),
          ),
          const SizedBox(height: 10),
          PrimaryButton(
            text: 'Ver catÃ¡logo completo',
            onPressed: onOpenCatalog,
          ),
        ],
      ),
    );
  }
}

class _SquareChip extends StatelessWidget {
  final String? iconKey;
  final String label;
  final VoidCallback onTap;
  const _SquareChip({
    required this.iconKey,
    required this.label,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      borderRadius: BorderRadius.circular(12),
      onTap: onTap,
      child: Container(
        width: 96,
        height: 72,
        decoration: BoxDecoration(
          color: Colors.grey.shade100,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black.withValues(alpha: 0.06)),
        ),
        padding: const EdgeInsets.all(10),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(_iconFromKey(iconKey), color: AppTheme.purpleDark),
            const SizedBox(height: 6),
            Text(
              label,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                color: AppTheme.black,
                fontSize: 12,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

IconData _iconFromKey(String? key) {
  switch (key) {
    case 'fastfood':
      return Icons.fastfood;
    case 'lunch_dining':
      return Icons.lunch_dining;
    case 'local_cafe':
      return Icons.local_cafe;
    case 'bakery_dining':
      return Icons.bakery_dining;
    case 'icecream':
      return Icons.icecream;
    default:
      return Icons.category;
  }
}

class _EmptyCategoriesNotice extends StatelessWidget {
  final VoidCallback onOpenCatalog;
  const _EmptyCategoriesNotice({required this.onOpenCatalog});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        const Icon(Icons.folder_off_outlined, color: AppTheme.purpleDark),
        const SizedBox(width: 12),
        Expanded(
          child: Text(
            'CatÃ¡logo sin categorÃ­as por el momento.',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
        ),
        TextButton(onPressed: onOpenCatalog, child: const Text('Ver todo')),
      ],
    );
  }
}

- END FILE: modules/features/home/presentation/widgets/explore_quick_chips.dart 

- FILE: modules/features/home/presentation/widgets/featured_products_strip.dart 
//lib/modules/features/home/presentation/widgets/featured_products_strip.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/config/app_theme.dart';
import '../../domain/entities/product_summary.dart';
import '../blocs/home_featured_cubit.dart';
import '../../../../core/widgets/actions_buttons/primary_button.dart';
import '../../../../core/widgets/images/safe_network_image.dart';

class FeaturedProductsStrip extends StatelessWidget {
  final VoidCallback onOpenCatalog;

  const FeaturedProductsStrip({super.key, required this.onOpenCatalog});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<HomeFeaturedCubit, HomeFeaturedState>(
      builder: (context, state) {
        Widget content;

        if (state is HomeFeaturedLoading) {
          content = const _ShimmerRow();
        } else if (state is HomeFeaturedError) {
          content = _ErrorRow(
            message: state.message,
            onRetry: () {
              context.read<HomeFeaturedCubit>().load();
            },
          );
        } else if (state is HomeFeaturedEmpty) {
          content = _EmptyRow(onOpenCatalog: onOpenCatalog);
        } else if (state is HomeFeaturedLoaded) {
          content = _ChipsRow(items: state.items);
        } else {
          content = const SizedBox.shrink();
        }

        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Explorar por tipo',
                style: TextStyle(
                  color: AppTheme.black,
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 12),
              content,
              const SizedBox(height: 10),
              PrimaryButton(
                text: 'Ver catÃ¡logo completo',
                onPressed: onOpenCatalog,
              ),
            ],
          ),
        );
      },
    );
  }
}

class _ChipsRow extends StatelessWidget {
  final List<ProductSummary> items;
  const _ChipsRow({required this.items});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      height: 96,
      padding: const EdgeInsets.symmetric(horizontal: 10),
      child: ListView.separated(
        scrollDirection: Axis.horizontal,
        itemCount: items.length,
        separatorBuilder: (context, _) => const SizedBox(width: 10),
        itemBuilder: (context, i) {
          final p = items[i];
          return _ProductChip(
            name: p.name,
            imageUrl: p.imageUrl,
            isPromo: p.isPromo,
            onTap: () {
              ScaffoldMessenger.of(
                context,
              ).showSnackBar(SnackBar(content: Text('Abrir: ${p.name}')));
            },
          );
        },
      ),
    );
  }
}

class _ProductChip extends StatelessWidget {
  final String name;
  final String? imageUrl;
  final bool isPromo;
  final VoidCallback onTap;

  const _ProductChip({
    required this.name,
    required this.imageUrl,
    required this.isPromo,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final hasImg = (imageUrl != null && imageUrl!.trim().isNotEmpty);

    return InkWell(
      borderRadius: BorderRadius.circular(12),
      onTap: onTap,
      child: Container(
        width: 110,
        decoration: BoxDecoration(
          color: Colors.grey.shade100,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black.withValues(alpha: 0.06)),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (hasImg)
                SafeNetworkImage(
                  url: imageUrl!,
                  fit: BoxFit.cover,
                  placeholder: Container(color: Colors.grey.shade200),
                  fallback: Container(
                    color: Colors.grey.shade200,
                    alignment: Alignment.center,
                    child: const Icon(
                      Icons.image_not_supported_rounded,
                      size: 22,
                    ),
                  ),
                ),
              if (hasImg)
                Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.bottomCenter,
                      end: Alignment.topCenter,
                      colors: [
                        Colors.black.withValues(alpha: 0.35),
                        Colors.transparent,
                      ],
                    ),
                  ),
                ),
              Positioned(
                left: 8,
                right: 8,
                bottom: 8,
                child: Text(
                  name,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: TextStyle(
                    color: hasImg ? AppTheme.white : AppTheme.black,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
              if (isPromo)
                Positioned(
                  top: 6,
                  right: 6,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 6,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: AppTheme.purpleDark,
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: const Text(
                      '%',
                      style: TextStyle(
                        color: AppTheme.white,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ShimmerRow extends StatelessWidget {
  const _ShimmerRow();

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 96,
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      padding: const EdgeInsets.all(10),
      child: ListView.separated(
        scrollDirection: Axis.horizontal,
        itemCount: 4,
        separatorBuilder: (context, _) => const SizedBox(width: 10),
        itemBuilder: (context, _) {
          return Container(
            width: 110,
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              borderRadius: BorderRadius.circular(12),
            ),
          );
        },
      ),
    );
  }
}

class _EmptyRow extends StatelessWidget {
  final VoidCallback onOpenCatalog;
  const _EmptyRow({required this.onOpenCatalog});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 96,
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      alignment: Alignment.center,
      child: TextButton.icon(
        onPressed: onOpenCatalog,
        icon: const Icon(Icons.storefront_rounded),
        label: const Text('Sin productos destacados. Ver catÃ¡logo'),
      ),
    );
  }
}

class _ErrorRow extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;
  const _ErrorRow({required this.message, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 96,
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      alignment: Alignment.center,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.warning_amber_rounded, color: Colors.orange),
          const SizedBox(width: 8),
          const Text('Error cargando destacados'),
          const SizedBox(width: 8),
          TextButton(onPressed: onRetry, child: const Text('Reintentar')),
        ],
      ),
    );
  }
}

 END FILE: modules/features/home/presentation/widgets/featured_products_strip.dart 

----- FILE: modules/features/home/presentation/widgets/greeting_header.dart ----
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/config/app_routes.dart';
import '../../../profile/presentation/blocs/profile_overview_cubit.dart';
import '../../../../core/services/storage/session_storage.dart';

class GreetingHeader extends StatelessWidget {
  final String? nameOverride;
  const GreetingHeader({super.key, this.nameOverride});

  String _extractName(User? user) {
    if (nameOverride != null && nameOverride!.trim().isNotEmpty) return nameOverride!;
    if (user?.displayName != null && user!.displayName!.trim().isNotEmpty) {
      return user.displayName!;
    }
    final email = user?.email ?? '';
    if (email.contains('@')) return email.split('@').first;
    // Para invitado NO usamos el nombre; se maneja aparte.
    return 'â';
  }

  @override
  Widget build(BuildContext context) {
    final authUser = FirebaseAuth.instance.currentUser;
    final state = context.watch<ProfileCubit>().state;

    final isGuest = authUser == null || (authUser.isAnonymous) || (state is ProfileGuest);

    // ---------- VISTA INVITADO ----------
    if (isGuest) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Bienvenida',
              style: TextStyle(
                color: AppTheme.black,
                fontSize: 24,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 6),
            Text(
              'Explora el catÃ¡logo y conoce a las emprendedoras.',
              style: TextStyle(color: Colors.grey.shade700, fontSize: 14),
            ),
            const SizedBox(height: 10),
            SizedBox(
              height: 36,
              child: OutlinedButton.icon(
                icon: const Icon(Icons.login_rounded, size: 18),
                label: const Text('Crear cuenta o iniciar sesiÃ³n'),
                onPressed: () async {
                  // si estÃ¡ en anÃ³nimo, cerrar primero
                  final u = FirebaseAuth.instance.currentUser;
                  if (u != null && u.isAnonymous) {
                    final uid = u.uid;
                    await FirebaseAuth.instance.signOut();
                    if (context.mounted) {
                      await context.read<SessionStorage>().clearRole(uid);
                    }
                  }
                  if (!context.mounted) return;
                  Navigator.pushNamedAndRemoveUntil(
                    context,
                    AppRoutes.welcome,
                    (_) => false,
                  );
                },
              ),
            ),
          ],
        ),
      );
    }

    // ---------- VISTA USUARIA CON PERFIL ----------
    String? role;
    String? displayName;
    if (state is ProfileLoaded) {
      role = state.profile.role?.toLowerCase().trim();
      displayName = (state.profile.name != null && state.profile.name!.trim().isNotEmpty)
          ? state.profile.name!
          : null;
    }

    final name = displayName ?? _extractName(authUser);
    final RoleStyle? roleStyle = _roleStyleOf(role);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Hola, $name',
              style: const TextStyle(
                color: AppTheme.black,
                fontSize: 24,
                fontWeight: FontWeight.w700,
              )),
          const SizedBox(height: 6),
          Wrap(
            spacing: 10,
            crossAxisAlignment: WrapCrossAlignment.center,
            children: [
              if (roleStyle != null) _RoleChip(style: roleStyle),
              // ð Ocultamos ubicaciÃ³n por ahora (se activarÃ¡ cuando tengamos dato real)
              // Text('UbicaciÃ³n', style: TextStyle(color: Colors.grey.shade700, fontSize: 14)),
            ],
          ),
        ],
      ),
    );
  }

  RoleStyle? _roleStyleOf(String? role) {
    if (role == null || role.isEmpty) return null;

    // Colores alineados con la selecciÃ³n de rol:
    // - Emprendedora â rosa (AppTheme.pinkAccent)
    // - Cliente      â azul (AppTheme.blue)
    // (Admin opcional â morado)
    switch (role) {
      case 'emprendedora':
        return RoleStyle(
          label: 'Emprendedora',
          bg: AppTheme.pinkAccent.withValues(alpha: .12),
          fg: AppTheme.pinkAccent,
          icon: Icons.store_mall_directory_rounded,
        );
      case 'cliente':
        return RoleStyle(
          label: 'Cliente',
          bg: AppTheme.blue.withValues(alpha: .12),
          fg: AppTheme.blue,
          icon: Icons.shopping_bag_outlined,
        );
      case 'admin':
        return RoleStyle(
          label: 'Admin',
          bg: AppTheme.purpleDark.withValues(alpha: .12),
          fg: AppTheme.purpleDark,
          icon: Icons.verified_user_outlined,
        );
      default:
        return null;
    }
  }
}

class RoleStyle {
  final String label;
  final Color bg;
  final Color fg;
  final IconData icon;
  RoleStyle({
    required this.label,
    required this.bg,
    required this.fg,
    required this.icon,
  });
}

class _RoleChip extends StatelessWidget {
  final RoleStyle style;
  const _RoleChip({required this.style});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: style.bg,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: style.fg.withValues(alpha: .25)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(style.icon, size: 16, color: style.fg),
          const SizedBox(width: 6),
          Text(
            style.label,
            style: TextStyle(
              color: style.fg,
              fontWeight: FontWeight.w700,
            ),
          ),
        ],
      ),
    );
  }
}

--- END FILE: modules/features/home/presentation/widgets/greeting_header.dart --

----- FILE: modules/features/home/presentation/widgets/home_info_card.dart -----
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';

class HomeInfoCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final Widget? trailing; // ej. "5 cerca"
  final List<Widget> footerActions; // ej. botones "Cerca de mÃ­" / "Por zona"
  final VoidCallback? onTap;
  final IconData? icon;

  const HomeInfoCard({
    super.key,
    required this.title,
    required this.subtitle,
    this.trailing,
    this.footerActions = const [],
    this.onTap,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: onTap,
        child: Container(
          height: 134,
          decoration: BoxDecoration(
            color: AppTheme.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
          ),
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  if (icon != null) ...[
                    Icon(icon, color: AppTheme.purpleDark),
                    const SizedBox(width: 8),
                  ],
                  Expanded(
                    child: Text(
                      title,
                      style: const TextStyle(
                        color: AppTheme.black,
                        fontSize: 16,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ),
                  if (trailing != null) trailing!,
                ],
              ),
              const SizedBox(height: 6),
              Text(
                subtitle,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: TextStyle(color: Colors.grey.shade700, fontSize: 13),
              ),
              const Spacer(),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: footerActions,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

--- END FILE: modules/features/home/presentation/widgets/home_info_card.dart ---

----- FILE: modules/features/home/presentation/widgets/home_info_grid.dart -----
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';
import 'home_info_card.dart';

class HomeInfoGrid extends StatelessWidget {
  final VoidCallback onOpenPickupPoints;
  final VoidCallback onOpenAbout;

  const HomeInfoGrid({
    super.key,
    required this.onOpenPickupPoints,
    required this.onOpenAbout,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: LayoutBuilder(
        builder: (context, c) {
          final isTwoColumns = c.maxWidth >= 620; // simple breakpoint
          final children = [
            HomeInfoCard(
              title: 'Puntos de venta',
              subtitle: 'Ubicaciones de emprendedoras',
              trailing: _Pill(text: 'cerca'),
              icon: Icons.location_on_outlined,
              footerActions: const [
                _Link(text: 'Cerca de mÃ­'),
                _Link(text: 'Por zona'),
              ],
              onTap: onOpenPickupPoints,
            ),
            HomeInfoCard(
              title: 'ConÃ³cenos',
              subtitle: 'Historias, equipo y comunidad 100MT',
              icon: Icons.groups_2_outlined,
              footerActions: const [
                _Link(text: 'Ver mÃ¡s'),
              ],
              onTap: onOpenAbout,
            ),
          ];

          if (isTwoColumns) {
            return Row(
              children: [
                Expanded(child: children[0]),
                const SizedBox(width: 12),
                Expanded(child: children[1]),
              ],
            );
          }
          return Column(
            children: [
              children[0],
              const SizedBox(height: 12),
              children[1],
            ],
          );
        },
      ),
    );
  }
}

class _Pill extends StatelessWidget {
  final String text;
  const _Pill({required this.text});
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
      decoration: BoxDecoration(
        color: AppTheme.blue.withValues(alpha: .12),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        text,
        style: const TextStyle(
          color: AppTheme.purpleDark,
          fontWeight: FontWeight.w700,
          fontSize: 12,
        ),
      ),
    );
  }
}

class _Link extends StatelessWidget {
  final String text;
  const _Link({required this.text});
  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Text(
          text,
          style: const TextStyle(
            color: AppTheme.purpleDark,
            fontWeight: FontWeight.w700,
          ),
        ),
        const Icon(Icons.chevron_right, size: 18, color: AppTheme.purpleDark),
      ],
    );
  }
}

--- END FILE: modules/features/home/presentation/widgets/home_info_grid.dart ---

------- FILE: modules/features/home/presentation/widgets/home_topbar.dart ------
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/images/safe_network_image.dart';
import '../../../cart/presentation/widgets/cart_icon_button.dart';

class HomeTopBar extends StatelessWidget {
  final String logoAsset;

  const HomeTopBar({
    super.key,
    this.logoAsset = 'assets/Logo1_FondoTransparente-Azul.png',
  });

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    final photoUrl = user?.photoURL;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: [
          Image.asset(logoAsset, height: 36, fit: BoxFit.contain),
          const Spacer(),
          IconButton(
            tooltip: 'Notificaciones',
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Notificaciones (prÃ³ximamente)')),
              );
            },
            icon: const Icon(
              Icons.notifications_none_rounded,
              color: AppTheme.black,
            ),
          ),
          const CartIconButton(color: AppTheme.black),
          const SizedBox(width: 4),
          SafeAvatar(
            url: photoUrl,
            size: 36,
            fallbackIcon: Icons.person,
            backgroundColor: Colors.grey.shade300,
            iconColor: AppTheme.purpleDark,
          ),
        ],
      ),
    );
  }
}

----- END FILE: modules/features/home/presentation/widgets/home_topbar.dart ----

------ FILE: modules/features/home/presentation/widgets/logout_button.dart -----
// lib/modules/features/home/presentation/widgets/logout_button.dart
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/config/app_routes.dart';
import '../../../../core/services/storage/session_storage.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class LogoutButton extends StatelessWidget {
  const LogoutButton({super.key});

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.logout, color: AppTheme.white),
      onPressed: () async {
        final uid = FirebaseAuth.instance.currentUser?.uid;
        await FirebaseAuth.instance.signOut();
        if (uid != null && context.mounted) {
          await context.read<SessionStorage>().clearRole(uid);
        }
        if (!context.mounted) return;
        Navigator.pushReplacementNamed(context, AppRoutes.welcome);
      },
    );
  }
}

---- END FILE: modules/features/home/presentation/widgets/logout_button.dart ---

--- FILE: modules/features/home/presentation/widgets/orders_summary_card.dart --
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/config/app_theme.dart';
import '../../domain/entities/order_summary.dart';
import '../blocs/orders_summary_cubit.dart';

class OrdersSummaryCard extends StatelessWidget {
  final VoidCallback onSeeAll;

  const OrdersSummaryCard({super.key, required this.onSeeAll});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Container(
        decoration: BoxDecoration(
          color: AppTheme.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black12),
        ),
        child: BlocBuilder<OrdersSummaryCubit, OrdersSummaryState>(
          builder: (context, state) {
            if (state is OrdersSummaryLoading) {
              return const _Loading();
            }
            if (state is OrdersSummaryError) {
              return _Error(message: state.message, onSeeAll: onSeeAll);
            }
            if (state is OrdersSummaryEmpty) {
              return _Empty(onSeeAll: onSeeAll);
            }
            final items = (state as OrdersSummaryLoaded).items;
            return _Content(items: items, onSeeAll: onSeeAll);
          },
        ),
      ),
    );
  }
}

class _Content extends StatelessWidget {
  final List<OrderSummary> items;
  final VoidCallback onSeeAll;
  const _Content({required this.items, required this.onSeeAll});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _SectionHeader(onSeeAll: onSeeAll),
        const Divider(height: 1),
        ...items.map((o) => _OrderTile(o)),
        const SizedBox(height: 6),
      ],
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final VoidCallback onSeeAll;
  const _SectionHeader({required this.onSeeAll});

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: const Text(
        'Historial de pedidos',
        style: TextStyle(
          color: AppTheme.black,
          fontSize: 18,
          fontWeight: FontWeight.w700,
        ),
      ),
      trailing: TextButton(
        onPressed: onSeeAll,
        child: const Text('Ver todos'),
      ),
    );
  }
}

class _OrderTile extends StatelessWidget {
  final OrderSummary order;
  const _OrderTile(this.order);

  String _statusText(String s) {
    switch (s) {
      case 'pending':
        return 'Pendiente';
      case 'delivered':
        return 'Entregado';
      case 'canceled':
        return 'Cancelado';
      default:
        return s;
    }
  }

  @override
  Widget build(BuildContext context) {
    final date = order.createdAt;
    final dateStr = '${date.day}/${date.month}/${date.year}';
    return ListTile(
      dense: true,
      leading: CircleAvatar(
        backgroundColor: Colors.grey.shade200,
        child: const Icon(Icons.receipt_long, color: AppTheme.purpleDark),
      ),
      title: Text('#${order.id} â¢ ${_statusText(order.status)}',
          style: const TextStyle(fontWeight: FontWeight.w600)),
      subtitle: Text(dateStr),
      trailing: Text('\$${order.total.toStringAsFixed(2)}'),
      onTap: () {
        // Detalle de pedido (a definir)
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Detalle de pedido prÃ³ximamente')),
        );
      },
    );
  }
}

class _Loading extends StatelessWidget {
  const _Loading();
  @override
  Widget build(BuildContext context) {
    return Column(
      children: const [
        _SectionHeader(onSeeAll: _noop),
        Divider(height: 1),
        _ShimmerLine(),
        _ShimmerLine(),
        _ShimmerLine(),
        SizedBox(height: 6),
      ],
    );
  }
}

class _Empty extends StatelessWidget {
  final VoidCallback onSeeAll;
  const _Empty({required this.onSeeAll});
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _SectionHeader(onSeeAll: onSeeAll),
        const Divider(height: 1),
        const Padding(
          padding: EdgeInsets.all(16),
          child: Text('AÃºn no tienes pedidos.'),
        ),
      ],
    );
  }
}

class _Error extends StatelessWidget {
  final String message;
  final VoidCallback onSeeAll;
  const _Error({required this.message, required this.onSeeAll});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _SectionHeader(onSeeAll: onSeeAll),
        const Divider(height: 1),
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              const Icon(Icons.warning_amber_rounded, color: Colors.orange),
              const SizedBox(width: 8),
              Expanded(child: Text('No se pudo cargar: $message')),
            ],
          ),
        ),
      ],
    );
  }
}

class _ShimmerLine extends StatelessWidget {
  const _ShimmerLine();
  @override
  Widget build(BuildContext context) {
    return ListTile(
      dense: true,
      leading: CircleAvatar(backgroundColor: Colors.grey.shade200),
      title: Container(height: 12, color: Colors.grey.shade200),
      subtitle: Container(height: 10, margin: const EdgeInsets.only(top: 6), color: Colors.grey.shade100),
      trailing: Container(width: 50, height: 12, color: Colors.grey.shade200),
    );
  }
}

void _noop() {}

- END FILE: modules/features/home/presentation/widgets/orders_summary_card.dart 

Dentro de /orders:

--------------- FILE: modules/features/orders/orders_routes.dart ---------------
import 'package:flutter/material.dart';
import 'presentation/pages/orders_tab.dart';

class OrdersRoutes {
  static const String base = '/orders';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case base:
        return MaterialPageRoute(builder: (_) => const OrdersTab());
      default:
        return MaterialPageRoute(
          builder: (_) => const Scaffold(
            body: Center(child: Text('Ruta de Pedidos no definida')),
          ),
        );
    }
  }
}

------------- END FILE: modules/features/orders/orders_routes.dart -------------

Dentro de /data:

Dentro de /datasources:

- FILE: modules/features/orders/data/datasources/orders_remote_datasource.dart -
// OJO: escondemos Order de Firestore para evitar conflicto con tu entidad.
import 'package:cloud_firestore/cloud_firestore.dart' hide Order;
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/config/collections.dart';
import '../../domain/entities/order.dart';
import '../models/pickup_point_model.dart';

class OrdersRemoteDataSource {
  final FirebaseFirestore firestore;
  final FirebaseAuth auth;
  OrdersRemoteDataSource(this.firestore, this.auth);

  Future<List<PickupPointModel>> fetchPickupPoints() async {
    final snap = await firestore
        .collection(Col.pickupPoints)
        .orderBy('name')
        .get();
    return snap.docs
        .map((d) => PickupPointModel.fromMap({'id': d.id, ...d.data()}))
        .toList();
  }

  Future<String> createOrder(Order order) async {
    final uid = auth.currentUser?.uid;
    final data = order.toMap();
    final doc = await firestore.collection(Col.orders).add({
      ...data,
      'userId': uid ?? order.userId,
      'createdAt': FieldValue.serverTimestamp(),
    });
    return doc.id;
  }
}

 END FILE: modules/features/orders/data/datasources/orders_remote_datasource.dart 

Dentro de /models:

---------- FILE: modules/features/orders/data/models/order_model.dart ----------
import '../../domain/entities/order.dart';

class OrderModel extends Order {
  const OrderModel({
    super.id,
    required super.userId,
    required super.items,
    required super.deliveryMethod,
    super.pickupPointId,
    super.deliveryAddress,
    required super.recipientName,
    required super.recipientPhone,
    required super.total,
    required super.createdAt,
  });

  factory OrderModel.fromMap(Map<String, dynamic> map) => OrderModel(
        id: (map['id'] ?? '').toString().isEmpty ? null : (map['id'] as String),
        userId: (map['userId'] ?? '').toString(),
        items: ((map['items'] ?? const []) as List)
            .map((e) => OrderItem.fromMap((e as Map).cast<String, dynamic>()))
            .toList(),
        deliveryMethod: ((map['deliveryMethod'] ?? 'pickup').toString() == 'delivery')
            ? DeliveryMethod.delivery
            : DeliveryMethod.pickup,
        pickupPointId: (map['pickupPointId'] ?? '').toString().isEmpty
            ? null
            : (map['pickupPointId'] as String),
        deliveryAddress: (map['deliveryAddress'] ?? '').toString().isEmpty
            ? null
            : (map['deliveryAddress'] as String),
        recipientName: (map['recipientName'] ?? '').toString(),
        recipientPhone: (map['recipientPhone'] ?? '').toString(),
        total: (map['total'] ?? 0) is num ? (map['total'] as num).toDouble() : 0.0,
        createdAt: DateTime.tryParse((map['createdAt'] ?? '').toString()) ??
            DateTime.now().toUtc(),
      );

  Map<String, dynamic> toFirestore() => super.toMap();
}

-------- END FILE: modules/features/orders/data/models/order_model.dart --------

------- FILE: modules/features/orders/data/models/pickup_point_model.dart ------
import '../../domain/entities/pickup_point.dart';

class PickupPointModel extends PickupPoint {
  const PickupPointModel({
    required super.id,
    required super.name,
    required super.address,
  });

  factory PickupPointModel.fromMap(Map<String, dynamic> m) => PickupPointModel(
        id: (m['id'] ?? '').toString(),
        name: (m['name'] ?? '').toString(),
        address: (m['address'] ?? '').toString(),
      );

  Map<String, dynamic> toMap() => {
        'id': id,
        'name': name,
        'address': address,
      };
}

----- END FILE: modules/features/orders/data/models/pickup_point_model.dart ----

Dentro de /repositories:

-- FILE: modules/features/orders/data/repositories/orders_repository_impl.dart -
import '../../domain/entities/order.dart';
import '../../domain/entities/pickup_point.dart';
import '../../domain/repositories/orders_repository.dart';
import '../datasources/orders_remote_datasource.dart';

class OrdersRepositoryImpl implements OrdersRepository {
  final OrdersRemoteDataSource remote;
  OrdersRepositoryImpl(this.remote);

  @override
  Future<List<PickupPoint>> fetchPickupPoints() async {
    final list = await remote.fetchPickupPoints();
    return list; // PickupPointModel extiende PickupPoint
  }

  @override
  Future<String> createOrder(Order order) => remote.createOrder(order);
}

 END FILE: modules/features/orders/data/repositories/orders_repository_impl.dart 

Dentro de /domain:

Dentro de /entities:

----------- FILE: modules/features/orders/domain/entities/order.dart -----------
// Evita conflicto con Firestore.Order:
enum DeliveryMethod { pickup, delivery }

class OrderItem {
  final String productId;
  final String presentationId;
  final int qty;
  final double unitPrice;

  const OrderItem({
    required this.productId,
    required this.presentationId,
    required this.qty,
    required this.unitPrice,
  });

  double get lineTotal => unitPrice * qty;

  Map<String, dynamic> toMap() => {
        'productId': productId,
        'presentationId': presentationId,
        'qty': qty,
        'unitPrice': unitPrice,
        'lineTotal': lineTotal,
      };

  factory OrderItem.fromMap(Map<String, dynamic> m) => OrderItem(
        productId: (m['productId'] ?? '').toString(),
        presentationId: (m['presentationId'] ?? '').toString(),
        qty: (m['qty'] ?? 0) is num ? (m['qty'] as num).toInt() : 0,
        unitPrice: (m['unitPrice'] ?? 0) is num ? (m['unitPrice'] as num).toDouble() : 0.0,
      );
}

class Order {
  final String? id;
  final String userId;
  final List<OrderItem> items;
  final DeliveryMethod deliveryMethod;
  final String? pickupPointId;   // si deliveryMethod == pickup
  final String? deliveryAddress; // si deliveryMethod == delivery
  final String recipientName;
  final String recipientPhone;
  final double total;
  final DateTime createdAt;

  const Order({
    this.id,
    required this.userId,
    required this.items,
    required this.deliveryMethod,
    this.pickupPointId,
    this.deliveryAddress,
    required this.recipientName,
    required this.recipientPhone,
    required this.total,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() => {
        if (id != null) 'id': id,
        'userId': userId,
        'items': items.map((e) => e.toMap()).toList(),
        'deliveryMethod': deliveryMethod.name,
        'pickupPointId': pickupPointId,
        'deliveryAddress': deliveryAddress,
        'recipientName': recipientName,
        'recipientPhone': recipientPhone,
        'total': total,
        'createdAt': createdAt.toUtc(),
      };

  factory Order.fromMap(Map<String, dynamic> m) => Order(
        id: (m['id'] ?? '').toString().isEmpty ? null : (m['id'] as String),
        userId: (m['userId'] ?? '').toString(),
        items: ((m['items'] ?? const []) as List)
            .map((e) => OrderItem.fromMap((e as Map).cast<String, dynamic>()))
            .toList(),
        deliveryMethod: ((m['deliveryMethod'] ?? 'pickup').toString() == 'delivery')
            ? DeliveryMethod.delivery
            : DeliveryMethod.pickup,
        pickupPointId: (m['pickupPointId'] ?? '').toString().isEmpty
            ? null
            : (m['pickupPointId'] as String),
        deliveryAddress: (m['deliveryAddress'] ?? '').toString().isEmpty
            ? null
            : (m['deliveryAddress'] as String),
        recipientName: (m['recipientName'] ?? '').toString(),
        recipientPhone: (m['recipientPhone'] ?? '').toString(),
        total: (m['total'] ?? 0) is num ? (m['total'] as num).toDouble() : 0.0,
        createdAt: DateTime.tryParse((m['createdAt'] ?? '').toString()) ??
            DateTime.fromMillisecondsSinceEpoch(
              (m['createdAt'] as int? ?? DateTime.now().millisecondsSinceEpoch),
              isUtc: true,
            ),
      );
}

--------- END FILE: modules/features/orders/domain/entities/order.dart ---------

--------- FILE: modules/features/orders/domain/entities/order_item.dart --------
class OrderItem {
  final String presentationId;
  final String presentationName;
  final double unitPrice;
  final int quantity;

  const OrderItem({
    required this.presentationId,
    required this.presentationName,
    required this.unitPrice,
    required this.quantity,
  });

  double get subtotal => unitPrice * quantity;
}

------- END FILE: modules/features/orders/domain/entities/order_item.dart ------

-------- FILE: modules/features/orders/domain/entities/pickup_point.dart -------
class PickupPoint {
  final String id;
  final String name;
  final String address;

  const PickupPoint({
    required this.id,
    required this.name,
    required this.address,
  });
}

------ END FILE: modules/features/orders/domain/entities/pickup_point.dart -----

--------- FILE: modules/features/orders/domain/entities/recipient.dart ---------
class Recipient {
  final String name;
  final String phoneE164;

  const Recipient({required this.name, required this.phoneE164});
}

------- END FILE: modules/features/orders/domain/entities/recipient.dart -------

Dentro de /repositories:

--- FILE: modules/features/orders/domain/repositories/orders_repository.dart ---
import '../entities/order.dart';
import '../entities/pickup_point.dart';

abstract class OrdersRepository {
  Future<List<PickupPoint>> fetchPickupPoints();
  Future<String> createOrder(Order order);
}

- END FILE: modules/features/orders/domain/repositories/orders_repository.dart -

Dentro de /usecases:

-------- FILE: modules/features/orders/domain/usecases/create_order.dart -------
import '../entities/order.dart';
import '../repositories/orders_repository.dart';

class CreateOrder {
  final OrdersRepository repo;
  CreateOrder(this.repo);

  Future<String> call(Order order) => repo.createOrder(order);
}

------ END FILE: modules/features/orders/domain/usecases/create_order.dart -----

-- FILE: modules/features/orders/domain/usecases/get_orders_by_date_range.dart -

 END FILE: modules/features/orders/domain/usecases/get_orders_by_date_range.dart 

----- FILE: modules/features/orders/domain/usecases/get_pickup_points.dart -----
import '../entities/pickup_point.dart';
import '../repositories/orders_repository.dart';

class GetPickupPoints {
  final OrdersRepository repo;
  GetPickupPoints(this.repo);

  Future<List<PickupPoint>> call() => repo.fetchPickupPoints();
}

--- END FILE: modules/features/orders/domain/usecases/get_pickup_points.dart ---

----- FILE: modules/features/orders/domain/usecases/schedule_delivery.dart -----

--- END FILE: modules/features/orders/domain/usecases/schedule_delivery.dart ---

---- FILE: modules/features/orders/domain/usecases/update_order_status.dart ----

-- END FILE: modules/features/orders/domain/usecases/update_order_status.dart --

---- FILE: modules/features/orders/domain/usecases/verify_order_payment.dart ---

-- END FILE: modules/features/orders/domain/usecases/verify_order_payment.dart -

Dentro de /presentation:

Dentro de /blocs:

--- FILE: modules/features/orders/presentation/blocs/order_create_cubit.dart ---
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../catalog/domain/entities/presentation.dart';
import '../../domain/entities/order.dart';
import '../../domain/entities/pickup_point.dart';
import '../../domain/usecases/create_order.dart';
import '../../domain/usecases/get_pickup_points.dart';

sealed class OrderCreateState {}

class OrderCreateEditing extends OrderCreateState {
  final String productId;
  final String productName;
  final Presentation? initialPresentation;

  final int qty;
  final DeliveryMethod deliveryMethod;
  final String? pickupPointId;
  final String? addressLine;
  final String recipientName;
  final String recipientPhone;

  final List<PickupPoint> pickupPoints;

  final bool isSubmitting;

  OrderCreateEditing({
    required this.productId,
    required this.productName,
    required this.initialPresentation,
    required this.qty,
    required this.deliveryMethod,
    required this.pickupPointId,
    required this.addressLine,
    required this.recipientName,
    required this.recipientPhone,
    required this.pickupPoints,
    required this.isSubmitting,
  });

  int get minQty => initialPresentation?.minQty ?? 1;
  double get unitPrice => initialPresentation?.unitPrice ?? 0;
  double get total => unitPrice * qty;

  bool get canSubmit {
    final okQty = qty >= minQty && qty > 0;
    final okRecipient = recipientName.trim().isNotEmpty && recipientPhone.trim().isNotEmpty;
    final okDelivery = deliveryMethod == DeliveryMethod.pickup
        ? (pickupPointId ?? '').isNotEmpty
        : (addressLine ?? '').trim().isNotEmpty;
    return okQty && okRecipient && okDelivery && !isSubmitting;
  }

  OrderCreateEditing copyWith({
    int? qty,
    DeliveryMethod? deliveryMethod,
    String? pickupPointId,
    String? addressLine,
    String? recipientName,
    String? recipientPhone,
    List<PickupPoint>? pickupPoints,
    bool? isSubmitting,
    Presentation? initialPresentation,
  }) {
    return OrderCreateEditing(
      productId: productId,
      productName: productName,
      initialPresentation: initialPresentation ?? this.initialPresentation,
      qty: qty ?? this.qty,
      deliveryMethod: deliveryMethod ?? this.deliveryMethod,
      pickupPointId: pickupPointId ?? this.pickupPointId,
      addressLine: addressLine ?? this.addressLine,
      recipientName: recipientName ?? this.recipientName,
      recipientPhone: recipientPhone ?? this.recipientPhone,
      pickupPoints: pickupPoints ?? this.pickupPoints,
      isSubmitting: isSubmitting ?? this.isSubmitting,
    );
  }
}

class OrderCreateSaved extends OrderCreateState {
  final String orderId;
  OrderCreateSaved(this.orderId);
}

class OrderCreateError extends OrderCreateState {
  final String message;
  OrderCreateError(this.message);
}

class OrderCreateCubit extends Cubit<OrderCreateState> {
  final GetPickupPoints getPickupPoints;
  final CreateOrder createOrder;

  OrderCreateCubit({
    required String productId,
    required String productName,
    required Presentation? initialPresentation,
    required this.getPickupPoints,
    required this.createOrder,
  }) : super(
          OrderCreateEditing(
            productId: productId,
            productName: productName,
            initialPresentation: initialPresentation,
            qty: initialPresentation?.minQty ?? 1,
            deliveryMethod: DeliveryMethod.pickup,
            pickupPointId: null,
            addressLine: null,
            recipientName: '',
            recipientPhone: '',
            pickupPoints: const [],
            isSubmitting: false,
          ),
        );

  Future<void> loadPickupPoints() async {
    final st = state;
    if (st is! OrderCreateEditing) return;
    try {
      final list = await getPickupPoints();
      emit(st.copyWith(pickupPoints: list));
    } catch (_) {
      // Silencioso: mantiene UI usable
      emit(st.copyWith(pickupPoints: const []));
    }
  }

  void setQty(int q) {
    final st = state;
    if (st is! OrderCreateEditing) return;
    emit(st.copyWith(qty: q < 1 ? 1 : q));
  }

  void setDeliveryMethod(DeliveryMethod m) {
    final st = state;
    if (st is! OrderCreateEditing) return;
    emit(st.copyWith(
      deliveryMethod: m,
      // limpia campos del otro mÃ©todo
      pickupPointId: m == DeliveryMethod.pickup ? st.pickupPointId : null,
      addressLine: m == DeliveryMethod.delivery ? st.addressLine : null,
    ));
  }

  void setPickupPoint(String? id) {
    final st = state;
    if (st is! OrderCreateEditing) return;
    emit(st.copyWith(pickupPointId: (id ?? '').isEmpty ? null : id));
  }

  void setAddressLine(String s) {
    final st = state;
    if (st is! OrderCreateEditing) return;
    emit(st.copyWith(addressLine: s));
  }

  void setRecipient({required String name, required String phone}) {
    final st = state;
    if (st is! OrderCreateEditing) return;
    emit(st.copyWith(recipientName: name, recipientPhone: phone));
  }

  Future<void> submit(String userId) async {
    final st = state;
    if (st is! OrderCreateEditing) return;
    if (!st.canSubmit) return;

    emit(st.copyWith(isSubmitting: true));
    try {
      final it = OrderItem(
        productId: st.productId,
        presentationId: st.initialPresentation?.id ?? '',
        qty: st.qty,
        unitPrice: st.unitPrice,
      );

      final order = Order(
        userId: userId,
        items: [it],
        deliveryMethod: st.deliveryMethod,
        pickupPointId: st.deliveryMethod == DeliveryMethod.pickup ? st.pickupPointId : null,
        deliveryAddress: st.deliveryMethod == DeliveryMethod.delivery ? st.addressLine : null,
        recipientName: st.recipientName,
        recipientPhone: st.recipientPhone,
        total: st.total,
        createdAt: DateTime.now().toUtc(),
      );

      final id = await createOrder(order);
      emit(OrderCreateSaved(id));
    } catch (_) {
      emit(OrderCreateError('No se pudo crear el pedido'));
      emit(st.copyWith(isSubmitting: false));
    }
  }
}

- END FILE: modules/features/orders/presentation/blocs/order_create_cubit.dart -

--- FILE: modules/features/orders/presentation/blocs/payment_proof_cubit.dart --
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../../../core/config/collections.dart';
import '../../../../core/config/storage_flags.dart';
import '../../../../core/services/storage/i_file_storage_service.dart';
import '../../../../core/utils/data/image_bytes.dart';
import '../../../../core/config/storage_config.dart';
import '../../../../core/utils/errors/firebase_errors.dart';

sealed class PaymentProofState {}

class PaymentProofIdle extends PaymentProofState {}

class PaymentProofUploading extends PaymentProofState {
  final double progress; // 0..1 (si tuvieras progress real)
  PaymentProofUploading({this.progress = 0});
}

class PaymentProofSuccess extends PaymentProofState {
  final String url;
  PaymentProofSuccess(this.url);
}

class PaymentProofError extends PaymentProofState {
  final String message;
  PaymentProofError(this.message);
}

class PaymentProofCubit extends Cubit<PaymentProofState> {
  final IFileStorageService primaryStorage;
  final IFileStorageService? fallbackStorage;

  PaymentProofCubit({
    required this.primaryStorage,
    this.fallbackStorage,
  }) : super(PaymentProofIdle());

  Future<void> uploadAndAttachProof({
    required String orderId,
    required Uint8List bytes,
    required String? contentTypeHint,
  }) async {
    emit(PaymentProofUploading());

    try {
      final ct = contentTypeHint ??
          ImageBytesHelper.sniffContentType(bytes) ??
          'application/octet-stream';

      // Validaciones bÃ¡sicas (mismos lÃ­mites del catÃ¡logo)
      if (!StorageConfig.allowedMime.contains(ct)) {
        throw Exception('Formato no permitido. Adjunta JPG/PNG o PDF.');
      }
      if (bytes.length > StorageConfig.maxFileBytes) {
        throw Exception('Archivo muy grande. MÃ¡ximo 5 MB.');
      }

      final fileName = ImageBytesHelper.buildFileName(
        uid: orderId,
        base: 'payment_proof',
        contentType: ct,
      );

      String url;
      try {
        final res = await primaryStorage.uploadBytes(
          bytes: bytes,
          fileName: fileName,
          contentType: ct,
          folder: StorageFlags.ordersFolder,
        );
        url = res.url;
      } catch (e) {
        if (fallbackStorage == null) rethrow;
        final res = await fallbackStorage!.uploadBytes(
          bytes: bytes,
          fileName: fileName,
          contentType: ct,
          folder: StorageFlags.ordersFolder,
        );
        url = res.url;
      }

      // Persistimos la URL en la orden
      final fs = FirebaseFirestore.instance;
      await fs.collection(Col.orders).doc(orderId).set(
        {'paymentProofUrl': url, 'updatedAt': FieldValue.serverTimestamp()},
        SetOptions(merge: true),
      );

      emit(PaymentProofSuccess(url));
    } catch (e) {
      final friendly = FirebaseErrorMapper.friendly(
        e,
        generic: 'No se pudo subir el comprobante. Intenta de nuevo.',
      );
      debugPrint('PaymentProofCubit error: $e');
      emit(PaymentProofError(friendly));
    }
  }

  void reset() => emit(PaymentProofIdle());
}

- END FILE: modules/features/orders/presentation/blocs/payment_proof_cubit.dart 

Dentro de /pages:

---- FILE: modules/features/orders/presentation/pages/order_create_page.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart' hide Order;
import 'package:firebase_auth/firebase_auth.dart';
import '../../../catalog/domain/entities/presentation.dart';
import '../../data/datasources/orders_remote_datasource.dart';
import '../../data/repositories/orders_repository_impl.dart';
import '../../domain/entities/order.dart';
import '../../domain/usecases/create_order.dart';
import '../../domain/usecases/get_pickup_points.dart';
import '../blocs/order_create_cubit.dart';
import '../widgets/delivery_method_selector.dart';

class OrderCreatePage extends StatelessWidget {
  final String productId;
  final String productName;
  final Presentation? initialPresentation;

  const OrderCreatePage({
    super.key,
    required this.productId,
    required this.productName,
    this.initialPresentation,
  });

  @override
  Widget build(BuildContext context) {
    final firestore = FirebaseFirestore.instance;
    final auth = FirebaseAuth.instance;

    final ds = OrdersRemoteDataSource(firestore, auth);
    final repo = OrdersRepositoryImpl(ds);
    final getPickupPoints = GetPickupPoints(repo);
    final createOrder = CreateOrder(repo);

    return BlocProvider(
      create: (_) => OrderCreateCubit(
        productId: productId,
        productName: productName,
        initialPresentation: initialPresentation,
        getPickupPoints: getPickupPoints,
        createOrder: createOrder,
      )..loadPickupPoints(),
      child: _OrderCreateView(userId: auth.currentUser?.uid ?? ''),
    );
  }
}

class _OrderCreateView extends StatelessWidget {
  final String userId;
  const _OrderCreateView({required this.userId});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Crear pedido')),
      body: BlocConsumer<OrderCreateCubit, OrderCreateState>(
        listener: (context, state) {
          if (state is OrderCreateSaved) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Pedido creado correctamente')),
            );
            Navigator.pop(context);
          } else if (state is OrderCreateError) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(state.message)),
            );
          }
        },
        builder: (context, state) {
          if (state is! OrderCreateEditing) {
            return const Center(child: CircularProgressIndicator());
          }

          final c = context.read<OrderCreateCubit>();

          return ListView(
            padding: const EdgeInsets.all(16),
            children: [
              Text(
                state.productName,
                style: const TextStyle(fontSize: 20, fontWeight: FontWeight.w700),
              ),
              if (state.initialPresentation != null) ...[
                const SizedBox(height: 6),
                Text(
                  'PresentaciÃ³n: ${state.initialPresentation!.name} '
                  'Â· \$${state.unitPrice.toStringAsFixed(2)} '
                  '(min ${state.minQty})',
                ),
              ],
              const SizedBox(height: 12),

              // Cantidad
              Row(
                children: [
                  const Text('Cantidad', style: TextStyle(fontWeight: FontWeight.w600)),
                  const SizedBox(width: 10),
                  IconButton(
                    onPressed: () => c.setQty(state.qty - 1),
                    icon: const Icon(Icons.remove_circle_outline),
                  ),
                  Text('${state.qty}', style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w700)),
                  IconButton(
                    onPressed: () => c.setQty(state.qty + 1),
                    icon: const Icon(Icons.add_circle_outline),
                  ),
                ],
              ),

              const Divider(height: 24),

              // MÃ©todo de entrega
              DeliveryMethodSelector(
                value: state.deliveryMethod,
                onChanged: c.setDeliveryMethod,
              ),
              const SizedBox(height: 8),

              if (state.deliveryMethod == DeliveryMethod.pickup) ...[
                const Text('Punto de retiro', style: TextStyle(fontWeight: FontWeight.w600)),
                const SizedBox(height: 6),
                DropdownButtonFormField<String>(
                  initialValue: state.pickupPointId,
                  items: state.pickupPoints
                      .map((p) =>
                          DropdownMenuItem(value: p.id, child: Text('${p.name} â ${p.address}')))
                      .toList(),
                  onChanged: c.setPickupPoint,
                  decoration: const InputDecoration(isDense: true, border: OutlineInputBorder()),
                ),
              ] else ...[
                const Text('DirecciÃ³n de entrega', style: TextStyle(fontWeight: FontWeight.w600)),
                const SizedBox(height: 6),
                TextFormField(
                  initialValue: state.addressLine ?? '',
                  onChanged: c.setAddressLine,
                  decoration: const InputDecoration(
                    hintText: 'Calle, nÃºmero, referenciaâ¦',
                    isDense: true,
                    border: OutlineInputBorder(),
                  ),
                ),
              ],

              const SizedBox(height: 14),
              const Text('Datos del destinatario', style: TextStyle(fontWeight: FontWeight.w600)),
              const SizedBox(height: 6),
              TextFormField(
                initialValue: state.recipientName,
                onChanged: (v) => c.setRecipient(name: v, phone: state.recipientPhone),
                decoration: const InputDecoration(
                  labelText: 'Nombre y apellido',
                  isDense: true,
                  border: OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                initialValue: state.recipientPhone,
                keyboardType: TextInputType.phone,
                onChanged: (v) => c.setRecipient(name: state.recipientName, phone: v),
                decoration: const InputDecoration(
                  labelText: 'TelÃ©fono',
                  isDense: true,
                  border: OutlineInputBorder(),
                ),
              ),

              const SizedBox(height: 16),
              Row(
                children: [
                  const Spacer(),
                  Text('Total: \$${state.total.toStringAsFixed(2)}',
                      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w800)),
                ],
              ),
              const SizedBox(height: 10),
              FilledButton(
                onPressed: state.canSubmit ? () => c.submit(userId) : null,
                child: Text(state.isSubmitting ? 'Enviandoâ¦' : 'Confirmar pedido'),
              ),
            ],
          );
        },
      ),
    );
  }
}

-- END FILE: modules/features/orders/presentation/pages/order_create_page.dart -

------- FILE: modules/features/orders/presentation/pages/orders_tab.dart -------
import 'package:flutter/material.dart';

class OrdersTab extends StatelessWidget {
  const OrdersTab({super.key});

  @override
  Widget build(BuildContext context) {
    return const SafeArea(
      child: Center(
        child: Text('Tus pedidos (prÃ³ximamente)'),
      ),
    );
  }
}

----- END FILE: modules/features/orders/presentation/pages/orders_tab.dart -----

Dentro de /widgets:

-- FILE: modules/features/orders/presentation/widgets/address_line_field.dart --
import 'package:flutter/material.dart';
import '../../../../core/utils/input/input_formatters.dart';

class AddressLineField extends StatelessWidget {
  final String value;
  final ValueChanged<String> onChanged;

  const AddressLineField({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      initialValue: value,
      onChanged: onChanged,
      inputFormatters: const [AddressTextFormatter()],
      decoration: const InputDecoration(
        labelText: 'DirecciÃ³n (una lÃ­nea)',
        hintText: 'Ej. Av. Siempre Viva 123 y Central',
        isDense: true,
        border: OutlineInputBorder(),
      ),
    );
  }
}

 END FILE: modules/features/orders/presentation/widgets/address_line_field.dart 

 FILE: modules/features/orders/presentation/widgets/delivery_method_selector.dart 
import 'package:flutter/material.dart';
import '../../domain/entities/order.dart'; // DeliveryMethod (pickup|delivery)

class DeliveryMethodSelector extends StatelessWidget {
  final DeliveryMethod value;
  final ValueChanged<DeliveryMethod> onChanged;

  const DeliveryMethodSelector({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('MÃ©todo de entrega', style: TextStyle(fontWeight: FontWeight.w600)),
        const SizedBox(height: 4),
        // â Flutter 3.32+: RadioGroup administra el valor del grupo
        RadioGroup<DeliveryMethod>(
          groupValue: value,
          onChanged: (v) => onChanged(v ?? value),
          child: Row(
            children: [
              Expanded(
                child: RadioListTile<DeliveryMethod>(
                  dense: true,
                  value: DeliveryMethod.pickup,
                  title: const Text('Retiro en punto'),
                ),
              ),
              Expanded(
                child: RadioListTile<DeliveryMethod>(
                  dense: true,
                  value: DeliveryMethod.delivery,
                  title: const Text('Entrega a domicilio'),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

 END FILE: modules/features/orders/presentation/widgets/delivery_method_selector.dart 

---- FILE: modules/features/orders/presentation/widgets/order_item_tile.dart ---
import 'package:flutter/material.dart';
import '../../domain/entities/order_item.dart';

class OrderItemTile extends StatelessWidget {
  final OrderItem item;
  const OrderItemTile({super.key, required this.item});

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(item.presentationName, style: const TextStyle(fontWeight: FontWeight.w700)),
      subtitle: Text('${item.quantity} Ã \$${item.unitPrice.toStringAsFixed(2)}'),
      trailing: Text('\$${item.subtotal.toStringAsFixed(2)}'),
    );
  }
}

-- END FILE: modules/features/orders/presentation/widgets/order_item_tile.dart -

- FILE: modules/features/orders/presentation/widgets/pickup_point_dropdown.dart 
import 'package:flutter/material.dart';
import '../../domain/entities/pickup_point.dart';

class PickupPointDropdown extends StatelessWidget {
  final List<PickupPoint> items;
  final PickupPoint? selected;
  final ValueChanged<PickupPoint?> onChanged;

  const PickupPointDropdown({
    super.key,
    required this.items,
    required this.selected,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<PickupPoint>(
      // Flutter 3.33+: usar initialValue
      initialValue: selected,
      decoration: const InputDecoration(
        labelText: 'Punto de retiro',
        border: OutlineInputBorder(),
        isDense: true,
      ),
      items: items
          .map(
            (p) => DropdownMenuItem<PickupPoint>(
              value: p,
              child: Text('${p.name} â ${p.address}'),
            ),
          )
          .toList(growable: false),
      onChanged: onChanged,
    );
  }
}

 END FILE: modules/features/orders/presentation/widgets/pickup_point_dropdown.dart 

----- FILE: modules/features/orders/presentation/widgets/qty_selector.dart -----
import 'package:flutter/material.dart';

class QtySelector extends StatelessWidget {
  final int value;
  final int min;
  final ValueChanged<int> onChanged;

  const QtySelector({
    super.key,
    required this.value,
    required this.min,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        _Btn(
          icon: Icons.remove_rounded,
          onTap: () {
            final n = value - 1;
            onChanged(n < min ? min : n);
          },
        ),
        const SizedBox(width: 10),
        Text(
          '$value',
          style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w700),
        ),
        const SizedBox(width: 10),
        _Btn(
          icon: Icons.add_rounded,
          onTap: () => onChanged(value + 1),
        ),
        const Spacer(),
        Text('MÃ­n: $min', style: TextStyle(color: Colors.grey.shade700)),
      ],
    );
  }
}

class _Btn extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  const _Btn({required this.icon, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Ink(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.black12),
        borderRadius: BorderRadius.circular(8),
      ),
      child: InkWell(
        borderRadius: BorderRadius.circular(8),
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.all(8),
          child: Icon(icon, size: 20),
        ),
      ),
    );
  }
}

--- END FILE: modules/features/orders/presentation/widgets/qty_selector.dart ---

Dentro de /profile:

-------------- FILE: modules/features/profile/profile_routes.dart --------------
// lib/modules/features/profile/profile_routes.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'presentation/pages/profile_edit_page.dart';
import 'presentation/pages/legal_page.dart';
import 'presentation/pages/notifications_page.dart';
import 'presentation/pages/profile_account_page.dart';

// DI edicion
import 'data/datasources/profile_write_remote_datasource.dart';
import 'data/repositories/profile_write_repository_impl.dart';
import 'domain/usecases/update_user_profile.dart';
import 'presentation/blocs/profile_editor_cubit.dart';

// Storage (nuevo servicio via Function)
import '../../core/services/storage/cloudinary_function_storage_service.dart';
import '../../core/services/storage/firebase_storage_service.dart' as fbstore;
import '../../core/config/storage_flags.dart';

class ProfileRoutes {
  static const edit = '/profile/edit';
  static const account = '/profile/account';
  static const legal = '/profile/legal';
  static const notifications = '/profile/notifications';

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case account:
        return MaterialPageRoute(
          builder: (_) => const ProfileAccountPage(),
        );

      case edit:
        {
          final uid = FirebaseAuth.instance.currentUser?.uid;
          if (uid == null || uid.isEmpty) {
            return MaterialPageRoute(
              builder:
                  (_) => const Scaffold(
                    body: Center(child: Text('Debes iniciar sesi\u00f3n')),
                  ),
            );
          }

          // Data layer
          final ds = ProfileWriteRemoteDataSource(
            FirebaseFirestore.instance,
            FirebaseAuth.instance,
          );
          final repo = ProfileWriteRepositoryImpl(ds);
          final uc = UpdateUserProfile(repo);

          // Uploader: Cloudinary via Function (firmado)
          final uploader = CloudinaryFunctionStorageService();

          // Fallback opcional a Firebase Storage (desactivado por defecto)
          final firebaseFallback =
              StorageFlags.enableFirebaseFallback
                  ? fbstore.FirebaseStorageService()
                  : null;

          return MaterialPageRoute(
            builder:
                (_) => BlocProvider(
                  create:
                      (_) => ProfileEditCubit(
                        uid: uid,
                        update: uc,
                        repo: repo,
                        cloudinary: uploader,
                        firebaseFallback: firebaseFallback,
                      )..bootstrap(),
                  child: const EditProfilePage(),
                ),
          );
        }

      case legal:
        return MaterialPageRoute(builder: (_) => const LegalPage());

      case notifications:
        return MaterialPageRoute(builder: (_) => const NotificationsPage());

      default:
        return MaterialPageRoute(
          builder:
              (_) => const Scaffold(
                body: Center(child: Text('Ruta Perfil no definida')),
              ),
        );
    }
  }
}

------------ END FILE: modules/features/profile/profile_routes.dart ------------

Dentro de /data:

Dentro de /datasources:

 FILE: modules/features/profile/data/datasources/profile_read_remote_datasource.dart 
// lib/modules/features/profile/data/datasources/profile_remote_datasource.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../../core/config/collections.dart';
import '../models/user_profile_model.dart';

class ProfileRemoteDataSource {
  final FirebaseFirestore firestore;
  ProfileRemoteDataSource(this.firestore);

  Stream<UserProfileModel?> watchByUid(String uid) {
    final ref = firestore.collection(Col.users).doc(uid);
    return ref.snapshots().map((doc) {
      if (!doc.exists) return null;
      return UserProfileModel.fromDoc(doc);
    });
  }
}

 END FILE: modules/features/profile/data/datasources/profile_read_remote_datasource.dart 

 FILE: modules/features/profile/data/datasources/profile_write_remote_datasource.dart 
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/config/collections.dart';

class ProfileWriteRemoteDataSource {
  final FirebaseFirestore firestore;
  final FirebaseAuth auth;
  ProfileWriteRemoteDataSource(this.firestore, this.auth);

  Future<Map<String, dynamic>?> fetchOnce(String uid) async {
    final doc = await firestore.collection(Col.users).doc(uid).get();
    return doc.data();
  }

  Future<void> updateProfile({
    required String uid,
    required Map<String, dynamic> patch,
  }) async {
    await firestore.collection(Col.users).doc(uid).set(patch, SetOptions(merge: true));
  }

  Future<void> syncAuth({
    required String uid,
    String? displayName,
    String? photoUrl,
  }) async {
    final u = auth.currentUser;
    if (u == null || u.uid != uid) return;
    final updates = <String, dynamic>{};
    if (displayName != null) updates['displayName'] = displayName;
    if (photoUrl != null) updates['photoURL'] = photoUrl;
    if (updates.isEmpty) return;
    await u.updateDisplayName(updates['displayName']);
    await u.updatePhotoURL(updates['photoURL']);
  }
}

 END FILE: modules/features/profile/data/datasources/profile_write_remote_datasource.dart 

Dentro de /models:

------ FILE: modules/features/profile/data/models/user_profile_model.dart ------
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/user_profile.dart';

class UserProfileModel extends UserProfile {
  const UserProfileModel({
    required super.uid,
    super.name,
    super.cedula,
    super.role,
    super.phone,
    super.photoUrl,
    super.photoPublicId,
    super.addressLine,
    super.lastAccess,
  });

  factory UserProfileModel.fromDoc(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? <String, dynamic>{};
    final rawLastAccess = data['lastAccess'];
    DateTime? lastAccess;
    if (rawLastAccess is Timestamp) {
      lastAccess = rawLastAccess.toDate();
    } else if (rawLastAccess is DateTime) {
      lastAccess = rawLastAccess;
    }
    return UserProfileModel(
      uid: doc.id,
      name: (data['name'] ?? '').toString(),
      cedula: (data['cedula'] ?? '').toString(),
      role: (data['role'] ?? '').toString(),
      phone: (data['phone'] ?? '').toString(),
      photoUrl: (data['photoUrl'] ?? '').toString(),
      photoPublicId: (data['photoPublicId'] ?? '').toString(),
      addressLine: (data['addressLine'] ?? '').toString(),
      lastAccess: lastAccess,
    );
  }
}

---- END FILE: modules/features/profile/data/models/user_profile_model.dart ----

Dentro de /repositories:

 FILE: modules/features/profile/data/repositories/profile_read_repository_impl.dart 
import '../../domain/entities/user_profile.dart';
import '../../domain/repositories/profile_read_repository.dart';
import '../datasources/profile_read_remote_datasource.dart';

class ProfileRepositoryImpl implements ProfileRepository {
  final ProfileRemoteDataSource remote;
  ProfileRepositoryImpl(this.remote);

  @override
  Stream<UserProfile?> watchProfile(String uid) => remote.watchByUid(uid);
}

 END FILE: modules/features/profile/data/repositories/profile_read_repository_impl.dart 

 FILE: modules/features/profile/data/repositories/profile_write_repository_impl.dart 
import '../../domain/repositories/profile_write_repository.dart';
import '../datasources/profile_write_remote_datasource.dart';

class ProfileWriteRepositoryImpl implements ProfileWriteRepository {
  final ProfileWriteRemoteDataSource remote;
  ProfileWriteRepositoryImpl(this.remote);

  @override
  Future<Map<String, dynamic>?> fetchProfileOnce(String uid) {
    return remote.fetchOnce(uid);
  }

  @override
  Future<void> updateProfile({required String uid, required Map<String, dynamic> patch}) {
    return remote.updateProfile(uid: uid, patch: patch);
  }

  @override
  Future<void> syncAuth({
    required String uid,
    String? displayName,
    String? photoUrl,
  }) {
    return remote.syncAuth(uid: uid, displayName: displayName, photoUrl: photoUrl);
  }
}

 END FILE: modules/features/profile/data/repositories/profile_write_repository_impl.dart 

Dentro de /domain:

Dentro de /entities:

------- FILE: modules/features/profile/domain/entities/user_profile.dart -------
class UserProfile {
  final String uid;
  final String? name;
  final String? cedula;
  final String? role; // "cliente" | "emprendedora" | "admin" | null
  final String? phone;
  final String? photoUrl;
  final String? photoPublicId; // para limpieza backend
  final String? addressLine;
  final DateTime? lastAccess;

  const UserProfile({
    required this.uid,
    this.name,
    this.cedula,
    this.role,
    this.phone,
    this.photoUrl,
    this.photoPublicId,
    this.addressLine,
    this.lastAccess,
  });

  // Helper para evitar repetir trim/nullable
  static bool _isBlank(String? v) => v == null || v.trim().isEmpty;

  List<String> missingFields() {
    final missing = <String>[];
    final req = profileRequirementsForRole(role);

    if (req.requirePhoto && _isBlank(photoUrl)) {
      missing.add('Agrega una foto');
    }
    if (req.requireName && _isBlank(name)) {
      missing.add('A\u00f1ade tu nombre');
    }
    if (req.requireCedula && _isBlank(cedula)) {
      missing.add('A\u00f1ade tu c\u00e9dula');
    }
    if (req.requirePhone && _isBlank(phone)) {
      missing.add('A\u00f1ade tu tel\u00e9fono');
    }
    if (req.requireAddress && _isBlank(addressLine)) {
      missing.add('A\u00f1ade una direcci\u00f3n');
    }

    return missing;
  }

  int completedCount() {
    final req = profileRequirementsForRole(role);
    return req.total - missingFields().length;
  }

  int totalCount() => profileRequirementsForRole(role).total;
}

class ProfileRequirements {
  final bool requirePhoto;
  final bool requireName;
  final bool requireCedula;
  final bool requirePhone;
  final bool requireAddress;

  const ProfileRequirements({
    required this.requirePhoto,
    required this.requireName,
    required this.requireCedula,
    required this.requirePhone,
    required this.requireAddress,
  });

  int get total =>
      [
        requirePhoto,
        requireName,
        requireCedula,
        requirePhone,
        requireAddress,
      ].where((v) => v).length;
}

ProfileRequirements profileRequirementsForRole(String? role) {
  final normalized = (role ?? '').toLowerCase().trim();
  final isEntrepreneur =
      normalized == 'emprendedora' || normalized == 'entrepreneur';
  final isSuper = normalized == 'super';
  final isAdmin = normalized == 'admin';
  final noRole = normalized.isEmpty;

  return ProfileRequirements(
    requirePhoto: true,
    requireName: true,
    requireCedula: isEntrepreneur || noRole,
    requirePhone: isEntrepreneur || (isAdmin && !isSuper) || noRole,
    // Direccion opcional para cliente; requerida para emprendedora; opcional para admin/super.
    requireAddress: isEntrepreneur || noRole,
  );
}

----- END FILE: modules/features/profile/domain/entities/user_profile.dart -----

Dentro de /repositories:

 FILE: modules/features/profile/domain/repositories/profile_read_repository.dart 
import '../entities/user_profile.dart';

abstract class ProfileRepository {
  Stream<UserProfile?> watchProfile(String uid);
}

 END FILE: modules/features/profile/domain/repositories/profile_read_repository.dart 

 FILE: modules/features/profile/domain/repositories/profile_write_repository.dart 
abstract class ProfileWriteRepository {
  /// Devuelve un snapshot (mapa) simple del perfil actual (lectura Ãºnica).
  Future<Map<String, dynamic>?> fetchProfileOnce(String uid);

  /// Aplica el patch al perfil del usuario.
  Future<void> updateProfile({
    required String uid,
    required Map<String, dynamic> patch,
  });

  /// Sincroniza displayName / photoURL en Firebase Auth (si cambian).
  Future<void> syncAuth({
    required String uid,
    String? displayName,
    String? photoUrl,
  });
}

 END FILE: modules/features/profile/domain/repositories/profile_write_repository.dart 

Dentro de /usecases:

---- FILE: modules/features/profile/domain/usecases/update_user_profile.dart ---
import '../repositories/profile_write_repository.dart';

class UpdateUserProfile {
  final ProfileWriteRepository repo;
  UpdateUserProfile(this.repo);

  Future<void> call({
    required String uid,
    required Map<String, dynamic> patch,
    String? authDisplayName,
    String? authPhotoUrl,
  }) async {
    await repo.updateProfile(uid: uid, patch: patch);
    await repo.syncAuth(
      uid: uid,
      displayName: authDisplayName,
      photoUrl: authPhotoUrl,
    );
  }
}

-- END FILE: modules/features/profile/domain/usecases/update_user_profile.dart -

----- FILE: modules/features/profile/domain/usecases/watch_user_stream.dart ----
import '../entities/user_profile.dart';
import '../repositories/profile_read_repository.dart';

class WatchUserProfile {
  final ProfileRepository repository;
  WatchUserProfile(this.repository);

  Stream<UserProfile?> call(String uid) => repository.watchProfile(uid);
}

--- END FILE: modules/features/profile/domain/usecases/watch_user_stream.dart --

Dentro de /presentation:

Dentro de /blocs:

-- FILE: modules/features/profile/presentation/blocs/profile_editor_cubit.dart -
// lib/modules/features/profile/presentation/blocs/profile_editor_cubit.dart
import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/services/storage/i_file_storage_service.dart';
import '../../../../core/services/storage/cloudinary_storage_service.dart';
import '../../../../core/services/storage/firebase_storage_service.dart'
    as fbstore;
import '../../../../core/services/storage/cloudinary_maintenance_api.dart';
import '../../../../core/config/storage_flags.dart';
import '../../../../core/config/storage_config.dart';
import '../../../../core/utils/data/image_bytes.dart';
import '../../../../core/utils/validation/validators.dart';
import '../../../../core/utils/validation/phone_normalizer.dart';
import '../../../../core/utils/errors/firebase_errors.dart';
import '../../domain/entities/user_profile.dart';
import '../../domain/usecases/update_user_profile.dart';
import '../../domain/repositories/profile_write_repository.dart';

class ProfileEditState {
  final bool loading;
  final bool saving;
  final bool dirty;

  final String uid;
  final String? role;
  final String? name;
  final String? phone; // lo que escribe el usuario (9XXXXXXXX u 09XXXXXXXX)
  final String? address;
  final String? photoUrl;
  final String? photoPublicId;

  final Uint8List? pickedImage;
  final String? pickedMime;

  final String? error;
  final Map<String, String?> fieldErrors;

  ProfileEditState({
    required this.uid,
    this.role,
    this.loading = false,
    this.saving = false,
    this.dirty = false,
    this.name,
    this.phone,
    this.address,
    this.photoUrl,
    this.photoPublicId,
    this.pickedImage,
    this.pickedMime,
    this.error,
    this.fieldErrors = const {},
  });

  ProfileEditState copyWith({
    bool? loading,
    bool? saving,
    bool? dirty,
    String? role,
    String? name,
    String? phone,
    String? address,
    String? photoUrl,
    String? photoPublicId,
    Uint8List? pickedImage,
    String? pickedMime,
    String? error,
    Map<String, String?>? fieldErrors,
  }) {
    return ProfileEditState(
      uid: uid,
      role: role ?? this.role,
      loading: loading ?? this.loading,
      saving: saving ?? this.saving,
      dirty: dirty ?? this.dirty,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      photoUrl: photoUrl ?? this.photoUrl,
      photoPublicId: photoPublicId ?? this.photoPublicId,
      pickedImage: pickedImage ?? this.pickedImage,
      pickedMime: pickedMime ?? this.pickedMime,
      error: error,
      fieldErrors: fieldErrors ?? this.fieldErrors,
    );
  }
}

class ProfileEditCubit extends Cubit<ProfileEditState> {
  final UpdateUserProfile _update;
  final ProfileWriteRepository _repo;
  final IFileStorageService _cloudinary;
  final fbstore.FirebaseStorageService? _firebaseFallback;
  final CloudinaryMaintenanceApi _maintenance;

  ProfileEditCubit({
    required String uid,
    required UpdateUserProfile update,
    required ProfileWriteRepository repo,
    IFileStorageService? cloudinary,
    fbstore.FirebaseStorageService? firebaseFallback,
    CloudinaryMaintenanceApi? maintenance,
  }) : _update = update,
       _repo = repo,
       _cloudinary = cloudinary ?? CloudinaryStorageService(),
       _firebaseFallback =
           StorageFlags.enableFirebaseFallback
               ? (firebaseFallback ?? fbstore.FirebaseStorageService())
               : null,
       _maintenance = maintenance ?? CloudinaryMaintenanceApi(),
       super(ProfileEditState(uid: uid, loading: true));

  Future<void> bootstrap() async {
    emit(state.copyWith(loading: true, error: null));
    try {
      final map = await _repo.fetchProfileOnce(state.uid) ?? {};
      emit(
        state.copyWith(
          loading: false,
          role: (map['role'] ?? '').toString(),
          name: (map['name'] ?? '').toString(),
          phone: (map['phone'] ?? '').toString(),
          address: (map['addressLine'] ?? '').toString(),
          photoUrl: (map['photoUrl'] ?? '').toString(),
          photoPublicId: (map['photoPublicId'] ?? '').toString(),
          dirty: false,
        ),
      );
    } catch (e, st) {
      if (kDebugMode) {
        debugPrint('bootstrap() error: $e\n$st');
      }
      emit(
        state.copyWith(loading: false, error: 'No se pudo cargar el perfil'),
      );
    }
  }

  void setName(String v) => emit(
    state.copyWith(
      name: v,
      dirty: true,
      fieldErrors: {...state.fieldErrors, 'name': null},
    ),
  );

  void setPhone(String v) => emit(
    state.copyWith(
      phone: v,
      dirty: true,
      fieldErrors: {...state.fieldErrors, 'phone': null},
    ),
  );

  void setAddress(String v) => emit(
    state.copyWith(
      address: v,
      dirty: true,
      fieldErrors: {...state.fieldErrors, 'address': null},
    ),
  );

  void setPickedImage(Uint8List bytes, {String? fileName}) {
    final ct =
        ImageBytesHelper.sniffContentType(bytes, fallbackName: fileName) ??
        'application/octet-stream';
    emit(
      state.copyWith(
        pickedImage: bytes,
        pickedMime: ct,
        dirty: true,
        error: null,
      ),
    );
  }

  bool get hasUnsavedChanges => state.dirty;

  Map<String, String?> _validate() {
    final errs = <String, String?>{};
    final reqs = profileRequirementsForRole(state.role);

    String? validateField({
      required bool requiredField,
      required String? value,
      required String? Function(String?) validator,
    }) {
      if (!requiredField && (value == null || value.trim().isEmpty)) {
        return null;
      }
      return validator(value);
    }

    final nameErr = validateField(
      requiredField: reqs.requireName,
      value: state.name,
      validator: (v) => AppValidators.personName(v, min: 2, max: 60),
    );
    if (nameErr != null) errs['name'] = nameErr;

    final addrErr = validateField(
      requiredField: reqs.requireAddress,
      value: state.address,
      validator: (v) => AppValidators.addressLine(v, min: 5, max: 120),
    );
    if (addrErr != null) errs['address'] = addrErr;

    final phoneErr = validateField(
      requiredField: reqs.requirePhone,
      value: state.phone,
      validator: AppValidators.ecMobilePhone,
    );
    if (phoneErr != null) errs['phone'] = phoneErr;

    final p = state.pickedImage;
    if (p != null) {
      if (p.length > StorageConfig.maxFileBytes) {
        errs['photo'] =
            'La imagen supera ${StorageConfig.maxFileBytes ~/ (1024 * 1024)} MB';
      } else if (!StorageConfig.allowedMime.contains(state.pickedMime)) {
        errs['photo'] = 'Tipo de archivo no permitido';
      }
    }
    return errs;
  }

  Future<void> save() async {
    final errs = _validate();
    if (errs.isNotEmpty) {
      emit(state.copyWith(fieldErrors: errs));
      return;
    }

    emit(state.copyWith(saving: true, error: null));

    String? photoUrl = state.photoUrl;
    String? newPublicId;
    final oldPublicId = state.photoPublicId;
    final picked = state.pickedImage;

    try {
      // 1) Subir imagen si hay
      if (picked != null) {
        final ct = state.pickedMime ?? 'image/jpeg';
        final fileName = ImageBytesHelper.buildFileName(
          uid: state.uid,
          base: 'profile',
          contentType: ct,
        );
        final userFolder = 'app100mt/users/${state.uid}/profile';

        try {
          final up = await _cloudinary.uploadBytes(
            bytes: picked,
            fileName: fileName,
            contentType: ct,
            folder: userFolder,
          );
          photoUrl = up.url;
          newPublicId = up.publicId;
        } catch (e, st) {
          if (kDebugMode) debugPrint('Cloudinary upload failed: $e\n$st');
          final fb = _firebaseFallback;
          if (fb != null) {
            final up = await fb.uploadBytes(
              bytes: picked,
              fileName: fileName,
              contentType: ct,
              folder: userFolder,
            );
            photoUrl = up.url;
            newPublicId = null; // N/A
          } else {
            throw Exception(
              e.toString().contains('upload_preset')
                  ? 'Cloudinary: upload_preset invÃ¡lido o no UNSIGNED.'
                  : 'Fallo al subir la imagen. $e',
            );
          }
        }
      }

      // 2) Normalizar telÃ©fono a E.164 (+5939XXXXXXXX)
      final phoneE164 = PhoneNormalizerEC.toE164(state.phone ?? '');

      // 3) Patch Firestore + Auth
      final patch = <String, dynamic>{
        if ((state.name ?? '').trim().isNotEmpty) 'name': state.name!.trim(),
        if ((state.phone ?? '').trim().isNotEmpty) 'phone': state.phone!.trim(),
        'phoneE164': phoneE164 ?? '',
        if ((state.address ?? '').trim().isNotEmpty)
          'addressLine': state.address!.trim(),
        if (photoUrl != null && photoUrl.isNotEmpty) 'photoUrl': photoUrl,
        if (newPublicId != null && newPublicId.isNotEmpty)
          'photoPublicId': newPublicId,
      };

      await _update(
        uid: state.uid,
        patch: patch,
        authDisplayName:
            state.name?.trim().isNotEmpty == true ? state.name!.trim() : null,
        authPhotoUrl: photoUrl,
      );

      // 4) Ãxito
      emit(
        state.copyWith(
          saving: false,
          dirty: false,
          photoUrl: photoUrl,
          photoPublicId: newPublicId ?? state.photoPublicId,
          pickedImage: null,
          pickedMime: null,
        ),
      );

      // 5) Limpieza Cloudinary (best-effort)
      try {
        if (newPublicId != null && newPublicId.isNotEmpty) {
          await _maintenance.pruneUserProfileImages(uid: state.uid, keep: 1);
        } else if (oldPublicId != null && oldPublicId.isNotEmpty) {
          await _maintenance.deleteByPublicId(oldPublicId);
        }
      } catch (e, st) {
        if (kDebugMode) debugPrint('Cloudinary prune/delete error: $e\n$st');
      }
    } catch (e, st) {
      if (kDebugMode) debugPrint('save() failed: $e\n$st');
      final human = FirebaseErrorMapper.friendly(
        e,
        generic:
            e.toString().contains('Cloudinary')
                ? e.toString()
                : 'No se pudo guardar los cambios',
      );
      emit(state.copyWith(saving: false, error: human));
    }
  }
}

 END FILE: modules/features/profile/presentation/blocs/profile_editor_cubit.dart 

- FILE: modules/features/profile/presentation/blocs/profile_overview_cubit.dart 
import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../domain/entities/user_profile.dart';
import '../../domain/usecases/watch_user_stream.dart';
import '../../../../core/services/storage/session_storage.dart';

sealed class ProfileState {}
class ProfileLoading extends ProfileState {}
class ProfileGuest extends ProfileState {}          // sin uid/session
class ProfileEmpty extends ProfileState {}          // sin doc
class ProfileLoaded extends ProfileState {
  final UserProfile profile;
  final int completed;
  final int total;
  final List<String> missing;
  ProfileLoaded(this.profile)
      : completed = profile.completedCount(),
        total = profile.totalCount(),
        missing = profile.missingFields();
}
class ProfileError extends ProfileState {
  final String message;
  ProfileError(this.message);
}

class ProfileCubit extends Cubit<ProfileState> {
  final WatchUserProfile _watch;
  final SessionStorage? _sessionStorage;
  StreamSubscription? _sub;
  String? _currentUid;

  ProfileCubit(this._watch, {SessionStorage? sessionStorage})
      : _sessionStorage = sessionStorage,
        super(ProfileLoading());

  /// uid==null => invitado
  void watch(String? uid) {
    _sub?.cancel();
    if (uid == null || uid.isEmpty) {
      emit(ProfileGuest());
      if (_currentUid != null) {
        _sessionStorage?.clearRole(_currentUid!);
        _currentUid = null;
      }
      return;
    }
    _currentUid = uid;
    emit(ProfileLoading());
    _sub = _watch(uid).listen((p) {
      if (isClosed) return;
      if (p == null) {
        emit(ProfileEmpty());
      } else {
        _sessionStorage?.storeRole(uid, p.role);
        emit(ProfileLoaded(p));
      }
    }, onError: (e) {
      if (!isClosed) emit(ProfileError(e.toString()));
    });
  }

  @override
  Future<void> close() {
    _sub?.cancel();
    return super.close();
  }
}

 END FILE: modules/features/profile/presentation/blocs/profile_overview_cubit.dart 

Dentro de /pages:

------- FILE: modules/features/profile/presentation/pages/legal_page.dart ------
import 'package:flutter/material.dart';

class LegalPage extends StatelessWidget {
  const LegalPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('InformaciÃ³n legal')),
      body: const Center(child: Text('TÃ©rminos y privacidad (pendiente)')),
    );
  }
}

----- END FILE: modules/features/profile/presentation/pages/legal_page.dart ----

--- FILE: modules/features/profile/presentation/pages/notifications_page.dart --
import 'package:flutter/material.dart';

class NotificationsPage extends StatelessWidget {
  const NotificationsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Notificaciones')),
      body: const Center(child: Text('Preferencias de notificaciÃ³n (pendiente)')),
    );
  }
}

- END FILE: modules/features/profile/presentation/pages/notifications_page.dart 

-- FILE: modules/features/profile/presentation/pages/profile_account_page.dart -
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';

import 'package:flutter_application_emprendedoras/modules/core/config/app_routes.dart';
import 'package:flutter_application_emprendedoras/modules/core/config/app_theme.dart';
import 'package:flutter_application_emprendedoras/modules/features/auth/domain/role_utils.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/domain/entities/user_profile.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/blocs/profile_overview_cubit.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/utils/logout_helper.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/primary_action_button.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/profile_completion_card.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/profile_header.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/profile_info_row.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/profile_info_section.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/profile_logout_tile.dart';
import 'package:flutter_application_emprendedoras/modules/features/profile/presentation/widgets/profile_settings_section.dart';
import '../../profile_routes.dart';

class ProfileAccountPage extends StatefulWidget {
  const ProfileAccountPage({super.key});

  @override
  State<ProfileAccountPage> createState() => _ProfileAccountPageState();
}

class _ProfileAccountPageState extends State<ProfileAccountPage> {
  bool _isNavigating = false;
  bool _forceWelcomeOnBack = false;
  bool _isLoggingOut = false;

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: !_forceWelcomeOnBack,
      onPopInvokedWithResult: (didPop, _) {
        if (didPop || !_forceWelcomeOnBack) return;
        Navigator.pushNamedAndRemoveUntil(
          context,
          AppRoutes.welcome,
          (_) => false,
        );
      },
      child: Scaffold(
        appBar: AppBar(title: const Text('Cuenta')),
        backgroundColor: AppTheme.lightBg,
        body: BlocConsumer<ProfileCubit, ProfileState>(
          listener: (context, state) {
            if (_isNavigating || _isLoggingOut) return;
            if (state is ProfileGuest || state is ProfileEmpty) {
              _isNavigating = true;
              _forceWelcomeOnBack = true;
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (!mounted) return;
                Navigator.pushNamedAndRemoveUntil(
                  context,
                  AppRoutes.welcome,
                  (_) => false,
                );
              });
            } else {
              _forceWelcomeOnBack = false;
            }
          },
          builder: (context, state) {
            if (_isLoggingOut) {
              // MantÃ©n la pantalla "vacÃ­a" mientras el overlay estÃ¡ activo.
              return const SizedBox.shrink();
            }
            if (state is ProfileLoading) {
              return const Center(child: CircularProgressIndicator());
            }
            if (state is ProfileGuest) return const _GuestView();
            if (state is ProfileError) return _ErrorView(message: state.message);
            if (state is ProfileEmpty) return const _EmptyView();

            final loaded = state as ProfileLoaded;
            final authUser = FirebaseAuth.instance.currentUser;
            final email = authUser?.email;
            final lastLogin = authUser?.metadata.lastSignInTime;
            final isAdmin = isAdminRole(loaded.profile.role);
            return isAdmin
                ? _AdminAccountView(
                    profile: loaded.profile,
                    email: email,
                    lastLogin: lastLogin,
                    onConfirmLogout: _showLogoutFlow,
                  )
                : _DefaultAccountView(
                    state: loaded,
                    authEmail: email,
                    lastLogin: lastLogin,
                  );
          },
        ),
      ),
    );
  }

  Future<void> _showLogoutFlow(BuildContext context) async {
    if (_isLoggingOut) return;
    final navigator = Navigator.of(context, rootNavigator: true);
    setState(() => _isLoggingOut = true);

    final confirm = await showDialog<bool>(
      context: navigator.context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Cerrar sesiÃ³n'),
        content: const Text('Â¿Deseas cerrar la sesiÃ³n en este dispositivo?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            child: const Text('Cancelar'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            child: const Text('Cerrar sesiÃ³n'),
          ),
        ],
      ),
    );

    if (confirm != true) {
      if (mounted) {
        setState(() => _isLoggingOut = false);
      } else {
        _isLoggingOut = false;
      }
      return;
    }

    if (!mounted) {
      _isLoggingOut = false;
      return;
    }

    _isNavigating = true;
    showDialog(
      context: navigator.context,
      barrierDismissible: false,
      barrierColor: Colors.black.withValues(alpha: 0.35),
      builder: (_) => const _LoggingOutDialog(),
    );

    await Future.delayed(const Duration(milliseconds: 400));
    if (!navigator.mounted || !mounted) {
      _isLoggingOut = false;
      return;
    }
    await performLogout(
      navigator.context,
      navigate: false,
    );

    if (!mounted) {
      _isLoggingOut = false;
      return;
    }

    // Cierra el diÃ¡logo si sigue abierto.
    if (navigator.canPop()) {
      navigator.pop();
    }

    navigator.pushNamedAndRemoveUntil(
      AppRoutes.welcome,
      (_) => false,
    );

    if (mounted) {
      setState(() => _isLoggingOut = false);
    } else {
      _isLoggingOut = false;
    }
  }
}

class _AdminAccountView extends StatelessWidget {
  final UserProfile profile;
  final String? email;
  final DateTime? lastLogin;
  final Future<void> Function(BuildContext context) onConfirmLogout;
  const _AdminAccountView({
    required this.profile,
    this.email,
    this.lastLogin,
    required this.onConfirmLogout,
  });

  @override
  Widget build(BuildContext context) {
    final resolvedEmail =
        (email != null && email!.trim().isNotEmpty) ? email!.trim() : 'Sin correo';
    final sessionDate = profile.lastAccess ?? lastLogin;

    return ListView(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 120),
      children: [
        const Text(
          'InformaciÃ³n de la cuenta',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.w800),
        ),
        const SizedBox(height: 12),
        _AccountCard(
          profile: profile,
          email: resolvedEmail,
          lastLogin: sessionDate,
        ),
        const SizedBox(height: 16),
        _SessionSecurityCard(lastLogin: sessionDate),
        const SizedBox(height: 16),
        PrimaryActionButton(
          label: 'Cerrar sesiÃ³n en este dispositivo',
          icon: Icons.logout_rounded,
          destructive: true,
          onPressed: () => onConfirmLogout(context),
        ),
      ],
    );
  }
}

class _AccountCard extends StatelessWidget {
  final UserProfile profile;
  final String email;
  final DateTime? lastLogin;

  const _AccountCard({
    required this.profile,
    required this.email,
    required this.lastLogin,
  });

  @override
  Widget build(BuildContext context) {
    final hasPhoto = (profile.photoUrl ?? '').trim().isNotEmpty;
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ListTile(
            leading: CircleAvatar(
              radius: 28,
              backgroundColor: Colors.grey.shade200,
              backgroundImage:
                  hasPhoto ? NetworkImage(profile.photoUrl!) : null,
              child: hasPhoto
                  ? null
                  : const Icon(Icons.person, color: AppTheme.purpleDark),
            ),
            title: Text(
              profile.name?.isNotEmpty == true ? profile.name! : 'Cuenta admin',
              style: const TextStyle(
                fontWeight: FontWeight.w800,
                fontSize: 18,
              ),
            ),
            subtitle: Text(email),
            trailing: _RolePill(role: profile.role),
          ),
          const Divider(height: 1),
          InfoRow(
            icon: Icons.badge_outlined,
            label: 'CÃ©dula',
            value: profile.cedula,
          ),
          InfoRow(
            icon: Icons.phone_outlined,
            label: 'TelÃ©fono',
            value: profile.phone,
          ),
          InfoRow(
            icon: Icons.place_outlined,
            label: 'DirecciÃ³n',
            value: profile.addressLine,
          ),
          InfoRow(
            icon: Icons.lock_clock_outlined,
            label: 'Ãltimo acceso',
            value: _formatDateTime(lastLogin),
          ),
        ],
      ),
    );
  }
}

class _SessionSecurityCard extends StatelessWidget {
  final DateTime? lastLogin;
  const _SessionSecurityCard({required this.lastLogin});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      child: Column(
        children: [
          const ListTile(
            title: Text(
              'Seguridad de la sesiÃ³n',
              style: TextStyle(fontWeight: FontWeight.w700),
            ),
          ),
          const Divider(height: 1),
          ListTile(
            leading: const Icon(
              Icons.phone_iphone_outlined,
              color: AppTheme.purpleDark,
            ),
            title: const Text('Este dispositivo'),
            subtitle: Text(
              lastLogin != null
                  ? 'SesiÃ³n iniciada: ${_formatDateTime(lastLogin)}'
                  : 'SesiÃ³n activa en este telÃ©fono',
            ),
            trailing: const Text(
              'Actual',
              style: TextStyle(fontWeight: FontWeight.w700),
            ),
          ),
          const Divider(height: 1),
          ListTile(
            leading: const Icon(
              Icons.devices_other_outlined,
              color: AppTheme.purpleDark,
            ),
            title: const Text('Otros dispositivos'),
            subtitle: const Text(
              'Gestiona sesiones adicionales desde la web o soporte',
            ),
            trailing: const Icon(Icons.chevron_right),
            onTap: () => ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text(
                  'Para cerrar sesiones remotas contÃ¡ctanos por soporte.',
                ),
                behavior: SnackBarBehavior.floating,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _LoggingOutDialog extends StatelessWidget {
  const _LoggingOutDialog();

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Card(
        elevation: 8,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.all(Radius.circular(14)),
        ),
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 18),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(strokeWidth: 3),
              SizedBox(width: 12),
              Text('Cerrando sesiÃ³n...'),
            ],
          ),
        ),
      ),
    );
  }
}

class _RolePill extends StatelessWidget {
  final String? role;
  const _RolePill({this.role});

  @override
  Widget build(BuildContext context) {
    if (role == null || role!.trim().isEmpty) return const SizedBox.shrink();
    final trimmed = role!.trim();
    final display =
        trimmed.length <= 1 ? trimmed.toUpperCase() : '${trimmed[0].toUpperCase()}${trimmed.substring(1)}';
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: AppTheme.purpleDark.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        display,
        style: const TextStyle(
          color: AppTheme.purpleDark,
          fontWeight: FontWeight.w700,
        ),
      ),
    );
  }
}

class _DefaultAccountView extends StatelessWidget {
  final ProfileLoaded state;
  final String? authEmail;
  final DateTime? lastLogin;
  const _DefaultAccountView({
    required this.state,
    this.authEmail,
    this.lastLogin,
  });

  @override
  Widget build(BuildContext context) {
    final p = state.profile;
    final sessionDate = p.lastAccess ?? lastLogin;
    return ListView(
      padding: const EdgeInsets.fromLTRB(0, 0, 0, 32),
      children: [
        ProfileHeader(
          displayName: (p.name?.isNotEmpty == true) ? p.name! : 'Usuario',
          role: p.role,
          photoUrl: p.photoUrl,
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: TextButton.icon(
            onPressed: () => Navigator.pushNamed(context, ProfileRoutes.edit),
            icon: const Icon(Icons.edit),
            label: const Text('Editar perfil'),
          ),
        ),
        if (state.missing.isNotEmpty)
          ProfileCompletionCard(
            completed: state.completed,
            total: state.total,
            missing: state.missing,
          ),
        ProfileInfoSection(
          role: p.role,
          email: authEmail,
          cedula: p.cedula,
          phone: p.phone,
          address: p.addressLine,
          lastAccess: _formatDateTime(sessionDate),
          onEdit: () => Navigator.pushNamed(context, ProfileRoutes.edit),
        ),
        SettingsSection(
          role: p.role,
          onNotifications: () => Navigator.pushNamed(
            context,
            ProfileRoutes.notifications,
          ),
          onLegal: () => Navigator.pushNamed(context, ProfileRoutes.legal),
        ),
        const LogoutTile(),
      ],
    );
  }
}

class _GuestView extends StatelessWidget {
  const _GuestView();
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.person_outline_rounded, size: 56),
            const SizedBox(height: 8),
            const Text(
              'Debes iniciar sesiÃ³n para ver tu cuenta.',
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            FilledButton(
              onPressed: () => Navigator.pushNamedAndRemoveUntil(
                context,
                AppRoutes.welcome,
                (_) => false,
              ),
              child: const Text('Ir a bienvenida'),
            ),
          ],
        ),
      ),
    );
  }
}

class _EmptyView extends StatelessWidget {
  const _EmptyView();
  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Padding(
        padding: EdgeInsets.all(24),
        child: Text('AÃºn no tenemos tus datos.'),
      ),
    );
  }
}

class _ErrorView extends StatelessWidget {
  final String message;
  const _ErrorView({required this.message});
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.warning_amber_rounded, size: 56),
            const SizedBox(height: 8),
            Text('No se pudo cargar el perfil:\n$message'),
          ],
        ),
      ),
    );
  }
}

String _formatDateTime(DateTime? value) {
  if (value == null) return 'Sin registro';
  final local = value.toLocal();
  return DateFormat('dd/MM/yyyy HH:mm').format(local);
}

 END FILE: modules/features/profile/presentation/pages/profile_account_page.dart 

--- FILE: modules/features/profile/presentation/pages/profile_edit_page.dart ---
// lib/modules/features/profile/presentation/pages/profile_edit_page.dart
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_theme.dart';
import '../../../../core/widgets/feedback/blocking_loader.dart';
import '../../../../core/widgets/layout/auto_scroll_on_focus.dart';
import '../blocs/profile_editor_cubit.dart';

// Picking + crop
import '../../../../core/services/media/i_image_source.dart';
import '../../../../core/services/media/image_picker_service.dart';
import '../widgets/editor/pick_image_sheet.dart';
import '../../../../core/widgets/media/avatar_cropper_page.dart';

// ComposiciÃ³n visual
import '../widgets/editor/profile_photo_editor.dart';
import '../widgets/editor/profile_section_card.dart';
import '../widgets/editor/profile_save_bar.dart';

// Inputs reutilizables
import '../../../../core/widgets/inputs/name_field.dart';
import '../../../../core/widgets/inputs/address_field.dart';
import '../../../../core/widgets/inputs/phone_ec_field.dart';

class EditProfilePage extends StatefulWidget {
  const EditProfilePage({super.key});

  @override
  State<EditProfilePage> createState() => _EditProfilePageState();
}

class _EditProfilePageState extends State<EditProfilePage> {
  final _nameCtrl = TextEditingController();
  final _phoneCtrl = TextEditingController();
  final _addrCtrl = TextEditingController();

  // ð FocusNodes para auto-scroll y control fino del foco
  final _nameNode = FocusNode();
  final _addrNode = FocusNode();
  final _phoneNode = FocusNode();

  final _scroll = ScrollController();

  @override
  void dispose() {
    _nameCtrl.dispose();
    _phoneCtrl.dispose();
    _addrCtrl.dispose();
    _nameNode.dispose();
    _addrNode.dispose();
    _phoneNode.dispose();
    _scroll.dispose();
    super.dispose();
  }

  Future<bool> _confirmDiscard(BuildContext context) async {
    final c = context.read<ProfileEditCubit>();
    if (!c.hasUnsavedChanges) return true;

    final ok = await showDialog<bool>(
      context: context,
      builder:
          (_) => AlertDialog(
            title: const Text('Descartar cambios'),
            content: const Text(
              'Tienes cambios sin guardar. Â¿Deseas descartarlos?',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text('Seguir editando'),
              ),
              FilledButton(
                onPressed: () => Navigator.pop(context, true),
                child: const Text('Descartar'),
              ),
            ],
          ),
    );
    return ok == true;
  }

  Future<void> _changePhoto(BuildContext context) async {
    final cubit = context.read<ProfileEditCubit>();
    final nav = Navigator.of(context);
    final picker = ImagePickerService();

    final AppImageSource? src = await PickImageSheet.show(context);
    if (src == null) return;

    final picked = await picker.pick(src);
    if (picked == null) return;

    final Uint8List? cropped = await nav.push<Uint8List>(
      MaterialPageRoute(
        fullscreenDialog: true,
        builder: (_) => AvatarCropperPage(originalBytes: picked.bytes),
      ),
    );
    if (cropped == null) return;

    cubit.setPickedImage(cropped, fileName: picked.fileName ?? 'avatar.jpg');
  }

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<ProfileEditCubit, ProfileEditState>(
      listenWhen: (p, c) => p.saving != c.saving || p.error != c.error,
      listener: (context, state) {
        if (!state.saving &&
            state.error == null &&
            !state.dirty &&
            !state.loading) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text('Perfil actualizado')));
          Navigator.pop(context);
        }
        if (state.error != null) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text(state.error!)));
        }
      },
      builder: (context, state) {
        if (state.loading) {
          return Scaffold(
            appBar: AppBar(title: const Text('Editar perfil')),
            body: const Center(child: CircularProgressIndicator()),
          );
        }

        // Sincroniza valores controladores (sin mover el cursor)
        if (_nameCtrl.text != (state.name ?? '')) {
          _nameCtrl.value = _nameCtrl.value.copyWith(text: state.name ?? '');
        }
        if (_phoneCtrl.text != (state.phone ?? '')) {
          _phoneCtrl.value = _phoneCtrl.value.copyWith(text: state.phone ?? '');
        }
        if (_addrCtrl.text != (state.address ?? '')) {
          _addrCtrl.value = _addrCtrl.value.copyWith(text: state.address ?? '');
        }

        final kbVisible = MediaQuery.viewInsetsOf(context).bottom > 0;
        final showSaveBar = !kbVisible; // ð ocultar barra con teclado abierto
        final listBottomPadding = showSaveBar ? 100.0 : 24.0;

        return PopScope(
          canPop: false,
          onPopInvokedWithResult: (didPop, _) async {
            if (didPop) return;
            final nav = Navigator.of(context);
            final discard = await _confirmDiscard(context);
            if (!discard) return;
            if (nav.mounted) nav.pop();
          },
          child: Scaffold(
            appBar: AppBar(title: const Text('Editar perfil')),
            body: Stack(
              children: [
                ListView(
                  controller: _scroll,
                  padding: EdgeInsets.fromLTRB(16, 12, 16, listBottomPadding),
                  // MantÃ©n el teclado abierto al scrollear
                  keyboardDismissBehavior:
                      ScrollViewKeyboardDismissBehavior.manual,
                  children: [
                    SectionCard(
                      title: 'Foto de perfil',
                      child: Row(
                        children: [
                          EditablePhoto(
                            photoUrl: state.photoUrl,
                            pickedPreview: state.pickedImage,
                            onChange: () => _changePhoto(context),
                            errorText: state.fieldErrors['photo'],
                          ),
                          const SizedBox(width: 12),
                          const Expanded(
                            child: Text(
                              // Copia breve y moderna
                              'Consejo: usa una imagen nÃ­tida, rostro centrado.',
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.black54,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 12),
                    SectionCard(
                      title: 'Datos bÃ¡sicos',
                      child: Column(
                        children: [
                          AutoScrollOnFocus(
                            focusNode: _nameNode,
                            child: NameField(
                              controller: _nameCtrl,
                              focusNode: _nameNode,
                              errorText: state.fieldErrors['name'],
                              onChanged:
                                  context.read<ProfileEditCubit>().setName,
                              textInputAction: TextInputAction.next,
                            ),
                          ),
                          const SizedBox(height: 10),
                          AutoScrollOnFocus(
                            focusNode: _addrNode,
                            child: AddressField(
                              controller: _addrCtrl,
                              focusNode: _addrNode,
                              errorText: state.fieldErrors['address'],
                              onChanged:
                                  context.read<ProfileEditCubit>().setAddress,
                              textInputAction: TextInputAction.next,
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 12),
                    SectionCard(
                      title: 'Contacto',
                      child: Column(
                        children: [
                          AutoScrollOnFocus(
                            focusNode: _phoneNode,
                            child: PhoneEcField(
                              controller: _phoneCtrl,
                              focusNode: _phoneNode,
                              errorText: state.fieldErrors['phone'],
                              onChanged:
                                  context.read<ProfileEditCubit>().setPhone,
                              textInputAction: TextInputAction.done,
                            ),
                          ),
                          const SizedBox(height: 6),
                          Row(
                            children: const [
                              Icon(
                                Icons.info_outline,
                                size: 16,
                                color: AppTheme.purpleDark,
                              ),
                              SizedBox(width: 6),
                              Expanded(
                                child: Text(
                                  'Tu correo no se edita aquÃ­ (requiere re-autenticaciÃ³n).',
                                  style: TextStyle(
                                    color: Colors.black54,
                                    fontSize: 12,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ],
                ),

                // Barra guardar/cancelar (oculta con teclado)
                if (showSaveBar)
                  Align(
                    alignment: Alignment.bottomCenter,
                    child: SaveBar(
                      primaryText: 'Guardar cambios',
                      onPrimary: context.read<ProfileEditCubit>().save,
                      onSecondary: () async {
                        final nav = Navigator.of(context);
                        if (await _confirmDiscard(context)) {
                          if (nav.mounted) nav.pop();
                        }
                      },
                      secondaryText: 'Cancelar',
                      enabled: !state.saving,
                    ),
                  ),

                if (state.saving) const BlockingLoader(),
              ],
            ),
          ),
        );
      },
    );
  }
}

- END FILE: modules/features/profile/presentation/pages/profile_edit_page.dart -

Dentro de /tabs:

 FILE: modules/features/profile/presentation/pages/tabs/profile_overview_tab.dart 
// lib/modules/features/profile/presentation/pages/tabs/profile_tab.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../../../../../core/config/app_theme.dart';
import '../../../../../core/config/app_routes.dart';
import '../../../../../core/services/storage/session_storage.dart';

import '../../blocs/profile_overview_cubit.dart';
import '../../widgets/profile_header.dart';
import '../../widgets/profile_completion_card.dart';
import '../../widgets/profile_info_section.dart';
import '../../widgets/profile_settings_section.dart';
import '../../widgets/profile_logout_tile.dart';
// <- rutas del feature
import '../../../profile_routes.dart';

class ProfileTab extends StatelessWidget {
  const ProfileTab({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: ColoredBox(
        color: AppTheme.white,
        child: BlocBuilder<ProfileCubit, ProfileState>(
          builder: (context, state) {
            if (state is ProfileLoading) return const _Loading();
            if (state is ProfileGuest) return const _Guest();
            if (state is ProfileError) return _Error(message: state.message);
            if (state is ProfileEmpty) return const _Empty();

            final s = state as ProfileLoaded;
            return CustomScrollView(
              slivers: [
                SliverToBoxAdapter(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      ProfileHeader(
                        displayName: (s.profile.name?.isNotEmpty == true)
                            ? s.profile.name!
                            : 'Usuario',
                        role: s.profile.role,
                        photoUrl: s.profile.photoUrl,
                      ),

                      // BotÃ³n Editar
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: TextButton.icon(
                          onPressed: () =>
                              Navigator.pushNamed(context, ProfileRoutes.edit),
                          icon: const Icon(Icons.edit),
                          label: const Text('Editar perfil'),
                        ),
                      ),

                      if (s.missing.isNotEmpty)
                        ProfileCompletionCard(
                          completed: s.completed,
                          total: s.total,
                          missing: s.missing,
                        ),

                      // Tocar cualquier fila te lleva a editar
                      ProfileInfoSection(
                        role: s.profile.role,
                        cedula: s.profile.cedula,
                        phone: s.profile.phone,
                        address: s.profile.addressLine,
                        onEdit: () =>
                            Navigator.pushNamed(context, ProfileRoutes.edit),
                      ),

                      SettingsSection(
                        role: s.profile.role,
                        onNotifications: () =>
                            Navigator.pushNamed(context, ProfileRoutes.notifications),
                        onLegal: () =>
                            Navigator.pushNamed(context, ProfileRoutes.legal),
                      ),
                      const LogoutTile(),
                    ],
                  ),
                ),
                const SliverToBoxAdapter(child: SizedBox(height: 16)),
              ],
            );
          },
        ),
      ),
    );
  }
}

class _Loading extends StatelessWidget {
  const _Loading();
  @override
  Widget build(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        Row(children: [
          CircleAvatar(radius: 32, backgroundColor: Colors.grey.shade200),
          const SizedBox(width: 12),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(width: 160, height: 14, color: Colors.grey.shade200),
              const SizedBox(height: 8),
              Container(width: 80, height: 12, color: Colors.grey.shade100),
            ],
          ),
        ]),
        const SizedBox(height: 16),
        Container(height: 90, color: Colors.grey.shade100),
        const SizedBox(height: 12),
        Container(height: 180, color: Colors.grey.shade100),
      ],
    );
  }
}

class _Guest extends StatelessWidget {
  const _Guest();
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.person_outline_rounded, size: 56),
            const SizedBox(height: 8),
            const Text(
              'Debes iniciar sesiÃ³n para ver tu perfil.',
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: () async {
                  // Si estÃ¡s en sesiÃ³n anÃ³nima (visitante), salimos primero
                  final user = FirebaseAuth.instance.currentUser;
                  if (user != null && user.isAnonymous) {
                      final uid = user.uid;
                    await FirebaseAuth.instance.signOut();
                    if (context.mounted) {
                      await context.read<SessionStorage>().clearRole(uid);
                    }
                  }
                  if (!context.mounted) return;

                  // Vamos a la pantalla de bienvenida y limpiamos la pila
                  Navigator.pushNamedAndRemoveUntil(
                    context,
                    AppRoutes.welcome,
                    (_) => false,
                  );
                },
                child: const Text('Crear cuenta o iniciar sesiÃ³n'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _Empty extends StatelessWidget {
  const _Empty();
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(mainAxisSize: MainAxisSize.min, children: const [
          Icon(Icons.info_outline_rounded, size: 56),
          SizedBox(height: 8),
          Text('AÃºn no tenemos tus datos.'),
        ]),
      ),
    );
  }
}

class _Error extends StatelessWidget {
  final String message;
  const _Error({required this.message});
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.warning_amber_rounded, size: 56, color: Colors.orange),
            const SizedBox(height: 8),
            Text('No se pudo cargar el perfil:\n$message', textAlign: TextAlign.center),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/profile/presentation/pages/tabs/profile_overview_tab.dart 

Dentro de /utils:

----- FILE: modules/features/profile/presentation/utils/logout_helper.dart -----
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/config/app_routes.dart';
import '../../../../core/services/storage/session_storage.dart';

/// Cierra la sesiÃ³n actual y limpia el rol guardado.
/// Si [navigate] es true, navega a la pantalla de bienvenida.
Future<void> performLogout(
  BuildContext context, {
  bool navigate = true,
}) async {
  final navigator = Navigator.of(context);
  final storage = context.read<SessionStorage>();

  final uid = FirebaseAuth.instance.currentUser?.uid;
  await FirebaseAuth.instance.signOut();
  if (uid != null) {
    await storage.clearRole(uid);
  }
  if (navigate && navigator.mounted) {
    navigator.pushNamedAndRemoveUntil(
      AppRoutes.welcome,
      (_) => false,
    );
  }
}

--- END FILE: modules/features/profile/presentation/utils/logout_helper.dart ---

Dentro de /widgets:

 FILE: modules/features/profile/presentation/widgets/primary_action_button.dart 
import 'package:flutter/material.dart';

import '../../../../core/config/app_theme.dart';

class PrimaryActionButton extends StatelessWidget {
  const PrimaryActionButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.destructive = false,
    this.icon,
  });

  final String label;
  final VoidCallback onPressed;
  final bool destructive;
  final IconData? icon;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final background = destructive ? Colors.red.shade600 : colorScheme.primary;
    final foreground = Colors.white;
    final labelWidget = Padding(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Text(
        label,
        style: const TextStyle(
          color: AppTheme.white,
          fontWeight: FontWeight.w700,
        ),
      ),
    );
    final style = FilledButton.styleFrom(
      backgroundColor: background,
      foregroundColor: foreground,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(14),
      ),
      textStyle: const TextStyle(fontSize: 16),
    );

    return SizedBox(
      width: double.infinity,
      child: icon != null
          ? FilledButton.icon(
              icon: Icon(icon, color: foreground),
              label: labelWidget,
              style: style,
              onPressed: onPressed,
            )
          : FilledButton(
              style: style,
              onPressed: onPressed,
              child: labelWidget,
            ),
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/primary_action_button.dart 

 FILE: modules/features/profile/presentation/widgets/profile_completion_card.dart 
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';

class ProfileCompletionCard extends StatelessWidget {
  final int completed;
  final int total;
  final List<String> missing;

  const ProfileCompletionCard({
    super.key,
    required this.completed,
    required this.total,
    required this.missing,
  });

  @override
  Widget build(BuildContext context) {
    final percent = total == 0 ? 0.0 : completed / total;
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Container(
        decoration: BoxDecoration(
          color: AppTheme.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
        ),
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(children: [
              const Icon(Icons.task_alt_rounded, color: AppTheme.purpleDark),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'Completa tu perfil â¢ $completed de $total',
                  style: const TextStyle(
                    color: AppTheme.black,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
            ]),
            const SizedBox(height: 10),
            ClipRRect(
              borderRadius: BorderRadius.circular(6),
              child: LinearProgressIndicator(
                value: percent,
                minHeight: 8,
                backgroundColor: Colors.grey.shade200,
                valueColor: const AlwaysStoppedAnimation(AppTheme.purpleDark),
              ),
            ),
            if (missing.isNotEmpty) ...[
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: missing.take(3).map((m) => _chip(m)).toList(),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _chip(String text) => Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        decoration: BoxDecoration(
          color: Colors.grey.shade100,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.black.withValues(alpha: .06)),
        ),
        child: Text(text, style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w600)),
      );
}

 END FILE: modules/features/profile/presentation/widgets/profile_completion_card.dart 

---- FILE: modules/features/profile/presentation/widgets/profile_header.dart ---
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';

class ProfileHeader extends StatelessWidget {
  final String displayName;
  final String? role;
  final String? photoUrl;

  const ProfileHeader({
    super.key,
    required this.displayName,
    this.role,
    this.photoUrl,
  });

  @override
  Widget build(BuildContext context) {
    ImageProvider? provider;
    if (photoUrl != null && photoUrl!.trim().isNotEmpty) {
      provider = CachedNetworkImageProvider(photoUrl!);
    }

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
      child: Row(
        children: [
          CircleAvatar(
            radius: 32,
            backgroundColor: Colors.grey.shade300,
            backgroundImage: provider,
            child:
                provider == null
                    ? const Icon(
                      Icons.person,
                      color: AppTheme.purpleDark,
                      size: 32,
                    )
                    : null,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Â¡Hola, $displayName!',
                  style: const TextStyle(
                    color: AppTheme.black,
                    fontSize: 20,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 6),
                if (role != null && role!.trim().isNotEmpty)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 10,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.grey.shade200,
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Text(
                      role!.substring(0, 1).toUpperCase() + role!.substring(1),
                      style: const TextStyle(
                        color: AppTheme.black,
                        fontWeight: FontWeight.w600,
                        fontSize: 12,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

-- END FILE: modules/features/profile/presentation/widgets/profile_header.dart -

--- FILE: modules/features/profile/presentation/widgets/profile_info_row.dart --
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';

class InfoRow extends StatelessWidget {
  final IconData icon;
  final String label;
  final String? value;
  final VoidCallback? onTap;

  const InfoRow({
    super.key,
    required this.icon,
    required this.label,
    this.value,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final hasValue = value != null && value!.trim().isNotEmpty;
    final displayValue = hasValue ? value!.trim() : '-';
    return ListTile(
      leading: Icon(icon, color: AppTheme.purpleDark),
      title: Text(label, style: const TextStyle(fontWeight: FontWeight.w600)),
      subtitle: Text(displayValue),
      trailing: onTap == null ? null : const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }
}

- END FILE: modules/features/profile/presentation/widgets/profile_info_row.dart 

- FILE: modules/features/profile/presentation/widgets/profile_info_section.dart 
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';
import 'profile_info_row.dart';

class ProfileInfoSection extends StatelessWidget {
  final String? role;
  final String? email;
  final String? cedula;
  final String? phone;
  final String? address;
  final String? lastAccess;

  /// Tap genÃ©rico para "editar".
  final VoidCallback? onEdit;

  const ProfileInfoSection({
    super.key,
    this.role,
    this.email,
    this.cedula,
    this.phone,
    this.address,
    this.lastAccess,
    this.onEdit,
  });

  @override
  Widget build(BuildContext context) {
    final normalizedRole = (role ?? '').toLowerCase().trim();
    final isClient = normalizedRole == 'cliente' || normalizedRole == 'client';
    final isEntrepreneur =
        normalizedRole == 'emprendedora' || normalizedRole == 'entrepreneur';
    final isAdmin = normalizedRole == 'admin';
    final isSuper = normalizedRole == 'super';

    final rows = <Widget>[];
    void addRow(Widget row) {
      if (rows.isNotEmpty) rows.add(const Divider(height: 1));
      rows.add(row);
    }

    final emailValue = (email ?? '').trim();
    if (emailValue.isNotEmpty) {
      addRow(
        InfoRow(
          icon: Icons.alternate_email_rounded,
          label: 'Correo',
          value: emailValue,
        ),
      );
    }

    final cedulaValue = (cedula ?? '').trim();
    final showCedula = !isClient || cedulaValue.isNotEmpty;
    if (showCedula) {
      addRow(
        InfoRow(
          icon: Icons.badge_outlined,
          label: 'C\u00e9dula',
          value: cedulaValue.isEmpty ? '-' : cedulaValue,
          onTap: onEdit,
        ),
      );
    }

    final phoneValue = (phone ?? '').trim();
    final showPhone = phoneValue.isNotEmpty ||
        !isClient ||
        isAdmin ||
        isSuper ||
        isEntrepreneur;
    if (showPhone) {
      addRow(
        InfoRow(
          icon: Icons.phone_outlined,
          label: 'Tel\u00e9fono',
          value: phoneValue.isEmpty ? '-' : phoneValue,
          onTap: onEdit,
        ),
      );
    }

    final addressValue = (address ?? '').trim();
    final showAddress = isEntrepreneur || isAdmin || isSuper || addressValue.isNotEmpty;
    if (showAddress) {
      addRow(
        InfoRow(
          icon: Icons.place_outlined,
          label: 'Direcci\u00f3n',
          value: addressValue.isEmpty ? '-' : addressValue,
          onTap: onEdit,
        ),
      );
    }

    final lastAccessValue = (lastAccess ?? '').trim();
    if (lastAccessValue.isNotEmpty) {
      addRow(
        InfoRow(
          icon: Icons.lock_clock_outlined,
          label: '\u00daltimo acceso',
          value: lastAccessValue,
        ),
      );
    }

    if (rows.isEmpty) {
      addRow(
        const InfoRow(
          icon: Icons.info_outline_rounded,
          label: 'Informaci\u00f3n',
          value: '-',
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Container(
        decoration: BoxDecoration(
          color: AppTheme.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
        ),
        child: Column(
          children: [
            const ListTile(
              title: Text(
                'Datos personales',
                style: TextStyle(
                  color: AppTheme.black,
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
            const Divider(height: 1),
            ...rows,
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/profile_info_section.dart 

- FILE: modules/features/profile/presentation/widgets/profile_logout_tile.dart -
// lib/modules/features/profile/presentation/widgets/logout_tile.dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../../core/config/app_theme.dart';
import '../utils/logout_helper.dart';

class LogoutTile extends StatelessWidget {
  const LogoutTile({super.key});

  @override
  Widget build(BuildContext context) {
    final isGuest = FirebaseAuth.instance.currentUser?.isAnonymous ?? false;
    final titleText = isGuest ? 'Volver al inicio' : 'Cerrar sesi\u00f3n';
    final contentText = isGuest
        ? '\u00bfQuieres volver a la pantalla de bienvenida?'
        : '\u00bfDeseas cerrar la sesi\u00f3n?';

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
      child: Container(
        decoration: BoxDecoration(
          color: AppTheme.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
        ),
        child: ListTile(
          leading: const Icon(Icons.logout_rounded, color: AppTheme.purpleDark),
          title: Text(
            titleText,
            style: const TextStyle(fontWeight: FontWeight.w700),
          ),
          onTap: () async {
            final confirm = await showDialog<bool>(
              context: context,
              builder: (dialogContext) => AlertDialog(
                title: Text(titleText),
                content: Text(contentText),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(dialogContext).pop(false),
                    child: const Text('Cancelar'),
                  ),
                  FilledButton(
                    onPressed: () => Navigator.of(dialogContext).pop(true),
                    child: Text(titleText),
                  ),
                ],
              ),
            );

            if (confirm != true) return;
            if (!context.mounted) return;

            await performLogout(context);
          },
        ),
      ),
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/profile_logout_tile.dart 

 FILE: modules/features/profile/presentation/widgets/profile_settings_section.dart 
import 'package:flutter/material.dart';
import '../../../../core/config/app_theme.dart';
import '../../../admin/admin_routes.dart';
import '../../../auth/domain/role_utils.dart';
import '../../../catalog/catalog_routes.dart';

class SettingsSection extends StatelessWidget {
  final VoidCallback onNotifications;
  final VoidCallback onLegal;

  /// Nuevo: rol para construir menÃº sin duplicar pantallas
  final String? role; // 'cliente' | 'emprendedora' | 'admin'

  const SettingsSection({
    super.key,
    required this.onNotifications,
    required this.onLegal,
    this.role,
  });

  bool get isAdmin => isAdminRole(role);
  bool get isSeller => (role ?? '').toLowerCase() == 'emprendedora';

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Container(
        decoration: BoxDecoration(
          color: AppTheme.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
        ),
        child: Column(
          children: [
            const ListTile(
              title: Text(
                'ConfiguraciÃ³n',
                style: TextStyle(
                  color: AppTheme.black,
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
            const Divider(height: 1),
            ListTile(
              leading: const Icon(
                Icons.notifications_outlined,
                color: AppTheme.purpleDark,
              ),
              title: const Text('Notificaciones'),
              onTap: onNotifications,
            ),
            ListTile(
              leading: const Icon(
                Icons.info_outline,
                color: AppTheme.purpleDark,
              ),
              title: const Text('InformaciÃ³n legal'),
              onTap: onLegal,
            ),
            if (isSeller) ...[
              const Divider(height: 1),
              ListTile(
                leading: const Icon(
                  Icons.storefront_outlined,
                  color: AppTheme.purpleDark,
                ),
                title: const Text('Mis productos'),
                subtitle: const Text('Acceso rÃ¡pido a tu catÃ¡logo'),
                onTap: () => Navigator.pushNamed(context, CatalogRoutes.home),
              ),
            ],
            if (isAdmin) ...[
              const Divider(height: 1),
              ListTile(
                leading: const Icon(
                  Icons.admin_panel_settings_outlined,
                  color: AppTheme.purpleDark,
                ),
                title: const Text('Panel de administraciÃ³n'),
                subtitle: const Text('Herramientas avanzadas'),
                onTap: () => Navigator.pushNamed(context, AdminRoutes.base),
              ),
            ],
            ListTile(
              leading: const Icon(
                Icons.devices_other_outlined,
                color: AppTheme.purpleDark,
              ),
              title: const Text('Cerrar sesiÃ³n en otros dispositivos'),
              subtitle: const Text('PrÃ³ximamente'),
              onTap: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text(
                      'Esta acciÃ³n requiere soporte del servidor (Admin SDK).',
                    ),
                    behavior: SnackBarBehavior.floating,
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/profile_settings_section.dart 

Dentro de /editor:

 FILE: modules/features/profile/presentation/widgets/editor/pick_image_sheet.dart 
import 'package:flutter/material.dart';
import '../../../../../core/services/media/i_image_source.dart';

/// Hoja inferior para elegir origen: cÃ¡mara o galerÃ­a.
class PickImageSheet extends StatelessWidget {
  const PickImageSheet({super.key});

  static Future<AppImageSource?> show(BuildContext context) {
    return showModalBottomSheet<AppImageSource>(
      context: context,
      showDragHandle: true,
      builder: (_) => const PickImageSheet(),
    );
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(mainAxisSize: MainAxisSize.min, children: [
        ListTile(
          leading: const Icon(Icons.photo_camera_outlined),
          title: const Text('Tomar foto'),
          onTap: () => Navigator.pop(context, AppImageSource.camera),
        ),
        ListTile(
          leading: const Icon(Icons.photo_library_outlined),
          title: const Text('Elegir de la galerÃ­a'),
          onTap: () => Navigator.pop(context, AppImageSource.gallery),
        ),
        const SizedBox(height: 8),
      ]),
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/editor/pick_image_sheet.dart 

 FILE: modules/features/profile/presentation/widgets/editor/profile_photo_editor.dart 
import 'dart:typed_data';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';

/// Muestra el avatar actual o el preview reciÃ©n elegido y un botÃ³n "Cambiar".
/// No sube ni recorta: solo visual y callback.
class EditablePhoto extends StatelessWidget {
  final String? photoUrl;
  final Uint8List? pickedPreview;
  final VoidCallback onChange;
  final String? errorText;

  const EditablePhoto({
    super.key,
    this.photoUrl,
    this.pickedPreview,
    required this.onChange,
    this.errorText,
  });

  @override
  Widget build(BuildContext context) {
    ImageProvider? provider;

    if (pickedPreview != null && pickedPreview!.isNotEmpty) {
      provider = MemoryImage(pickedPreview!);
    } else if (photoUrl != null && photoUrl!.trim().isNotEmpty) {
      provider = CachedNetworkImageProvider(photoUrl!);
    }

    final avatar = CircleAvatar(
      radius: 40,
      backgroundColor: Colors.grey.shade300,
      backgroundImage: provider,
      child:
          provider == null
              ? const Icon(Icons.person, color: AppTheme.purpleDark, size: 40)
              : null,
    );

    final button = TextButton.icon(
      onPressed: onChange,
      icon: const Icon(Icons.edit),
      label: const Text('Cambiar'),
    );

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        avatar,
        const SizedBox(height: 8),
        button,
        if (errorText != null && errorText!.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              errorText!,
              style: const TextStyle(color: Colors.red, fontSize: 12),
            ),
          ),
      ],
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/editor/profile_photo_editor.dart 

 FILE: modules/features/profile/presentation/widgets/editor/profile_save_bar.dart 
// lib/modules/features/profile/presentation/widgets/editor/profile_save_bar.dart
import 'package:flutter/material.dart';
import '../../../../../core/widgets/network/require_online.dart';
import '../../../../../core/utils/input/keyboard.dart';

class SaveBar extends StatelessWidget {
  final String primaryText;
  final VoidCallback onPrimary;
  final String? secondaryText;
  final VoidCallback? onSecondary;
  final bool enabled;

  const SaveBar({
    super.key,
    required this.primaryText,
    required this.onPrimary,
    this.secondaryText,
    this.onSecondary,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final bar = Container(
      padding: const EdgeInsets.fromLTRB(16, 10, 16, 16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        boxShadow: const [BoxShadow(blurRadius: 12, color: Color(0x22000000))],
      ),
      child: SafeArea(
        top: false,
        child: Row(
          children: [
            if (secondaryText != null && onSecondary != null) ...[
              OutlinedButton(
                onPressed: () async {
                  await hideKeyboard(context); // tambiÃ©n al cancelar
                  onSecondary?.call();
                },
                child: Text(secondaryText!),
              ),
              const SizedBox(width: 10),
            ],
            Expanded(
              child: ElevatedButton(
                onPressed:
                    enabled
                        ? () async {
                          await hideKeyboard(context);
                          onPrimary();
                        }
                        : null,
                child: Text(primaryText),
              ),
            ),
          ],
        ),
      ),
    );

    // Entra deshabilitado si no hay Internet (con tooltip)
    return const RequireOnline(
      showTooltip: true,
      child: SizedBox(),
    ).copyWith(child: bar);
  }
}

// PequeÃ±o helper para evitar reescribir RequireOnline cuando queremos inyectar child
extension _RequireOnlineCopy on RequireOnline {
  RequireOnline copyWith({Widget? child}) => RequireOnline(
    showTooltip: showTooltip,
    tooltipWhenOffline: tooltipWhenOffline,
    child: child ?? this.child,
  );
}

 END FILE: modules/features/profile/presentation/widgets/editor/profile_save_bar.dart 

 FILE: modules/features/profile/presentation/widgets/editor/profile_section_card.dart 
import 'package:flutter/material.dart';
import '../../../../../core/config/app_theme.dart';

class SectionCard extends StatelessWidget {
  final String title;
  final Widget child;

  const SectionCard({super.key, required this.title, required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.black.withValues(alpha: 0.08)),
      ),
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              color: AppTheme.black,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const Divider(height: 16),
          child,
        ],
      ),
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/editor/profile_section_card.dart 

 FILE: modules/features/profile/presentation/widgets/editor/profile_text_input.dart 
import 'package:flutter/material.dart';

class LabeledTextField extends StatelessWidget {
  final String label;
  final TextEditingController controller;
  final TextInputType? keyboardType;
  final TextInputAction? textInputAction;
  final String? errorText;
  final void Function(String)? onChanged;

  const LabeledTextField({
    super.key,
    required this.label,
    required this.controller,
    this.keyboardType,
    this.textInputAction,
    this.errorText,
    this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: controller,
      keyboardType: keyboardType,
      textInputAction: textInputAction,
      decoration: InputDecoration(
        labelText: label,
        errorText: errorText,
        border: const OutlineInputBorder(),
        isDense: true,
      ),
      onChanged: onChanged,
    );
  }
}

 END FILE: modules/features/profile/presentation/widgets/editor/profile_text_input.dart 

